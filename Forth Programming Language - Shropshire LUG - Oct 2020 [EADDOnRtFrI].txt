We are recording this meeting, so by being here, you can send to the fact that if you talk your voice and if you show your face on your webcam, your face could be recorded and put up on the YouTube video.
If you do not want either to happen, please mute yourself and turn off your camera. If you have any questions, feel free to put them in the chat, keeping in mind the public chat will also be published.
So, by doing so, you can send to that, unless you tell me not to, in which case I'll take out your chat message.
So, I will leave it to Mr. Alexander, because I only did part of your job for you, John. John, you, John will introduce the speaker of the month, Karsten Strohman. So, John, I'll let you tell everyone about.
Hi there. Yeah, it's John.
We have been kindly volunteered for old Karsten to give us a talk.
So, subsequently, a talk we had last week, last month even, for an overlook, so we've extended this out, so we've got a, we've done somewhat double-dipped.
So, today, Karsten will be talking about the fourth language, history, practicality, technology, etc.
So, basically, without any further ado, I'm going to basically hand over to Karsten. You will tell me that none of that was actually true.
And hopefully we'll have a good entertaining time. So, thanks very much, Karsten.
Yeah, thank you, John. Hello, everybody. My name is Karsten. I'm from, I'm from Germany.
And I got a little heart attack one hour ago when I prepared for this talk, and I found out that all my texts in the notes for this talk were still in German.
I thought I'd already translated that into English. So, I did that quickly before this talk.
Excuse me. First, the domain name I have is still an unholy mix of German and English. It's free, fourth-schulung, which is German for training.d.
And also, there might be one or more German words or like grammar in this. If you find that, please let me know in the chat or after the talk, and I will correct that.
So this talk about the fourth programming language is built in a way that you can actively follow along.
I've set up a virtual Linux system running CentOS 8. And you can reach that with the URL shown here, free, fourth-schulung, de, port 1990, and then slash system slash terminal.
If you go to this web page, which is open to the public, you will be able to click just on this link. The user there is fourth, and the password is fourth dash October or OCT dash 2020.
I'll quickly show how that looks like. This is the login prompt that you will be greeted with when you go to that page.
And you type in the username force, everyone is using the very same username because behind the back in the system, everyone will get its own Linux container. So we are all nicely separated from each other, and nobody will step on each other.
And then the password is force OCT 2020. And then you log in.
And then you will be greeted with this dialogue from the tool, Linux tool dialogue that asks for the force environment and that is actually the unique name of the container to be created.
Just use some unique value that you are sure nobody else will choose. I use something like test 1234, which nobody with the same mind will use.
Once you have given in your unique value, you will be greeted with a new force or g force installation where you can happily then type in any for stuff that you will learn during this talk.
And I will encourage you to just do that. So if you hear me explain some fourth words, you can go here into your environment and just test them out and see if I if I'm right, or even just telling nonsense here.
Of course, if you have your own Linux machine with force installed.
You can use that as well.
My talk is tested.
And I will targeting the new force system, which is the most popular one on Linux, and it's available on all Linux is in the repositories.
If you have some other flavor of force, and I come to the to the issue of fourth flavors later on.
And you said as well, of course, but be warned that some words and some stuff might be different on your flavors and that is on the new force.
So back to the to the talk first off, why I'm doing a talk about force now force is not something where I earn my living with.
I know people who make a living a good living by doing force programming. I know a couple of ones in the UK, and they are very nice people.
And I'm very happy if I can meet them again after this current situation.
I'm not that person who makes a living from force. I make a living by doing trainings mostly Linux trainings DNS and IPv6, but I do force programming as recreational thing.
So it's something that I use to relax.
So I'm a strange person.
I start in what is force, or why do I use force.
So first forces interactive. It's not technically a compiled only language like C or rust or Java.
It's, it's an interactive language.
It's still compiled because if you if you start compiling words into force.
It's still compiles into native code or some kind of bytecode, but you have an interactive environment where you can just type in force commands and and you get the results directly on the screen, which is nice because it facilitates interactive development.
Piece by piece, build your program and directly tested out you don't need to write code compile test and go back to the editor. Instead, you can just type and test.
And by that you build your program.
It's a very lightweight full force development environment fits into 10 K 10 kilobyte that is so you can cram the force system and the whole development environment that is the compiler the editor, the interactive environment into 10 K of, for example, in an
risk five CPU microcontroller, or even on an old 1970s home computers like the Apple one or Apple two.
It just works perfectly there, but it scales also up to very large machines and it's always the same kind of fourth. So whatever you have learned you can apply that to very small machines, and also very large machines.
It's very scalable in that aspect, and also because it's lightweight is also very energy efficient.
So you can find force in commercial applications, which is important that the commercial application will work like 10 years with one battery charge, because it's like a probe that sits on the ground of the ocean.
It just measures the pressure of the of the of the water to to measure the height of the waves.
And these kind of applications.
You don't want to to fetch the, the probe, like every two months and replace the battery there, being used in these kind of situations.
Despite being interactive and lightweight forces available for many operating systems, and also for many machines, computers microcontroller small and large machines.
So it's very easy to to reuse your knowledge.
I would say I use two systems in my computer career that I never need to replace. One is force because force just grows with every new computer I get and it's always there.
It grows with the, with the new technologies I come to like that later. And the second one is Emacs, which is my editor because also Emacs grows and always gets new functionality in there.
I, it's, it's around for 50 years. So it's not a new thing. This force has been invented or discovered by Chuck Moore.
He used that originally to control a big telescope in the in the US.
And then the, the researchers and the telescope, they, they use the force programming language to, to remote control the telescope and to write the programs to like follow a star or something like that.
And it soon there became the de facto language for programming a telescope worldwide. And then it was in the very, very beginning it was already what we call today open source, because it's inherent in the, in a force system that you distribute that with the source code.
And then in the 1970s, like 1974 and 1975, when the first false versions escape the laboratories, it always came with a false source code, and it was kind of open source, even though commercial force implications exist, and for systems existed
that are commercial and have a commercial license, there's always always have been an open source community around this language.
And other reasons why I use force is that it is extendable and it is, it does not age. So like every 10 years, there's a new wave of new ideas coming through the IT.
That was object oriented programming, functional programming, domain specific languages, unit testing, all these new developments I have seen during my career in the last 40 years.
Every time I was able to apply these new technologies to forth and just extend my force to, to use this. So I'm not bound to any committee that designs the language, or any vendor that might or might not integrate new ideas into that language I can do that myself as a developer.
And that is very unique to the force programming language, I think the other language that allows that is list, which is kind of a close cousin, but just the other way around in how you apply that to force.
So, yeah, a bare bones force system might be might be very bear it might not give you object oriented programming or functional programming or multitasking or anything like that.
But remember you can always add to that and you find online the sources. And it's not that that is a big chunk like the code that makes out of a non object oriented force an object oriented force is something like 20 lines of code.
And that fits on one screen. And it's not hard to understand, even though if you start with force it looks like kind of magic was happening there.
Okay, that's for the beginning. Let's take a look at the language and let's go into the crash course.
So first about the syntax.
Some people say that force doesn't have any syntax at all. I would say it has the most minimal syntax possible.
So force in the source code we write what's called a word, and the word is any sequence of characters separated by white space. And I mean really any sequence of characters.
It can be special characters it can be just the normal ABCD characters.
If you have a system that understands utf-8. It's, it's, you can use Chinese or Japanese characters in there it's just fine with the language, or you can use Egyptian hieroglyphs or even cling cling on.
That's what the, the symbols in the cling on language are called, but you can write in cling on in force and that just works fine.
Not that any other person might be able to read your source code, but if you want to a first you skate your source code that's just possible.
So that's all you need to know.
The words that are made of characters separated by white space and that is the syntax. Everything else is what the developer, the person who wrote that force word designed it to to be.
That's then not really syntax of the language that is then convention of that developer.
That's not imposed by the language. So the first, the force words that we see here are all valid. The first one is what which is word in German.
This here is also just a valid force word you can name a function in in fourth you can name it this and it just would work.
It's not that that is very readable and I wouldn't recommend that just works. You can also name your function 123467890 and that would work as well or you can name it blitz.
So there's no restrictions on what you can't have in the word is it is a white space so no spaces.
Apart from words being separated by white space they will always be evaluated from left to right, and they either evaluate to an executable force word or to a number and that's it.
If a word that you have typed in cannot evaluate to an executable force word or to a number that's an error.
These are just the two things that can happen if you type in something in in force.
Without the safety of a force system.
There are, there's no, there's none. So you have direct control to your machine to your operating system.
And you can crash the whole system. Of course, if you run on the Linux, then the Linux operating system is is mature and stable enough that you only can you can only crash your fourth system.
And that goes down and sec falls and it will not affect the Linux call or other applications running. But if you have fourth running on the system that has no process protection, like on MS does or on the microcontroller.
If you do the wrong thing, it will just crash.
Firstly, it crashes terminal. So make backups there. Of course, you can build your own safety nets, but most developers don't because when they use a fourth, most often they do that because they want to have the raw power.
They want to do, they want to be able to do everything with the machine without the language sitting in between them.
So we are working directly with memory access with pointers. And this is not a language where you want to write the control of a of a nuclear power plant. No, no, you don't want that.
That's so.
So it's the ultimate if expandable programming environment, no rules, no syntax full control about the language and the system.
One defining element of force is the use of the stack. The stack is a first in first out memory storage, meaning the stuff that we put in, we have to first take out to see the stuff that lies below that.
And all the parameters that are given to functions in force, the function in force is called the word we first place them on the stack.
Then we call the function, the function does its magic with the input parameters, then it might have some output parameters and they put the output values on the stack as well for other words to take and consume.
So in this example here 123 we place two values on the stack, and then the little force words dot s for print stack will print the content of the stack. Let me show you that one.
Here in the terminal. If I do 123.
Enter.
It's a response with a green okay and the number three, telling me that we have that I have three elements on the stack and a dot s will print them out.
The pointy brackets, tell me again the number of elements on the stack.
123 are the elements with the number three the right most is the top of stack that is the one that is on the top. And if I want to access part of the stack that would be the first value to be returned from the stack.
So if you have any questions in between, use the chat or open your mic and just ask your question.
So the little words dot prints the value of the top most element on the stack to the terminal.
So if I write 123 separate by space and then dot dot dot separate by space.
It will print exactly that numbers in the reverse order, because number three was the top of stack that is the first one that will be returned from the stack so that will print out three to one.
Let's see that I still have them on the stack dot dot dot three dots enter three to one is the the output and here I do the same same way as shown in the lecture notes.
123 dot dot dot print three to one. So the dot takes the top most element from the stack and prints the value in. Yeah, to the terminal.
So we have the usual arithmetic operators, like a plus a minus an asterisk for multiplication, the forward slash for division and not for doing division without or for the remainder of a division.
Other division always in force always creates a full number. So there are no fractions of number on the stack. It's always a full number.
And what's special about force is that it's using a post fix arithmetic.
So we first place the arguments to the arithmetic operation on the stack. And then we have the operator at the end as last.
So in order to add two to number two, we write two to plus and then dot to print out the result.
And two minus to one minus actually calculates one minus two. So we have two on the stack we place one on the stack, the minus then subtract the top of the stack from the second of the stack, and then places the result back to the stack.
And dot prints out the top of the stack. And 73 mod will divide seven by three and will print out or will put the reminder the will put that on the stack and the dot will print that out.
So let's quickly test that here. So two to plus dots gives us the four to one to one minus dots is one because two minus one is one.
Two more complicated stuff 10 six minus four or really large number. Another really large number minus is a negative really large number.
So the size of the values you can use for calculations really depends on the CPU size.
And here this was running on a 64 bit machine. So I have 64 bit integers to my in my system here that I can use for integer calculations.
So, because we are using post fix mathematics, there's no need for parentheses.
Because the evolution orders always clear from the order of the words.
It's a big plus of the forces and it takes a little time to get used to as a developer if you are used to infix notation.
You can use this post fix but it makes the forces to much simpler internally, and it's closer to the machine.
So the next two calculations, I would invite you to try to calculate the results first in your in your in your head.
There's a 34 plus five multiplication dot. What's the result there.
And if you like, post that to the chat.
And now the result in your head, you can try that out the terminal.
And what's happening here is we put the number three on the stack the number four on the stack. We have both together. So the result is seven.
Then we put the five on the stack. So we have seven and five on the stack. And then we have multiplication so we have seven times five, which is 35.
So what force has calculated here.
And the next one is the same numbers and the same automatic operators, but the different order 345.
Plus. So what is the result of that calculation. Try to calculate that in your head.
And see what the result here is so we put three on the stack. We put four on the stack. We put five on the stack. And then we have the multiplication.
And the multiplication works always as all the automatic operators work on the top stack values. So the top stack values are four and five.
So we multiply four by five, and that is 20.
And then we have 20 and the number three on the stack. And then we have the plus four addition. And that then adds the number three to 20. So the results should be 23.
That's the result that force gives us.
So from time to time if we read force force code, we find parenthesis.
And first, if you come from any other programming language such as see your Pascal or Java or Python.
It's like the parameters that are given to a function. And that's not completely wrong, except that the parameters are not really used by the force programming language.
But the parties are just commands. They are ignored by the puzzle and by the language.
And the only reason for having the comments in the code is for the humans that read the code.
But it is actually really the parameters that are given into a function and coming out of the function.
The convention is that on the left side of a stack command that is on the left side of the double dash, we have the input parameters.
And then we have dash dash. And then we have the output parameters on the right side.
And we have two examples here. The first example is the dot function or dot word, which takes just one input parameter from the stack, which is a natural number n, and it doesn't leave anything on the stack it prints out to the screen.
So that value is being consumed and destroyed.
And the other example is the plus sign, which is the addition, and that takes two natural numbers, and then and the result is another natural number that ends up on the stack.
So this is how you can read the stack commands and I have stack commands on most of the following fourth words.
So let me know how we work with the stack.
There are some words that we can use to juggle the stack values around the first one is called the swap word the swap command and swap exchanges the top two values on the stack.
So if I have here an empty stack, and I place one and two and three on the stack and print that out. The number three is on the top of the stack and number two is the second order of the stack and number one is the third of the stack.
If I now execute swap, I still have three values on the stack, but the order of the top most have been exchanged.
So now the number two is the top of the stack three is the next below, and one is still on the bottom of that.
And if I print it out.
Oops, there's no double need to do that again 123 swap dot dot dot.
The mistake here was that I typed in dot dot without a space, and that is not a valid name. Not yet we haven't defined that. So it gives me an error message undefined word.
So, here I did 123 swap, and then print print print. And the first number to be printed out is to then the number three then one because I've exchanged two and three.
The next word is depth, which creates a copy or a duplicate of the top most tech entry. So it takes an X as the top of stack and it leaves to access.
So 123 dub dot s results in 123 three so the top most step stack entry number three has been duplicated.
And the next words that we will learn is drop and drop takes the top most element and just throws it away.
So after drop.
The extra number three is gone. And I'm still back to 123 and another drop drops.
Number three. I have one and two.
Another drop drops to number two.
Now I just have the number one on the stack and another drop. I have an empty stack of zero entries.
Another drop will be a stack underflow. I tried to throw something away that doesn't exist. That's an error. So the force system gives me here a nice red error warning stack underflow.
The next one is the over and over creates a copy of the second stack element so it's like dub.
Just that it doesn't duplicate the top of stack it duplicates the second of stack and places the copy on the top of the stack.
Another example here.
Let me clean the screen 123 over.
And the result is 123 to.
So the overtook the second of stack, which was to made a copy and place that copy on the top of stack, pushing down all the existing values.
So now three is the second of stack to his top of stack and also the third of stack.
So we have rot for rotate and wrote a rot rotates the three top most stack entries.
Let me drop the top most so that we still have 123 one times rot gives me 231 so it took the number one which was the third of stack and move that to the top of stack and pushed all the others down.
Another rot takes the number to put that on top of stack.
Another rot creates the original order again.
Also the minus rod, which just works the other way around minus what takes the top of stack and places that on the third slot in the stack and pushes the other values up.
And always three times rot or three times minus rot is non operation just creates the same situation as before.
So I already talked about the parenthesis as being a command there are other commands in force. There's the backslash, which comments until the end of the line.
And then we have the dot parenthesis, which will have a same effect as the just parenthesis with the difference that the text inside the parenthesis will be printed out.
When the code is being read. So if you if you read source code.
This can be used to give some instructions to the user that is loading in the source code.
All these words slash and parenthesis and dot parenthesis are normal force words they are not any kind of special words in force they are just created as any other force words, so they need to be separated by white space.
What you can't do is write something like this.
This is a command.
Because force will complain that opening parenthesis of this is not an word that it knows of. So it says undefined word opening parenthesis of this.
What works is something like this.
You have to have white space between the opening parenthesis and the closing and the first entry of your command. That's very important the same with this type of commands.
This works.
And this does not work because backslash this is not a known word in force.
The reason here is because the comments are not syntax, they are executable words, and actually they alter the, the interpreter or the compiler, while they are being executed.
So before we will start writing codes in force.
And sometimes we do mistakes. And especially if you work interactively with the force system, you might try things out and then you later find out that what you tried 10 minutes ago was wrong and you have a better idea.
You have to go away, something that you have already compiled without closing your force environment and starting fresh and losing all your work.
And what you can do is you can use the marker. And the marker is a simple way to set a mark inside the directory or forth words.
And whenever you want to remove, or you want to jump back back to that mark, you just execute that marker. So the marker takes as the parameter a name, and that creates a fourth word of that name and whenever you then execute that name.
Everything that you have defined that everything you have compiled after creating the name will be deleted will be purged will be gone from memory.
So for example, marker dash dash my marker dash dash, starting a marker with dash dash and ending it with dash dash is a convention.
Just a convention you cannot show just ignore that.
So, creating new words.
We create new words with the colon, and then we give the new name of the word we are about to create. And then it's good practice, especially in source code to write a stack command that gives the reader a hint what Hermit is going to that word and what are being left on the stack.
However, that is completely optional because it's not used by the language it's just used by the humans. And then we have the body of the function, which is any kind of fourth words which will be executed when the new defined words is then later be executed
it's kind of a can think of that as a macro, and then the semicolon terminates the compiler and goes back to the interactive force environment.
So let's try out this one here what that was an example. The colon starts the compiler. Whenever a force system sees the colon in the input stream that turns on the compiler and disables the interactive force environment, and the colon requires the next word in the input stream to be the name of the new word.
And this quadrat, because it's a word that will multiply a number with itself. So it will calculate the quote.
What's the English word for that.
Proper English word. I'm not sure.
So it calculates the quadrat of the
of a number.
So basically, and this is the command here, it takes an X, and it will leave an X multiplied by itself. So X times two.
So maybe I should name this one times two.
Let's call it times two. So, and it requires an X to be on the stack. And that's the thing that the developer the programmer needs to take care of that there is an X value already on the stack.
And we duplicate that top of stack value with that command.
And we multiply then the top most values on by that we multiply X with X.
And then we terminate the compiler and switch back to the interactive mode again. And if we didn't make any square. Thank you.
Yes.
I haven't set a marker. So I can't remove this now. But yeah, I just can create another word that has just the same body.
Sum i colon and that's a square
and now I can use this new word is the same way as the building words actually technically there's no difference between the building words and any word that is developed define.
five square dot 25 nine square dot 81 1000 square dot is a million.
That's the way how force developers write an application. So basically you start
with a bare bones force system and then you add new stuff to that force system and you do that as
long or until you reach a state where the force system has become your application.
So that's different from other compiled languages such as Rust or Java or anything like that or
C or C++ where you have a compiler and the source code and you feed the source code in the compiler
and the compiler spits out the application, the binary. That's not the case with force. With force
you'll load your force system. You make changes to the force system and you do that iteratively
until you have your new application. It's maybe similar to small talk and here's a question how
can you show the meaning of the new words? So
not all force systems but some have a decompiler in there especially microcontroller force systems
because they are resource constrained by the memory of the microcontroller. They don't have a
decompiler but the linux version here has a decompiler. So if I do C
square, it tells me that square is dub star. So it turns the binary code back into source
code for me to inspect and that is the reason why force has always been open source because it's so
easy from going from binary to source code again and going then from source code to binary.
If you have a force system you have the source code of that system because we can also inspect
a dup. Now for performance reason dub is not coded in force. Dub is coded in assembly language
and this is the assembly language of dub for 64 Intel based architecture. If I do the same
on a power PC I would see the power PC assembly or if I do that on a MIPS machine I would see the MIPS
assembly language and yes you can also write your own force words in assembly language directly in
the force system if you like to. You don't start with the colon you start with the word code like
you see here code dub and then you write down the assembly instructions and force would or
some force systems have a built-in assembler. Those ones that don't have that built in you
can load that as an additional module and then you just mix force and assembly in the same language
and the same way you can also mix other languages like if a colleague of mine has written a C
compiler in force and with that you can just happily mix C and force in the source code and
whenever the force system encounters something that looks like the C language it will then start
interpreting C and compiling C and then you can switch back to force and write force again or
assemble whatever you like. That's very powerful. So that's about creating new words. So colon
starts the definition square or quadrat still here haven't translated that is the name of the
of the new word actually let me quickly translate that so let's reload now it's square
everywhere the power of emex. So square is the name of the new word and then the stack command
documents what how the stack changes for this word and then the dub and star or asterisk is
the body and that is not executed while we're compiling but it's compiled into the body of
the new world it's then executed when we execute the new word and there's no difference between
the words that come with the force system and the defined words. Now again I have here German
words let me quickly translate these
times three so in this we we use dub again and then we call square and then another star
and what that does and let me do that here on the interactive terminal
it's not actually time three it's
I'm missing the English word for that if you if you multiply a number three times
it's the power of to the power of to the power of thank you so
it's easier in German
so to the power of three we use then dub square star semicolon now I've not used any
stack commands here because they are optional they are only for the humans and now if I use number five
and then to the power of three dot that is 125 because it calculates first five times five
it's 25 times five is 125 and we could even do that to the power of four
which would be then square square type of square square and that would be then five
to the power of four dot is 625 so this just shows how to
use force words that you've created yourself inside new definitions and there's technically
there's no difference between the force words that are coming with your force systems and the
force words that you can create yourself they are all the same and it's just the way that
the force words that are already coming with your system that someone else has defined them
the same way as you would define them here
so I'm translating the the other stuff later you can override words so you can
create new words with the same name as an existing word and you can do really nasty
things there not that I recommend that but let me show you when I do star plus semicolon
that means the the meaning of star which was multiplication before is now addition
and if I now calculate three four star that is not four times three as we would expect it's seven
because the star now does addition and not multiplication a force warns me it tells me
in yellow warning redefined star so it tells me that I did redefine here
and yeah I still have or I have this now redefined and it's not that the original
code is being gone from the force system it's just that it is hidden because if I
use a force word the force system will search in the directory of all force words from the
latest defined words to the young to the the oldest words and when it finds a word which
is the last defined one of that name it will use that and it will not see any older words
any older words with the same name if I have a marker set I can then just remove
the the word and that still creates that so if I if I'm using square
here a square still has the multiplication built in and it still works as before so
it's not that if I'm overriding a word that that will change automatically all other
definitions that have used that words in the past it is just affecting all the new words that I'm
defining from now on so I haven't set a marker so I've currently no means to
really remove that other than doing a cold start with cold and a cold start just reset
the whole system to the factory defaults that is how I started it so I now have a clean force
environment again and square is gone square is gone it's not there and also plus it's now or
sorry multiplication is now multiplication again
or is it
no it's not actually then I have to disconnect and reload
this is what I'm expecting so 3 times 4 is 12 and that's 7
okay the roots of math are valid again
um the force what words lists all the words that are available in the force system and for
new force on linux that is a very long not list of many many hundreds words I think up to 1000
words that is um because it has all these words that that work with the linux system in there
if you have a fourth on a microcontroller that's much less it's probably a page
a terminal page full of words that you can use and you start then extending from that
working with new force can be intimidating at first because it has such a high number of words
but just ignore that you at the beginning you don't need that all you can just stick with the
standard word set that you find in the textbooks
so now we come to variables and how we can work with memory and storage
we define a variable with the force word variable and then any name that we want to give
that variable and that actually creates a fourth word and the execution of if I execute that
force word it will place its own memory address on the stack so let me show how that works
I still variable variable memory location and memory location is the name of the variable
and I'm now switching into the hexadecimal mode so everything from now on that will print on the
screen will be not in decimal but will be in hexadecimal because we will see memory locations
and that's easier to grasp in hexadecimal mode and if I now execute memory location
and print that out oops memory
and if I print it out that is actually the memory location in memory in my Linux system where
this variable is located and a variable can always store one cell and one cell is kind of the
integer value of force it's in a 64-bit machine it's a 164-bit value
so what can I do with that variable that gives me the address I can store data there
so I can take a value maybe 200 and I can
get the memory location with the name memory location and then I use the force word store
which is the explanation mark and that force word will take an address from the stack and
a value on as a second on the stack and it will then store that value in the inside the memory
location so after this command my stack is empty so the 200 is gone and after the memory location
is gone and at that memory location the value 200 has been stored in actually hexadecimal
because I'm still in the hexadecimal mode so it's a hexadecimal 200 not a decimal 200
and I can fetch that again I can read that again from memory I again need the memory location
and then I use the force word fetch which is the the add sign and that will take from the stack
a pointer address so the address of the the memory location of the variable I'll read that
and put that on the stack and the dot command will print it out and yep the 200 is still there
so this has read the 200 from the memory location
so this was the memory location I can also just take that memory location type that in
this is now on the stack we have on the stack one memory location I do a fetch
and now the memory location is gone and the value from that memory location has been
read from memory and has been stored on the stack and then I can work with that like
print it out and then the stack is empty again the the store and read commands the explanation
mark and the add sign are not restricted to variables they work with any memory location
so if you are on a machine where you have direct access to the hardware
and you know the memory locations of memory mapped hardware you can directly interact
with that hardware from the interactive mode so maybe if on hexadecimal 100 there's some
kind of hardware there you can just fetch the value there on linux I will get an invalid memory
address because on modern operating systems I can't just access any memory because there is
memory protection in the system I can't I can only access the memory from my system
from my process not from the whole system
so that was fetch and store
so the the fetch and store and also plus store they work with variables or with any memory location
and think of pointers in the C language or peak and poke in in basic
and of course we have control structures we have something like if then else
and here's a simple application of a control structure let me show that in action it's the
abs word which I write out as absolute
and that takes a number
and it returns a positive number always a positive number so it takes a negative or
positive number and always returns the positive value of that number and
what we do here is we first compare if the number we duplicate then we compare
need to peak on the instructions yeah
zero we duplicate the number and then we compare the number to zero and if the number was
less than zero if it was negative then we enter the if control structure
and we negate
see do we negate yep we negate then terminates the structure and then we close the compiler
so this is different from other programming languages where the if clause if you have
control structure the if clause starts the control structure then you have the comparison
then you have the word then that starts the code that should be executed in case the comparison
was true and then you have some kind of end if or end that that finishes the control structure
in force it's different you first have the comparison
because the comparison needs to place what's called a flag either true or false on the stack
and then you have the if and that looks for the stack value and if that stack value is a true value
it will execute what is behind the if and if it is a negative value if it's a false value
it will jump over to the then and execute whatever is behind then in our case there's nothing
behind then so it just executes there the okay tells me that force was able to compile this
new absolute function and let's try that out five absolute absolute
s t is missing so uh five absolute dot is five minus five
is also a five so this code if we put in a positive number it does actually nothing
it just compares and then it figures out that it's already positive we don't need to do anything
and if it is negative it calls the uh false word negate and negate just changes the
uh the the the sign from negative to positive
so if we work with control structures in force we always need to have what's called a flag
and a flag is any value that is not zero it's the true flag and the value zero is the false flag
and the if takes the flag from the stack if it is not zero so if it is a true value
it will then jump to the code following if and if it is a false value it jumps to the
then or else code we haven't seen the else code but i will show you in a moment and
have a a typo there compares so the smaller then compares the two top most
stick elements and produces a flag so two well one two smaller s let's try that out
one two smaller gives a minus one and the minus one is a true value because that's
not zero just the zero is the false value so this says that a one is smaller than the two
of course to one smaller is zero because that's false one one smaller is also false
so with these comparison operators we always get what's called a well formed flag and a well
formed flag is either a minus one because the minus one has all bits set or a zero which is the
value with all bits zero which makes it very easy to create also a logical expressions without the
need of control structures castan it's less than i'm sure we all understand it sorry yeah less
than smaller and larger thank you it is it wants it's good less than greater than
yeah i should know that and i usually know that but it's it's late and my brain is overworked
so we have all these other comparison operators like equal larger than unequal or not equal
smaller than equal larger than equal
we can also use something i haven't translated another control structure with the else part
the the min here the min word takes two numbers and returns the minimum the smaller number
so the word two dub duplicates the topmost entries so it does the double of the dub command
then it compares the entries and if the first one is less than the second one it just drops the
the topmost the larger one and if it's the other way around then we go to the else and then it does
a nip and the nip actually discards the second entry on the stack so it doesn't throw away the
topmost but the second entry if you don't have nip in your force system you can just
create that with a swap drop so of course here in in gforce we we have a nip so if a one two three
dot s nip should then discard the number two one and three that works if we have a force
where nip is not defined maybe an old force from the 1970s where that word wasn't
wasn't in the standards we can just do nip it's a swap and a drop swap just
exchanges the first and the second entry and drop then discards the topmost entry leaving the
second one there force gives me a warning here that nip already existed but now i have this
one two three nip dot s and it works the same way it discarded the number two so this is like
an example of if a word doesn't exist in your force system you can just create that and i gave
this course two weeks ago on the vintage computer festival berlin and of course vintage computer
festival is all about old machines and we use some old force systems there and they didn't
had nip i was just able to to recreate that and and that is another nice aspect of force that
you can you will never come to a point where your force system is blocking you because it
doesn't support any of the newer stuff because you can always recreate the newer stuff yourself
it's a little bit work but it's always possible and usually it's not too too hard to do
of course there is the words true and false are predefined and they return the well formed
flags and then we have logical operators like and or x or
equal zero and invert that we can use for bitwise logical operations
if we need a well formed flag we can always use zero equals because zero equals compares to the
false value and that will always create a well formed flag either a true or a false
and also that can be used here to invert so it's
same as invert for flags because if i have a false and i do zero equal because
false is zero the result is a true and if we have a true on the stack and we compare with zero
equal then the result will always be a false
so because of this property that the true has all bit set and the force has no bit set we can
use this as well to prevent the use of if so here in this example the first example
we have a word foo that tests if the
the word that comes in the parameter that comes in is is zero and if it is zero it puts
14 on the stack as it leaves zero on the stack and that could be just abbreviated to zero
equals 14 and because the zero equal will compare to zero and if it is zero then the flag will be
all bit set and then we put the 14 on the stack and then we do a bitwise bitwise and and if we do
a bitwise and with all bit set the value will not change it will still be 14 if zero equals
is false it will put a zero on the stack and if we do a bitwise and with the number and zero
the result will always be zero so that is then the same result as the the previous
and now we have loops and here we have an endless loop an endless loop we start with begin
and this loop will just we'll start with the number zero on the stack we put that on the
stack before the begin it then duplicates whatever is on the stack and prints it out
and then it increases it increments the stack value by one and the again jumps back to begin so it
is a accounting loop that prints the loop number all the time and it will never never terminate
because it's an endless loop of course most of the time we want to have loops with some
termination in building so we have while loops we have also until loops this is the while loop
and the while loop starts with the word begin and then we have any fourth code that produces
a well-formed flag so here we have an over zero greater than and that produces the flag the greater
than zero greater than produced the flag and then the while consumes the flag and as long as the
flag is true it will go into the body of the loop which does increment the stack value does a swap
divide by two swap back and repeat and the repeat jumps back to the begin
after begin it calculates a new flag again and then it either branches to the code of the body
or branches out to the nip depending on the the flag that is being calculated
um yep and then we have the the question do which is just a counting loop
that takes the two values from the stack the end value and the begin value and it executes the
code between question do and the loop from n1 to n2 times and if we need to loop counter
we can place that on the stack with the fourth word i and remember i here again is not
any special words or any special syntax it's just a normal fourth word that just grabs the
the counter from memory and puts it on the stack and this calculates the factorial of a number
and let me quickly just paste this in
so it compiled
this and it wants me here because there was already a literal called fac
predefined and i redefined that now and now i can like do
factorial of five is 78 factorial of nine is uh uh 58,980
so this is how we do loops in enforce
so um sorry i've missed the question here about the well-formed flag
a well-formed flag is is any value on the stack that is either zero which has no bit set or is
the minus one which is the value that has all the bits set
there's also a non well-formed flag which is any other value that is true but it has not
all the bits set to to one
so sometimes we want to communicate with the outside world we want our application to do
something meaningful with a word emit we can print an ascii or utf-8 character on the screen
so we can write 97 emit which is the ascii value for an uppercase a
we can also write char a emit the word char reads the next character from the input stream
and puts the ascii value on the stack and then emit takes the ascii value and prints back the
the character with that we can create all kinds of fourth words that prints out text of course
there are a couple of words to print out strings already available like
you can do something like this hello world
dot quote is the print command
and it's important that we have a space between dot quote and then the text because dot quote is a
force word and for the force system to recognize that as a force word it needs to be separated by
spaces and then as the input parameter we have the text hello world and the last quote is just the
end marker for the the text string and then the semicolon terminates the compiler and switches
back to interactive mode again and now I have a new word called hello world and I can execute that
and if I execute that it prints out hello world I can decompile that hello world and
now this looks a little bit different it tells me hello world is a memory address and a b
and a type command so what is that that memory address is actually the memory address where
the string has been stored I can use that memory address and then some counter and use dump
and that will print out the memory 100 bytes hexadecimal bytes from that memory address
and we see that memory here that has the string hello world or hello world in there
and then the rest is just zero it's unused memory in the force system
and the the b actually the b is the length of the string a hello world or hello world is 11
characters long so that's hexadecimal b and type is the the primitive print command of fourth
it takes the the length and the memory location and then it prints the the bytes at the memory
location for the given length in asky we already have seen variables and that they can store
stuff in variables there sometimes we need more space than just like an integer
and we can allocate more space with the force word a lot for allocate
and here we do that in addition to creating a variable the reason here is that if we first
create a variable and then allocate more space then the space will be directly following that
defined variable and we will have a symbolic name for that memory location and for that chunk
of memory that we have allocated there so this actually will reserve 21 cells of for storing
integer values in the memory it's 20 from a lot and one from the command variable
and then we can use address calculation or pointer arithmetic to work inside that memory
and to ease that and make force portable we have this word cells that then always gives back the
amount of bytes that are in one cell in one integer location and that is two bytes are in
one cell for an 8-bit or 16-bit CPU it's four bytes in a 32-bit and it's eight bytes in a 64-bit CPU
and let me show how that works
so I do a variable memory and then this I give us 20 cells a lot
and now memory itself gives me memory gives me the memory location
and from that memory location onwards I have 21 cells of memory that I can use if I dump 21
memory cells memory 21 dump that is the memory location and it's nicely initialized initialized
to 0 from my force system here and now I can say memory I want to store 200 in memory I want to have
that in location 5 so I calculate five cells and add that to the pointer of memory and store
then the 200 in that location and if I dump the memory again I should now see
somewhere here
the 200 I don't see it
where's my where's my error here
something wrong 200 memory gives two values on the stack five cells give three values
it's a 200 memory address and 28 which is five times eight in hexadecimal
I add that
and we have the new memory location and I store that into that memory location
we'll expect now I'll expect now if I dump
do you see that
yeah it seems too too late for me I don't see the 200 in there should be visible somewhere there
oh no so it's the the address is d0 and I'm just not dumping enough it's here
so 200 is we see that here in the memory address that I highlighted and I can now fetch the the
same memory again if I do memory five cells plus fetch print I get the 200 back so memory
places the the pointer to the reserve memory five cells calculates the index and then fetch
fetches the 200 at that location if I fetch the location number four it's a zero because I haven't
stored anything in that location so I'm almost done with my little false course here
um with the tick command I can get the what's called an execution token of a word
and with that I can create vectorization and I can use code as data so I
can do things that the the list people do I can treat code as data store code as data and
execute data as code and of course there are commands to talk to the operating system like
executing a shell or setting the the default directory with setdir or even create a word
that starts an editor like this little snippet here creates a new word called vi
so what this does is it the colon starts the compiler vi is the new word
s quote stores a string and the string is the string vi and system gives that
string to a system operation shell which is then being executed and if I now call vi I'm in
in the vi editor inside my linux and I can do whatever people do in vi uh edit source code
for source code maybe and if I leave the editor I'm back in my force system again and of course
that works with emacs and nano and whatever editor you like and the last bit here is to load
some source code and we do that with include command so I can launch an external editor
like vi I can write my fourth source code in there I can jump back and force between the
interactive mode my fourth system test something out copy that in my editor or copy from the editor
back and then save that to file and I can then import my source code into the fourth system with
include command and that will then load that source code the same way as if I have had that typed in
and of course I can later than save my whole force system as an application what's called
a turnkey application which then contains the whole force system plus my code my application
and I can hide the fourth force system so that the the users don't see
that is actually written in force and unlike with other systems that have an image-based
system like small torque or or lisp systems force is so small that it doesn't really
matter much to have the whole force systems in there because if the force system is just 20
kilobyte and my my application is another 100 kilobyte that 20 kilobyte doesn't really make
any difference in today's computing world it might on a microcontroller and and there you
can just compile to native code and just trip your your force system out of your final application
okay that concludes my little force
course here my training my talk I have some example applications but this is just for you to
to look at and enjoy and maybe test out yourself but I'm now here if you have any questions please
let me know
all righty so thank you for for that it was my mind's like overloaded so it was very cool thank you
and john I know you're thinking it doesn't take much for my mind to be overloaded
well yeah what can I say so I am going to go ahead and stop the recording now so anyone
who wants to not be on video will be will not be
