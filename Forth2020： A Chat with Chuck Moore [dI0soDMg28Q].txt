Okay, we want to see who is going to start you.
Okay, we have written some questions for you.
My first question is, we don't see Chuck much online, and I'm very interested in what he's doing now and is he still working on and with Ford?
Yes, of course.
Can you hear me?
Yes.
Yes.
Okay.
I have a wonderful version of Color Force, which I use almost every day.
I'm not doing anything impressive with it, just messing around with computers.
Basically I'm retired.
I spend a lot of time exercising, trying to stay alive.
It's a very pleasant, very pleasant life.
And I certainly don't want to be under any kind of pressure to produce things.
So I'm basically not.
I have a number of applications in Color Force that I enjoy.
They are emphatically not portable.
Forced to me, I agree with Ulrich is a personal language, and I'm doing it my way.
And I would be happy to share ideas.
But no one would be interested in my fourth code.
I think we all interested in everyone's ideas and especially in yours.
I would love to see it.
Sometimes maybe I can show it to you, but I'm not set up to do that. No.
What's the computer are you doing at the moment?
Sorry.
Are you doing it on the GA 144?
Another computer, a special computer maybe.
It's on a PC.
I've got a 4k display.
And it's all tuned to 4k.
Although I have it parameterized, so I could display it on 2k.
It doesn't work very well.
That means it's small screen.
Okay.
55 inch.
Big screen.
Okay, 55 inch 4k display.
It's a PCL television.
It works just fine.
You only do force on it.
So other things.
I browse web and YouTube.
Okay.
That is my fourth display.
It's very nice to meet you.
We have got an old club here.
From 1979 or about.
Okay.
We are rather active still with a few members, maybe 13 members are active.
And more than 100 members are there, but not here normally.
And we're all very happy to use forth because it's very flexible.
And it's very basic. You can do very smart things with a few.
It's always been my favorite language.
I'm impressed.
I'm impressed with how many people are interested.
I gave up long ago.
Trying to promote forth.
It's a hard sell.
And I would just rather use it myself.
I can understand that it's really a hard sell.
Beautiful code with it's most people only do a segment of relations.
And that doesn't help.
Beautiful code is right.
It's.
Back in the back in the old days.
I thought that people would write their own programs.
And it forced to be a great vehicle for doing that.
And it would appear that a thousand people.
Out of what eight billion are willing to write their own programs.
Yes.
Most of the people like to copy and paste only.
Question for check more.
I really wonder what your most used application does.
The application I use.
The application you mostly use.
It's a clock.
I have a, I have a screen full of numbers.
The date and time.
Julian day.
Moonrise.
Moon set.
The number of days till things like they like savings time.
All of the.
Time questions that I asked myself.
Have got the answers.
That sounds nice.
Thank you.
One thing I have done.
Recently.
Is a new character set.
You may be aware that I've done many, many different character sets.
This one is the prettiest.
And the simplest.
And it has a unique property.
And normally what I have been doing.
With me, I would generate.
A character.
As a raster.
Library.
I would have.
What 48.
Symbols representing the characters.
Stored.
In rain Ram.
It finally occurred to me that.
Computers are much faster than they need to be.
So instead of storing the.
Characters I store the code that generates the characters.
And when I wanted to display one, I compute it.
Computers are pretty fast to do that.
With both percept will delay.
And it saves memory.
It adds flexibility.
You can edit your characters on the fly.
And you can invest.
A fair amount of work in calculating a character because it
doesn't matter.
So I've got pretty characters.
Available on demand.
I encourage people to design their own characters.
It's fun.
It's easy.
And it gives you another customizable.
Aspect of force.
Yeah.
Very, very nice.
So there's something that is called display post script on,
on, on Mac OS 10, for example, or I don't know whether it's called
like this.
So this is something like display force.
A force program runs when you display text.
Because it draws the characters.
Yep.
Yeah, great.
I like that.
I'll show you the characters sometime when I can.
They're very pretty in 4k.
I can draw very large characters.
They're all scalable.
And some curves.
Chuck, this is Don.
You gave a talk, I think it was last fourth day where you were
writing directly to the memory buffer.
That's what this system you're describing as you're writing
directly to the memory buffer.
Oh, yes.
You have to have a kind of speed.
If you go through the windows.
It's, it's what she's doing.
Hi, Chuck.
This is Carlos here.
Hi.
From the interplanetary networking special interest group.
I know you have been for many years interested in a space and
space exploration.
What have you been working at some point about the delay
tolerant networking and interfacing with force.
What is called the team.
I don't understand.
DTN is a protocol.
That use environmental protocol encapsulates the TCP IP or LTP
like lighted transport protocol to connect with the space.
It's used in the international space station and also in much
rovers.
And I,
I've been looking to different languages to interface with DTN.
We are working with Pinto surfing this in this project about
interplanetary internet.
And I would like to know if you have been interested at some point
in this kind of communication.
I'm, I'm interested, but I've, I've done nothing in that direction.
In fact, I haven't even been able to get onto the internet.
The tools that windows provides are.
Oh, paid to me.
And I've just been forced to deal with things locally.
Thank you.
Hi, Chuck, my name's Bob Flanders. It's a pleasure to meet you, sir.
Yeah.
Somebody just brought up the original listings.
Here, Bob. Nice. Nice to meet you. Nice to see you in the group.
Nice to meet you too, Peter. It's been a, it's been a long time coming.
There's kind of an interesting little story about what's on the screen on
2011 or thereabouts. I got in touch with Chuck to ask if he had any old
code for the IBM 1130, which was the first computer he wrote fourth
of fully working forth on this. I understand it. In fact, the name of,
the first computer he wrote fourth would have been F O U R T H had it not
been for the 1130s limited file system, which only allows five characters.
So it had to be named F O R T H to be a file on the 1130.
Just kind of fun and has led to the idea of it being something that we go
forth.
He sent a message to him asking if he had any old code for the, to be 1130
and he said, yeah, I'll rummage around and, and he'll take a look
and see what he has and he found this.
And he sent it to me, but I missed the message or something.
Well, a few years later, I guess it was 2017 or so.
Carl Clanch, who is a fellow IBM 1130 enthusiast,
sent me a message that he had spoken with Chuck.
And Chuck had said, I think I send it to the sky Flanders and
but I've he'd since gotten rid of the papers and so I rummaged around
in my Gmail and I found it.
And it turns out it's either a pre version one or pretty close to version
copy of the code and the basic kernel, the, you know, the assemble level
words and then the additional words on top of it.
And I've had a tiny amount of
contribution to helping Carl get it working on the on IBM 1130 emulator.
And Carl actually has a working IBM 1130.
And
he's he's gotten it working. There was one critical word that we probably
would all be completely lost without had it not had that wasn't there in this
version, which was period.
So he couldn't print out the top of the stack.
I think that the top of the stack may have only been shown in the indicator on
the on the 1130 for the for the accumulator.
And it was a very interesting, very interesting bit of work to to put it
together and get it running. There were there are some typos or some not typos
but some some handwritten notes on the code and notice some things that needed
to be adjusted a little bit. Maybe also we made typos putting it in.
And there is there's actually floating about out there a version one fourth of
the IBM 1130.
The way I became interested in forth personally was I was hired by
MCI telecommunications
like 1986 or thereabouts.
And I had no fourth experience but a friend recommended me.
And I came in and the guy said well listen let's let's give you a try.
First thing I want you to do is write a word that shows a time stamp.
So I fumbled around and wrote a time stamp then the next thing he said is I want
you to implement drivers for a multi port serial card.
And then he said okay you got the job.
And I ended up working for eight years using LMI fourth under some
DOS extender to implement a system that ran on.
At the end I think it was nearly a thousand of what were called site
controllers, and they were put in their co located at the various MCI
facilities and talk to digital cross connects and extended extended
subframe monitoring units and it would send all the information back to
a central computer which would then use its interface support to do
things like you know a customer call up say hey I need a circuit from
Washington DC to Los Angeles and they would go into the digital
cross connects hook up the T1 get it all running and then you know go out
and get it delivered to the customer at their end points to whatever
provisions were necessary.
And it was very cool and interesting system I haven't done much with
fourth sense.
But I'm always like I'm always looking backwards like oh I want to do this
I want to work on like I'm writing 1130 emulating and things like that so
it's always an interest me to do things with older kind of not
necessarily New York.
But I program and C sharp and for us.
Let's do a lot of SQL stuff on you know it.
Anyway, pleasure to meet sir thank you so much for this is brilliant.
It was brilliant that is brilliant and shall continue to be better.
I can, I can add a little bit to the 1130 story.
It isn't as if I was sitting in an office working with the 1130.
The 1130 was on the abandoned production floor of a textile mill.
It was a huge room about 200 feet long and 100 feet wide.
The next center of it was this 1130 which had been delivered by IBM.
And nobody knew what to do with it.
Except me.
And so that was the environment in which forth was invented.
It was challenging in many ways.
Yeah.
The 1130 if there hadn't been 1130 my high school.
This was about 1972 when I started using one.
And I that time I had no understanding of what I was doing.
Venman for the 1130 probably would never have gotten into computing.
But that started my career.
First minute computer.
Yeah, yeah.
I call my first personal computer.
Hi Chuck.
Hey.
We've met a couple of times and.
Many of us here will remember the.
August 1980 edition of bites where you.
Introduce the language to a much wider audience.
But that was the time that you felt that the software had been done.
And you are now looking towards the hardware.
Could you.
Could you tell us a bit about.
How you made that transition from.
Software to hardware and and and you you move towards the.
The Novics.
Period of force history.
Yes, I did feel the software had been.
Perfected in the.
In the context of fourth.
What I was doing at the time.
Was.
Putting off putting forth on many different.
Computers.
And interfacing it with many different devices.
And this, of course, is very easy to do.
That's why fourth.
Exists.
But.
The interfacing with many different devices got very frustrating
because these devices were badly designed.
The interface I had to go through was.
A little bit more.
Baroque.
And I got kind of tired of doing that.
And I said, well, I could design a better interface.
I could design a better computer.
Now.
People didn't do that at the time.
This was.
Business of someone else.
So I took really a leap of a leap of faith.
To abandon software for hardware.
I actually didn't because I had to develop the software.
To design the hardware.
But thereafter, my software efforts went in the hardware direction.
And simulators and layout tools.
It was very rewarding.
My, my hardware worked.
And it worked much better than anyone.
Expected or even would admit.
And I'm still doing that in the sense of.
The greener rays.
Multi processor chips.
They're incredibly simple.
Incredibly effective.
And totally unpopular.
So forth hardware is just as.
Unacceptable as for software.
Yep.
And that's, that's absolutely fine.
The, that's a classic.
High light for like everybody here would imagine other people.
Don't understand.
Hi, it's Howard Oakford.
We've met a couple of times too.
I'd just like to say thank you.
You've made my career in.
Programming much more fun than it would ever have been otherwise.
The, if I wasn't flower is bloom.
Thank you.
back in the year when Australian symposium here and but and I've been using forth since the early
80s you know I started the big project with that and I've been using it ever since and yes you know
a lot of people won't admit that it works so well you know that's true it was a hardware and software
and it also makes the hardware a lot simpler we don't have to use any complicated hardware
and you know like that that was my original fourth board I did up you know with a Rockwell
chips etc and then you know I ended to a module you know a little credit card size module but this
is mid 80s and and and that was okay mid 80s and now I use the P2 multi core processor with 64
smart pins etc and and so and I so I do a lot of embedded control but this is a this is a question
I really wanted wanted to ask you you just mentioned the greener rates it's got all these
processors on there I've got these the propeller parallax propeller processor we've got eight cogs
well eight cores it has hub ram so it shares everything and every every one of those cores
can access all the IO equally but when I look at the greener rays I can't figure out how I can use
it you're saying it's an effective processor what has it proved to be effective in you know
really how can I use it for general embedded control and smart stuff
that's a good question it has 144 computers they aren't exactly cores they're independent computers
they communicate with one another and the ones around the edge communicate with pins
so if you want to control a pin you have to use the computer which is attached to it
and that computer pretty much can't do anything except run that pin and communicate with its
neighbors so you end up building a little network of computers not 144 but maybe half a dozen
that all cooperate and communicate in running the protocol on that pin
it's a it's a fun thing to do it's totally different than any other computer where you
would just run a serial processor your your whole attention is in coordinating the efforts
of as many independent computers as you want now I don't think I've done an application with more than
about a few dozen computers so also Chuck so in talking about applications what what do you what
if you had to showcase an application so look you know look how well it does this
and and I'm bearing in mind too that well what you said already there's a bit of work setting it
all up for those cores to communicate with one another or you know those little CPUs to communicate
with one another I'm familiar with the whole architecture but what would you say which you
know you could hold off an application and say man you know this does it so well
well one obvious applications to run forth to you can use some of the some of the computers
to drive a display you can use some of the computers to read a keyboard
um and you can put them together to run forth I haven't done that I've never got around to
doing that although I got close we've got each computer has 64 words of RAM
and one of the computers interfaces with a
flash memory so there's infinite infinite amounts of data available
another set of three computers can communicate with DRAM so what you want to do is set up a
system whereby you read code from flash you store it in DRAM and you read it back from DRAM and do
whatever you want to do um yeah so so we're with you know so you know I'm wondering why you haven't
done a pc with it yet come on you know you can do it but the thing is okay so I use chips you
know so so that one's got 512k of RAM that and plus all the 4k RAM on each cpu etc and
so it's really easy to make it work and and if and I talk to an IO and I can even instruct the IO
to do something by itself it's a smart IO it has everything built into it I you know I keep
racking my brains looking at the the green arrays and I can't think you know like even if I could
get it to do something it boy it'll be a lot of work you know it'll be fun but it'll be a lot of
work to do it and you mentioned memory and displays for instance yeah well there were a lot of more
effective ways of doing displays but I can do a vga or even a hd display from the RAM on this one
but I have to add bolt on all that RAM onto the green arrays you know I'd really love to see a
green arrays one that was had less cpu's had a bit more memory on each each one and and and and
more access to the IO and it was like that would be really great you know you know 64 cpu's we get
about 144 give me 64 and you know as you said you don't need to use many we'd love to do that we've
had plans for doing that but we've never been able to make such a chip
right yeah we'd have to integrate someone else's memory onto our chip and that isn't easy to do
yeah well yeah I appreciate it I just wanted to ask you that question because it's like it's
it's the one thing that bugs me it's like these fourth chips right going right from the early days
an ovex and all that and they're all really great and and and then you know like I like I've got
21s I've got they the trouble for shabams and everything like that but I can't figure out
how to use a green array so I'd really love to see some application I'll even forget about
application notes but just by showcase something to showcase that particular chip power was used
really well well the the biggest advantage of the 144 is it doesn't use any energy
so somebody put a lot of energy in to make it work though that's the trouble
yeah well thanks Chuck yeah no appreciate it all very much all your work
we let me know when we love forth the other question can I I just wanted to ask you nothing
to do with technicals thanks but we often talk about how how is it that we can really promote
forth you know it's just that mindset you know you've you've had way more experience with encountering
their opposition and with with people accepting forth and it's like well this before I had forth
built into the chip and silicon on this particular p2 chip and that was a hard task to get that done
at the time and but forth is a dirty word you know people just don't like companies don't
like mentioning it this is what we don't do you see anything that would help break down that barrier
a killer app we've been looking for a killer app for 50 years and haven't found one
no well the apps of these seas you know I think I think most of the forth use you know I've always
used forth on micros embedded and and so it's built into airports and roadways and and all
kinds of vending machines anything you know and so they're all out there people just don't see it
but it keeps going 24 seven and it's also my my prototype language that I use you probably
you want a prototype this you know people are used to using breadboards or forth you can move
stuff around like that you can fritz all you like with forth and it's very quick so you know I have
a project now where they are saying hey you know do it with Arduino you know C and everything else
like this and I'm thinking they can ask me but I'm still doing it my way because you know I can get
it done but yeah but it's just that opposition to it and I don't know if there's anything we often
talk about it on our group and forth 2020 how how we can get young people interested it's not
going to be a killer app I think it's going to be the easy use how they're using it make it's how
to how to make use forth you know can use forth easily straight away they say I have a question
for Chuck and Chuck it was the sun force in bios or open force open how was the name open os
open boot open boot from San Celeros yes exactly open boot was this not the fourth killer app
because this was installed in so many computers and also on the one laptop per child I know
this was a really big a really big installation of force yes that's true but bios is such a
obscure application that it didn't attract any any any any attention it was a technical
trial the attention that open boot attracted was attempts to replace it with conventional
software that didn't work forth didn't work to because there was not an industry behind it
that's always been a problem we lack large-scale support
yeah intel came along and and killed open firmware open not open boot open firmware
um and yeah intel was responsible for uefi and that killed open firmware
but forth really doesn't need corporate support to prosper it's it's an individual thing rather
than a collective as you did check with your um green erase talk on um you did a discussion of
that video how you got the 144 chipset to drive the video I was very impressed that you don't have
generic video hardware driving the video in your demonstration you had the green erase chips
each programming the timing and that was significant of how you got the green erase
chip to do video that wouldn't be normally required just to produce an output for people to see
in applications which don't really need consoles if you manipulating data
you work the data and you produce the storage of the of the output for the for later
display for people to see and so the video display was just just a really fantastic
ability that the trip array could actually program and the speed I think was absolutely
significant was the the power savings that your trip said that nobody else could do
and it was a lot of fun to program that dga and it was it wasn't easy timing it was a big
problem and um it was just fun I would say so too um it's quite unique that you've got
this hardware and you interfacing the green arrays into that hardware so there's another
incredible example of what the green erase chipset can do
it can bit bang anything it's got it's got the speed and this is with a an obsolete geometry
180 nanometers this is this is abandoned yes competitive with uh with the uh
oh 10 nanometer geometries you could equate the the the green erase chipset to be a risk processor
where everybody's going to assist type processes with multi with multi instructions
what you can do on a risk processor like the green arrays it's so much quicker it may need
may need a bit of effort to do the stuff that needs to be done but clearly the number of
instructions to do the work supersedes the performance that any of the standard processes
can work with and at the cost of power which is so much cheaper on
I've got to jump in here a little bit about programming these machines chucks machines
I was one of the first novice programmers and one of the early uh green arrays series of processors
Jeff Fox and I at the beginning were doing our darnedness to pack as much code as we could
into those 64 words of ram
over years now we found that the smaller amount of code the smallest amount that you can put into
a node lets them use the least power because each node is cooperating sending messages between them
and when it isn't running it isn't it's only got leakage power going
so look at for the earlier speaker about getting into green arrays programming mind mode
look at the um examples that are on the green arrays website you'll get a lot of that
one of the things that I did sort of is a skunkworks program with a good friend of mine
bill minch who was also an early programmer for the uh I think it was the 24 processor chip
was to implement a virtual machine to execute e-forth and we put bills bill was the originator
of e-forth and ting has taken taken off with it in assembly language we did it all in high level
and we built a virtual machine using I think it was three or four of the nodes
to execute e-forth op codes eight bit op codes directly and that has facilitated actually
it's been moved and uh Greg Bailey's version of poly forth fourth thanks code is now running
virtually on the novic on the green arrays chip and all the development that's happening currently
is being done in standard fourth you do not need to know the details just like every other processor
so take a look at those application uh write-ups on the green arrays website
for example if I may 10 words of code forms an ethernet manchester decoder and receiver
converting the wiggly signals on the twisted pairs into bits going to the next node
wow
you know I I listened to all this and I think wow this is there the stuff you guys are doing
are incredible little chunks right and then there's a question of how could something like
fourth be paid how do we take forth to the next level how do we get it to you know push it into
the future I'll tell you something you know I watch this one guy on youtube his name is deaf
dearly and he's trying to deal with taking a video card and getting it to run in a pcie single lane
on uh some of the new raspberry pi compute boards
if if you could do something like build a fourth driven
um video card with an open interface that could be you know could be added to the
drivers and such could be added to that would have some kind of a standard interface
that's like you know we'll work with open gl or I don't know what the current the modern
of the current video standards are if you could build something like that that would then sit in
like a pcie one one lane pcie slot you sell a billion of those because they repeat the very
the the cm4 the raspberry kai cm forced things are taking are are becoming incredibly popular
a lot of builds small um like you know systems with all with a bunch of
slots and stuff like that's more multiple cp news and then having a you know a pcie card or something
that's sitting in there to show have a video it seems like busy building pop thank you
track is busy building a thing called hd fourth from his last um this
from his last discussion um and that seems so significant what he's working with
on an hdmi interface i'll be interesting to see further development that he's working on on his hd
fourth
the hd fourth has evolved into what i call you hd fourth you even better for the 4k display
wow um it's running on a pc
x86
it's a unique characteristic is that a lot of the code is an assembler well is in machine language
and there's no assembler there are uh hex op codes for the x86 instructions
now i had to memorize those op codes
um but it was as easy to memorize the op codes as it was to memorize the assembly code
and it gives you beautiful versatility and efficiency
completely unportable
but that's that's what i use i call it color fourth but that's that's the versions i'm using now
and it is the nicest fourth i've ever had because it gives me the closest interface with the hardware
on the other hand in the old days when you wanted to interface to a chip
or a board that chip or board was documented
and you could really download the spec sheet and uh and work with it
but nowadays there's no documentation
the best i have found is in windows but windows is incredibly complex incredibly obscure
badly designed almost impossible to work with and i work with it when i must
but it has turned me off trying to interface with the larger world
as i said before i've never been able to figure out how to get on the internet
the world has changed and i'm afraid it's changed in such a way as to disadvantage us
the uh what calls hackers you're supposed to sign on
to the corporate vision of computers and if you don't or can't do that you're being left behind
that perhaps some of you know uh Werner Vinge's
science fiction novels he has one called uh
oh fire in the sky something like that in which
the problem of buggy enormous software was mentioned
the spaceships of that era were programmed in some obscure language
that nobody could really master and it was determined that you should improve rewrite the
software so that that was simple clean bug-free and entire planets
uh attempted to do so they could not reproduce all of the obscure bugs
in the existing software so it was not useful on existing spaceships
and the whole project led to enormous costs effort and failure
that would equate in today's view with trying to reprogram windows say or linux
in fourth it probably can't be done it certainly is not
sound like much fun because you have to reproduce the bugs
who wants to reduce banks you want to get the bags out
uh
for instance what you really need is just an ip stack and internet or wi-fi interface
and once you have those you're pretty much good to go
sorry the hard part is the wi-fi interface due to proprietary firmware though
yes exactly um that that's why i went to the 144 rather than try to interface with the
existing world i wanted to try something different something standalone now the 144
could drive a gpu
um i don't know how to do that i don't even know how to find out how to do that
if it could be done i mean if it can be done of course but whether you can figure out how
is a completely different question and i've given up on that
chuck here's a challenge if you were to develop the 144 to do bit corning everybody will stop
using the gpu processors and the sales of the 144 would go through the roof
you'd be making money over money because the the people out there wouldn't realize just how fast
these 144s could process the hash tables
quite right but
among other things that takes money to develop such an ambitious application
and we don't have any money oh right okay i have a have an open question for you chuck
if i may first of all let me say that i'm feel very honored to speak to you today
i mean fourth for me was a fantastic concept since the 80s when i was a student so definitely
it's a wonderful experience to speak to you now for the question is related to iot since fourth
is by design very very efficient in terms of power consumption in terms of processing efficiency
i'm surprised that iu fourth is not more commonly used for old developments based on iot where of
course energy consumption and responsiveness and real-time aspects absolutely critical what do
you think about this i think that's an absolutely wonderful application area and greener raises
projects which are trying to address that the fact we use very little energy
is an o-brainer but
we haven't found the killer app
if you will next week i have to go and explain to a professor at university of wyoming
why the fact that we don't run standard high-level languages in a pair of streaming glasses
is not a killer of our technology the point is the reason why people don't use
our chips is that we don't have these giant fat libraries of crappy code which they can glue
together which is all they know how to do they don't know how to write code they don't know how to
program in the story
well that's the first i've got a question for chuck kiv i may
yeah please go ahead ken um
it's a historical question chuck um when you made the transition from software to hardware
in the very early 1980s did you prototype any of the early fourth hardware using i guess ttl
at that time before you before you move to the the the gate array of the of the novics did you
prototype any of that stuff
thanks
yes i i did
i did build a prototype of a fourth computer in ttl
or famous chips which was one of the proofs of principle
but then i moved to simulating the gate array
as a more
helpful
design tool in fourth so the fourth
fourth hardware prototype didn't really wasn't really helpful didn't go anywhere
it only helped to convince some other people to support the uh gate array
okay thanks that's that's quite fascinating so i guess you were on the transition between
building prototypes and hardware to simulating them by 1981 82 i guess we had 16 bit pcs and
and simulation became a reality yeah
so i i see jared yeah that's right yeah uh hello everybody
now we know you're muted now you are muted
so we just had a couple of words and then uh your mic went off
no no no no no no sound we can't hear you it just broke yeah
uh-huh now comes the mic
no sound can you hear me yeah yeah yes sounds good no no no no no no no no not now
not now that's strange it was just uh again just a word maybe we'll log off and log back in
of the zoom like drop if you're having problems with the audio sometimes that fixes it yeah you
may get a message or reinstall the zoom software like it happened to me reinstall windows
whatever you want to drop out i want to come back i put on the chat uh something that jack will
love to see i will put this on the chat uh probably you have seen some of you i am
watching i started watching yesterday on netflix the billion dollar code battle
of over google earth and a german company called deravition it's absolute amazing the fantastic
film and this has to do uh with this killer app we were speaking uh before this is very this is
very interesting to watch thank you okay i've got a question for chuck um yeah i just i'm just
curious about the changes in fourth from the sort of the classic fourth from the early 80s through
to kalapur and some of your observations and reasons for the kinds of the way fourth has gone from
from the classic fourth to the fourth you're using now what was some of the reasons that
drove some of those design decisions in the more recent versions that you're using now
wow fourth was originally an interpreter
and i had to learn how to make it into a compiler and that was largely a question of confidence
the the model i used was a belgol developed at stanford
and i was a graduate student at stanford and there's this team of half a dozen people
who wrote a belgol compiler
and i said well if they can do it i can do it and so i wrote a standalone fourth that was the first
one the criteria was to make it simple because i couldn't do anything complicated
and i think all of my later developments of fourth implementations were to try to make it simpler
originally fourth had a threaded dictionary and that hung on for a long time
perhaps until um u h d fourth now i don't have a threaded dictionary i have a dictionary broken
into pieces each piece there's the each array one array contains the words another array contains
parameters another array contains the code address this this this lets me search
the name array with this hardware instruction
um but really nothing has changed i'm amazed that the original
concept structure of fourth with this dictionary and stack has remained for 50 years without
significant alteration um at the moment i don't know how to make it any simpler
and of course the hardware has changed it was originally memory constrained and now it's not
infinite amounts of memory fourth doesn't know how to use infinite amounts of memory
it's just not necessary so i don't know where to go from here
i have a question which is not about technology only i mean and as christian said i mean you are
free mind right um what what is the topic i mean considering the news considering the
where the world is going at the moment what is the topic that makes you passionate about at the
moment could be fourth could be ai or could be something not about technology
ai goes back to my early days at the um what they call them
the early neural nets
i i'm of two minds
you can see this played out in the full drug full self-driving cars
do you use artificial intelligence or do you use pre-programmed decision making
um i'm a pre-programmed decision maker so i
that that's the way i do things if ai becomes magic as it has in the case of go and chess
i'll be disturbed because
we can't understand how it does it if we get ai in the form of a mobile robot or a
a mainframe in the cloud that we don't know how it works
i don't know that we've accomplished anything if you've got the oracles of ancient Greece
who could answer your questions how is that different if an ai is answering your questions
but i don't know what side to come down on i think i will stick with my deterministic clock
and perhaps try to get precision time protocol implemented or something like that
yeah
Chuck um this is Don you know we're working on this FPGA base fourth
and i'm very curious about your comments on the dictionary because we haven't implemented the
the outer interpreter in the dictionary quite yet you know the compiler part
you said that you have three arrays you you have the cfas you have the strings
the word the word strings the name of the words and then you have the data
what is what's the data
because the data is usually on the stack right so um
in the case of a constant it would be the value of the constant
oh okay so that so so that's yeah it's an constant array
well it's an array of you can put anything in it you want the address of a variable
the value of a constant i think those are the only two i actually use
okay have a data field and in the case of a code reference the data field
merely indicates that it is a code reference
but this has led to the most efficient implementation of all these things that i've ever had
i have a second question you know i'm in the space business now i'm working on space robotics
or it has a very rich history in space your rtx especially i know that talking with dr
king in 2010 um the goddard uh space laboratory had him do some work implementing fourth for one
of their missions um can you talk a little bit about the history of fourth in space
i programmed reconnaissance satellite once
um but i had very little to do with it because the mc4000 was the
prototype of the rtx
and yet i had no contact with it at all nobody ever asked me a question nobody ever
paid me money to do anything so that whole space application went on without my participation
so most of the space stuff was done by fourth ink and elizabeth rathers people
well i they were kind of the central focus john john hayes and hopkins university yeah
john's hopkins university crew
well i they were good people they uh
what was his name
proved that fourth was uh provable language which was uh an issue at the time
you can prove it was correct although i don't know why that is interesting because it's pretty obvious it's correct
well what's very interesting right now um that i found being in the space business
is fpj's are naturally um radiation immune so they're very much favored in space because the geometry
is much larger than the modern microprocessors right so a radiation hit is not going to impact an
fpj um and i think this is a huge opportunity for fourth um if you can imagine a hundred robots
working out in pluto assembling something and you have this low speed data link and you're
going to send a c binary blob up there every time you want to change code
um you know fourth is interactive you just make uh your your core words deferred words
and you you update as necessary using text i think it's that's the same thing applies to
over the year updates that tesla uses i don't know how they do it but i doubt they use a fourth model
okay we have a queue of people that raise their hands to ask questions so dimitri is next as far as i know
yeah i put my hand up after after don uh my my question for chuck is okay i've got i've got a few
finite list uh what would you say are the most important things about fourth that someone learning
the language needs to know i'm interested in those who are learning it today i myself i'm
quite young i've learned fourth in the past couple years uh so i was wondering what you
what were your thoughts on this
the first thing you have to learn is how to handle the stack
uh conventional programmers don't think in stack terms and there is a transition that takes
of maybe a couple years before you really know what to put on the stack and what not to put on
the stack and how to keep the stack clean the the the processor used in green arrays chips
has a circular stack so you can put things on it leave it there and it will be forgotten
in an optimal way you don't never have to keep the stack clean
and that's what i do in u hd fourth also i have a circular stack it's a little more expensive
but it's a hard lot a lot easier
beyond that you've got to learn to factor take a problem break it into pieces give names
to each line of code so that you can combine them into a higher level uh structure
that's that's not unique to fourth that's that's the term that's a kind of
good programmer practice that no one uses c has made it conventional to use very large
subroutines it's lots of parameters and fourth has very small subroutines with
almost no parameters you have to make that mental transition
how many things do you recommend uh leaving on the stack at a time like how many
things in the stack should the word consume is there any rough guide on that
one or two one or two yeah the uh the
g a fourth uh g a 144 has eight deep stacks
it doesn't have 16 deep stacks whatever but my u hd fourth has eight deep stacks that's all you need
yeah i think um on the um fpga processor i'm working on with uh don yeah we've implemented
our circular stacks and i think i think it's 32 at the moment but i thought 16 might be
a reasonable depth uh for uh for fourth programming so that's reassuring to know
since others have their hand up i asked my next question which is um what was it like
working with fourth compared to a fortran or algal
what was it about fortran or algal that made you think my i needs to develop the language fourth
interactivity as others have said
in fortran you have to recompile the entire application
no i worked i worked in fortran in fact an early version of fourth was coded in fortran
and it was a pain to have to recompile the whole thing it took half an hour maybe
and i wanted something that was uh easier to to patch now there are two flavors of fourth that i've
seen one is where you have a large body a large dictionary with many things in it and different
vocabularies the other is which you know no vocabularies and you recompile apps on top of
each other that's the way my u hd fourth works one of the most one of the most common apps i used
is the editor it overlays whatever other app might be active because clearly it isn't
interesting any longer and it it compiles a new version of a block and then i can recompile the
app recompile that block to make the uh the new app so my compile times are zero edit times are
trivial and the application is tiny so i have a lot of tiny apps instead of one huge one
wow so that really that really is fascinating and i've tried out using blocks i think it's
implemented in the esp32 fourth and i found it very very handy uh my final question which
follows on from the previous one is do you think that fourth still has these advantages that you
method that you mentioned uh do you think it still has these advantages over languages today
like c and java and python absolutely i haven't seen any progress in the conventional language world
since uh been portrait all these languages are infix notation they are not interactive
they are huge
if nothing has changed in the last 50 years what would you say is wrong with infix notation
it's
it's a perversion of notation and concept and implementation in high school
people have taught infix notation as algebra and it is a pain because it is unnatural
uh the hp calculators are much more efficient
that in keystrokes than an infix calculator it's just a path that society has taken that
i think is suboptimal yeah um i would i would agree with you uh and that concludes my questions
by the way yeah i would agree because i had a a bug recently at work which was caused by an
infix operator that i i i got the precedents for it wrong and so it was evaluating it completely
incorrectly and i'm thinking if i was using fourth this would not happen and it's amazing how
how often people run into these things you see problems on facebook sometimes where someone says
solve this max equation and it's because it's confusing these rules are um confusing they're
good for mathematics but they're not actually as intuitive as people think they are the only
intuitive because we're taught them but yeah that's that's it for me thank you for answering my
questions chuck and i will continue learning sure yeah yeah thanks so next with the right hand is
james norris please go ahead
we can't hear you james there you go you hear me yeah no um i was wondering about the x86
hand coding that you're doing would you consider using assembler or why don't you do it
assembler is just another layer of software that gets in your way what i have is um the hex op codes
with subscripts which i will put a number on the stack and the subscript indicates how many bytes
that will take in the object code and stringing these numbers together gives you a program
now this is totally inappropriate for large programs this is this is insane but for a one line
fourth definition it's trivial um would you be interested uh i wrote a fourth base x86 assembler
if you ever want to do anything bigger um and my second question is what about using fourth as a
right now they're coming out with rust trying to do this they figured out that a lot of program
languages have problems like c plus plus has memory management problems and things like that
and it causes all these expensive bugs for like microsoft and stuff and they spend millions of
dollars trying to fix bugs in their operating system caused by the programming language so now
they're trying to come up with rust as a magic solution what about fourth you could take four
that's really simple you could put in all that error checking that doesn't have what do you think about
yes we certainly could um fourth doesn't have to be a standalone language it can be a module
in an operating system um it just doesn't seem to strike people's fancy
and that was all my questions okay thank you so gerard's next try okay next try can you hear me
now yeah wonderful very sorry about the blur before uh so jack i wanted to ask just because you
also mentioned before that not a lot has changed in force uh regarding to the basic structure of
having a directory and having a stack um but i actually recall having a discussion with you
where you mentioned investigating multiple stacks uh and using locals even uh did you have did you
do any further research or is this just been a short excursion for you no that that didn't
lead anywhere useful what i have done in um and uhd fourth i've taken advantage of all the registers
that the x86 has and you could almost say that you could make a fourth register based instead of
stack based and i explored that a bit and abandoned it and why is this a stack is absolutely
essential you might not use it all the time you might take advantage of the registers
but if you don't have a stack on which you can pass parameters um you're crippled and why did you
give up on having uh even more stacks i don't use floating point arithmetic so there's no no reason
to have a floating point stack and i have never found a use for any other kind of stack okay thank you
right thanks uh so our next question comes from Greg
yeah hello uh hello Chuck it's a pleasure to meet you um actually i was curious about something
that was said earlier you mentioned as a as a general rule um just limit the number of
things on the stack to maybe just two um and and so just as a as a possible example
if i were to um develop a uh a word that is to draw a rectangle and it uh it takes two points
you know top left bottom right let's say as parameters that would that would be four arguments
on the stack so i might think well uh maybe i should start thinking about structures so maybe
i'll create a structure that's a point object and so i could put two points on the stack and
you know that's only a couple of things placed on the stack but now i have a structure that structure
would be i think in fourth would be typically global uh which some people might look a scans
that and say it's a it's a global variable i could also think of it in terms of well maybe
i could create an object called a rectangle and and the rectangle might have methods to
set its points and to display itself or whatever i decide make makes sense um and that i think fits
well with the noun verb um you know uh structure that fourth i think encourages you know objects
you know action type of thing you know machine on machine off sort of thing
just curious as to what your thoughts of you know would be on on how you might structure and your
thoughts a problem like that and and you know what are your thoughts on structures and objects and
that level of abstraction you know in addition to just the basics of what fourth gives you
that that's one way of doing things what i do
is i have a word at that sets the cursor takes two parameters and uh specifies the location on the
screen and then i have another word called rectangle that has the dimensions of the rectangle
that i'm going to draw at the cursor so i've broken it into two pieces instead of having one
large piece and i can use the word at for triangles as well or for circles
um now in the case of a triangle
it's a problem because you've got three points
and i use a structure for that
a circle only has one parameter the radius so it's on stack so to generalize and say
everything should be structures is not right and everything should be in a stack is not right
either you have to be flexible what are your thoughts on on objects having you know a variety
i created an object in fourth
called the month and this object had the starting point in the year and the number of days or
something like that this was back back very early that's the only object i've ever
i've ever done and it was useless i have much better ways of doing months now
so i think object-oriented programming is the mistake there are not enough instances
of the object to make worth the generalization
interesting thank you for your thoughts on that appreciate it
that's why they call it oops
okay francis please ask your questions um hi shark can you hear me
yes okay hi chak it's an honor to speak with you uh following following for a while
and i just wanted to thank you for this gift to us i was wondering if you could speak a little bit
about the motivations for the circuit simulation software you wrote its performance and its current status
say again so i was wondering if you could speak a little bit about your motivations for the
circuit simulation software used to do the layout and electrical simulations its performance and its
current status yeah that is my that's one of my favorite applications it's one of the things that
i've spent most time on and i think i've done the best job on um there's there's two aspects to it
one is the circuit logic die logic uh description and the other is a layout
if you are laying out a circuit board or whether you're laying out a um
chip basically the same problem with different geometries and what i have learned to do is in
both cases i do the layout and from the layout i derive the circuit
an array of transistors and interconnects okay
um it's extremely efficient extremely intuitive pretty simple to implement
and gives wonderfully complete results
uh i've i've done a lot of circuit boards but i've done even more chips and the chip layout
well conventionally one has a uh logic description of gates that are connected
then you that you derive the the layout and i do it the other way the layout is predominant
and the functional layout is determined from it yeah this is this is a strange side effect
there is no need to do a validation proving that the layout accurately reflects the circuit
the layout is the circuit and is by definition correct amazing
and it's a lot of fun i enjoy working with rectangles and layouts yeah unfortunately
again just like the world doesn't let you interface with uh chips or boards or GPUs
the world doesn't let you interface with chips any longer you have to give it a
gds approved layout which they will they'll validate before they construct a layout
which vaguely resembles the one that you worked from to frustrating technological development
yeah i would love to have a
chip making machine something that will generate a prototype ship in a desktop environment
um but the world is going to the world prefers to have billion-dollar fabs
yep yep
um just uh just uh yeah i i asked that because i was uh in my daily job uh i do this as a maker
in a hobbyist of the cyber to my daily job i do uh chip design and process development for uh
some of the one of the big uh semiconductor companies and this is uh a cool interest of
mine i thought i would ask about that uh just another question um what are what are the most
interesting one or two applications you've seen in forth from others that you didn't see coming
the applications of forethink does and you can go to their website for a list
but they've done the communication networks device handlers
i did a hollywood robot once robot camera
um cement making plants
i would love to see an f full uh self-driving car in port
oh that's a that's a heavy thing though as soon as you get into applications that
risk human lives it's a whole new game and i've never done one of those
okay um and just uh just a just a last question um in hindsight is anything
sort of done differently with regards to forth and setting it up developing it all that
looking back after all these these news
no in in in hindsight i don't know that i've done particularly well
but i don't know that there's anything i would have or could have done differently
in back in what 1970 or so
forth in a sense was competing with uh microsoft not directly but conceptually
and if if we at forethink had developed an operating system
we could have competed with microsoft but we didn't we couldn't
um
and i'm i'm perhaps glad we didn't i'm much happier with where we are now than where with
microsoft is now microsoft has to be compatible with the exception maybe of windows 11
with everything they have ever done before yeah and that is a horrible burden to bear
forth as it stands
well
forth is free to reinvent the wheel and i think that is a marvelous concept no one should
ever be afraid to reinvent the wheel and we do it every day
thank you chuck thank you
yeah thanks and uh howard your turn and please open the mic hi hi chuck i've already had a turn
chatting to you but one more question about one's compliment the whole it used to be very
popular a long time ago the ip internet protocol uses a one's compliment checksum
and it has some interesting properties um i have a feeling that it's a really good way to go
and i observed that you you use one's compliment in the in color fourth and uh i just wanted to
hear your opinion do you think that the world went wrong when it moved over to twos compliments
no i i i'm worried about this one of the main frames i programmed early on was one's compliment
arithmetic but twos is much more convenient and it doesn't cost anything in hardware
so twos compliment is definitely the way to go yeah i can i can understand that that point of
view the thing thing i like about one's compliment is that you've got this extra state in the system
and uh normal normal um twos compliments you've got zero and you've got everything else and in
one's compliment you've got plus zero and minus zero and it strikes me that it's very useful to
have this extra state that can be used so you can have a value is either zero not zero or
not set or some such and i think this this whole idea of having three states in a in a value rather
than two it brings it closer to the optimal um number of symbols required to transmit
data which i believe is e somebody proved a long time ago so it's closer to three than two
anyway it's just um i think it's a having code you're talking about having code yeah yeah yeah
yes the introduction on computer file about that two days ago all right having codes and
the transition of following the edges of the of the square to get to that okay thanks for the link
i'll uh look into that yeah okay thanks chuck okay right so bob you will raise your hand
hello i'm raising my other hand
okay i have a few one thing i'm wondering when i heard you you've programmed a main frame that was
one's compliment what main frame was that you remember
that's why i didn't name it okay um could it have been a spare univac
no it might have been the uh
who needs this
was it when you divided the regs the first super computer right i can't come up with the name of it
right oh kray or us kray you have to kray or maybe one of its input terminals something like that
cool uh second question uh you mentioned compatibility you know and how microsoft
does maintain compatibility and then of course you've just mentioned main frames i was thinking
zvm which is the current version of osm mbs which is osmbt which is os 360 has maintained
compatibility across since the 1960s when it first started and evidently you could compile
the program today on cvm uh z zos rather i'm sorry zos mainframe and on run and it just you
know it was interesting that you'd mention compatibility idm has had to maintain that for
all these years compatibility guarantees there won't be any progress yes um what is the smallest
fourth you've you've run across what's the you know what's the minimum like if you could
i don't know exactly i quantify it but like the smallest amount of memory smallest amount of
stack space what is what is that what would that be the smallest one i've done was called cm fourth
for the novics i think it was
um
at fourth thing we had
micro fourth and mini fourth which explored the range of having a small kernel and everything
else compiled um e fourth does that i believe
but uh i've i've heard references to these some micro computer fourths that had very small kernels
mm-hmm i would say uh a kernel should not be more than 4k if you get it down to one k that
would be nice okay cool um you mentioned in talking in like to get who it was but you mentioned that
the um uh two parameters stack but you mentioned the stack that's only deep is that for like
as many levels as deep as you go or is it i i've dealt with by eating so often small
i would think in terms of the circular stack with eight elements so that you could put as many
things on the stack as you want but you only have access to eight of them now for the uh
uh my circuit tracing algorithms i've needed to stack thousands deep because as you trace
the circuit you're recursing and recursing and recursing and that's a whole different concept
that i would have a software stack for okay the hardware stack can be very small four is too small
eight is small 16 is plenty okay cool um two more one is did you know that the current uh
dot net implementation of languages produced something called i l and i l is a fourth light
stack language so they actually you compile c into a fourth light language i don't know if you've
known that i would say no because i haven't understood what you've said oh okay well us
the dot net is the kind of the i um i'm sorry microsoft's answer to java c sharp is microsoft's
answer to java it's become very popular it's a actually very nice language if you're writing
that kind of software um but when it compiles it compiles down into something called intermediate
language which is actually a very fourth light language it's a stack based language i thought
that was i thought that was interesting i didn't know if you'd heard of that or not well all
infects languages have to compile into a stack uh so yeah but if the interesting thing is this
it doesn't compile it doesn't compile to a native it compiles i l i l gets compiled to native an
intermediate language yeah yes that is um to me that is grossly inefficient
why not writing in intermediate language and um last thing is that you you've talked about assembler
and you don't even know the x86 op codes and such like that in the 1130 assembler you wrote an
assembler i mean in 1134 you wrote an assembler so you could write 1130 instructions in a fourth
light notation yeah that was i mean there was right there right at the beginning it was very cool
not only 1130 all of my all of my computers had assembly uh words and i now think that that was
a waste of time it was it was hard to figure out how to construct the words it was hard to remember
how they were constructed it was inefficient to implement the the xop codes are on any computer
are far the simplest way of implementing it it was it was it's interesting you're saying that
because it was just like that was when we were looking at the code that was one of the most
intense parts of the code starting to understand what you're doing here then like saying wow that
we thought we thought brilliant so it was fun it was it was uh clever um but it was
it was at least as difficult as the test codes yeah okay that's it i'm out of here i'm at least
i'm going to you thank you for your time okay thanks bob our next questions come from jan
bramkamp or jan brankamp i don't know if my microphone is working yes okay so my question is
you've already rented about infix notation and how it doesn't compose
and what do you think about a prefix notation like uh list
i'm sorry i lost my earpiece sorry let me repeat that um you've already given us your opinion on
infix notation and how bad it composes and what's your opinion on prefix notation language
just like lisp um they made an unfortunate choice i believe the human brain works on postfix
you you you accept data you store it in your short term stack and then you operate on it
you don't prefix things
okay short answer and are you satisfied with it
yes i got my answer okay okay thanks jan um next is anton etel anton please go ahead
oh uh maybe your mic volume has been turned down uh so that's what happened to jared uh so
uh we can't hear you
mic selection maybe answer
no no no answer no no no no and now not again so yeah yeah no i didn't speak so okay okay go ahead
all right so um the question is um what is your take on state smart words i think you had them in
your early fourth systems and then you eliminated them and i'm not sure if you have them in in the
reason systems i don't think so but can you talk a little bit about them and yeah
yeah i think maybe that's an area in which forth has made some progress or at least my fourth
and u hd fourth is basically color fourth and different words have different colors
now state smart words would have different colors for different states for instance the color white
means execute immediately the color green means compile and
and those are really only two states that i need but i do have to be aware in programming
for instance a conditional word like if or then is an immediate word and must be in white
if i have an if in green it means compile a reference to if for future use
and that's basically what the state smart words did you didn't have to be aware
that they were which state they were in if they knew but now i must be aware
to distinguish green from white and that is a programming challenge sometimes i get it wrong
thank you yep
yeah interesting um yeah don please hello check again um how many items or how deep do you think
we should build the return stack in our ftj fourth
32 bit fourth that shouldn't matter
i would go with eight eight okay i i think the return stack
stack and the data stack need not be the same length but by default i would make them the same
length so that until experience proved otherwise uh the next circular stack sorry can i just go
is it a circular stack that you're talking about it doesn't matter okay i actually implemented
circular stacks so that was uh dr ting uh we we shared the code with him he said use circular
stacks okay so we did that dmitri implemented that it costs nothing in hardware my next question
in to you is um yep why don't you utilize um fpj's because that is your desktop chip making
um scenario today and i will offer you when we get finished i'll send you a complete system
that you can play with and it's going to be in system bare log um and it's it's very beautiful
code right now it's like two pages of code to implement a fourth processor basic
so why why haven't you used fpj for development
because they wouldn't let me program them in fourth
there you go that's great yeah that's literally the reason and the only reason
i would love to use an fpj but they won't let me i have i'd have to learn someone else's
ugly language yeah remember that's only maybe five years that there are open source tool
chains for for fpj programming thanks jack okay oh not you're raising your hand and
you're putting it down and raising it maybe you have a question i i actually wasn't putting it
down but uh let's go ahead sorry yeah uh i have a question i think like fourth is uh like you know
perceived as a runtime language right but it could be like a meta language it could be like
incredibly like um expressive and like you know um what are your thoughts about that and also uh
yeah uh i can i can ask the next question later
so what exactly was your question oh sorry like so the question is um we're thinking about
stacks and what stack to use and like you know what kind of stack size to use because like
that's a runtime for it right that's the fort where it's like um you know we execute a like
a stack based we have a stack based runtime right and that has like a certain costs in terms of like
you know um like third performance costs and it doesn't actually map to architectures like gpus
for example because there is not even like a concept of stacks just like i mean you could have
like a memory stack on the gpus sure but it's got to work on like you know uh like we're just
and i think i think fourth can be an amazing uh like compiler you know like it's it's it's
i'm sorry i yeah i can be i'm super excited so i am somewhat in our particulates and can be harsh
sorry well let me let me try to address that yes thank you the stack is nearly a tool that fourth uses
to express things compactly and certainly fourth has applications far beyond stack-oriented things
and yes fourth would make an excellent compiler fourth would make a good language translator
fourth would make a good um artificial intelligence effect uh
and yes i i kind of agree fourth is a meta language it lets you define an application language
suitable for your environment yes yes thank you i mean um also that's brings to the second question
which is like i also think like having the like you know the 144 chip uh the how like in terms of
like the simplicity that's that's the way to actually reach like the energy uh like consumption
to the minimum right yep and um yeah we think there could be other constructs other than the stack
to like you know or like it could be like i don't know um i was thinking maybe it could
be like a hardware definition language where we define those kinds of constructs for whatever
problem at hand so the hardware could morph depending on like what kind of application is what
probably we redefine the hardware sort of you don't like need to be you don't want to think
restricted to a stack you don't have to use a stack for everything as i said earlier you can
have you can have structures which relieve the depth of the stack and um but the stack i think
is in this at least the small stack is absolutely essential for passing parameters
yes i i i think i i also come to that conclusion because like it's super simple to pass parameters
and yet i think like you know at some level it's it's it's all like it's it's it could be even like
you know that we implement the whole compiler assembly and like like use the i
sorry i can i can i can grab okay also i i just want to say like i i thank you for for all the
inspiration and like for everything i mean i am i'm so so uh happy that uh i briefly got to
introduce you to some of the work that i've been doing which yeah okay ona thank you very much i
think we follow up on that later uh dimitri another one oh it's a very short question it was it was
based on um don's question on the return stack and um in the in the chat on peter jackie he was
saying well you know wouldn't the return stack need to be deeper if you're going to factor your code
heavily um so chock how could we have a return stack or say eights deep uh and still factor our
fourth code
oh no it's a question it's a question of complexity if you if you have two
two deep a call sequence this calls that calls that calls that it gets complicated and you lose
track of what's going on i rarely have more than two or three levels of nested calls which is what
the return stack is for i see okay so it's quite flat to yes because you can still you can still um
you can still um factor your application into lots of short words but they're just not words
that uh call one another one another in a chain they all kind of stay at the same level
that's right the other use of the return stack is to hold um uh loop counts although that's not
the only way of doing it so you want to consider how many nested loops you have as well as how many
nested calls okay that makes sense to me now thank you okay great thanks so jan for another question
yes this time my question is uh regarding state smart words i found them a pain in the
posterior to work with and wouldn't it be possibly easier to have an always compiling
fourth where interactive code is compiled into the numberless function and executed
afterward just to be immediately deallocated is there a downside to setting up a fourth system
like this that it's always in compile mode and the defining a word would only move the
a compile location from the scratch pad to the dictionary yeah i'm i'm a little bit out of my
depth because i don't know how state smart words are done conventionally um but i do i do agree
there needs to be two distinct behaviors one in which you're interpreting and one in which
you're compiling and why do i need the interpreting state at all couldn't this be solved by compiling
into a temporary scratch pad area large enough to hold a line of code or two then calling this code
and reusing the scratch pad for the next interactive input so always being in compile mode
yes you could do that i think i did that once upon a time what is the downside
it's no less clumsy you still have to be aware of what you're doing and um it's just a different way
what say there's three ways of doing it one you can have a state flag two you can have different
colors or three you could have this um compiled scratch and execute uh there's three ways of doing
the same thing i think the color way is is latest so what i went into with g4 or macris
stelares is that yes there's a state variable and some words respond to it and as soon as you
want to do heavy metaprogramming and you need one of those state smart uh words in another
state smart word they don't nest that's really cool and at that point you're scratching your head
and some force systems work around it by providing non-state smart versions and suddenly you have
two or three times the number of words for those words it's got for special treatment
that's
that's bad yes i would rethink the problem
which is why i asked keep going
i have a state smart uh um a state state smart question for chuck so you know what i
was thinking is um you have a 32-bit wide fourth computer in an fpj but make the inside data bus
34 bits wide and then use the top four bits for your state or whether it's an immediate word
or um you know compile i guess it's compiling an immediate is that the two two things you need
to figure out i i have done that um one of the early computers that i
had fabricated had 21-bit words whereas the memory was only 20 bits and that extra bit
was used as a flag for various things nice it was not good it was it was as awkward and confusing
and difficult as anything else okay um i maybe i have a follow-up question and another one uh on
that you once talked about the ice principle interpret compile execute and so if we enroll
everything into just compile don't we lose the interpretation capability to calculate things
upfront before we compile so do we need interpret compile execute the ice principle
um you're exactly right we do need the ability to calculate things and that's why in color fourth
if i'm compiling green words i can interpret interpolate white words to do the calculation
yeah so so we we don't want to lose this maybe yandis also answers a little bit of that uh
we don't want to lose the capability to do execution while we compile and calculate things
and generate code or whatever right i didn't uh propose to eliminate immediate words
anyway uh my second question um you've been once uh talking about the map is not the territory
and i would like to hear your current opinion on on the statement and uh how how you think about
abstraction so do we the map the map is not the territory
um but currently i prefer to work in the territory
now that's not it that's inaccurate either in the case of drawing characters
you draw the character or you can describe the character and
a long time ago i would draw the characters and that became a pain because i would somehow
move a pixel the wrong place now i described the character and i've come up with i think a very
compact way of describing characters so i go back and forth between the map and the territory
i see yeah thank you thank you very much and thank you very much for influencing my life over
the last 40 years sure yeah yeah maybe without knowing it but uh you did the responsibility
right uh next question come from trevis
and you have to unmute uh so that we can hear you
about eight deep return stacks
um i found a number of different uses for return stacks like for instance i'll make a
uh word i have a word that out that a lot space in the dictionary and then deal lots afterwards
and i'll use the return stack as scratch space for storing the top of the hear pointer
before and afterwards so i can restore it and return it including if an exception occurs
i'll catch the exception restore the stack which the dictionary then re-throw the exception
and also in my fourth i have to deal with uh exception frames which go on the return stack
and furthermore there can be nested exception frames where one exception is within another
so all the pop and furthermore the multitasking uses the return stack so to store registers and all
that so in essence i need far more than eight uh cells on the return stack store all the possible
states even if my code itself does that go that deep so what are your thoughts on this
oh i understand you can have a larger you can have a large multi-purpose return stack certainly
um my concern is that it's getting complicated
and i tend not to like it being complicated i would observe that in the case of circular stacks
when you get an exception you don't need to do anything to the stacks you just leave them
where they are and get on your business because you don't need to keep them clean
so yeah i think the simplest solution is to have a small return stack
but i understand the convenience of having a large return stack
thank you okay we have two other guys that want to ask questions john hardy please
so me again i was just i mean it's return stacks an interesting topic because it it is necessary
to discuss all sorts of different aspects of fourth because because the return stack is so critical
to the virtual machine i'm interested in the changes that happened in color fourth
some of them i have to do with your use of tail call optimization as a way of reducing
so you know that we're optimizing away calls so they become jumps which means that they use less
stack space so i can see that would reduce the size of a return stack
but one thing that seemed to get thrown away from my understanding of classic fourth is
that you use a tail call optimization as a looping mechanism and that you when you do when
you in classic fourth when you redefine a word or when you define a word you don't have access
to that word it's hidden until you're finished defining it uh whereas in color fourth i believe
the word is is visible so that you can call so it can be called by itself um so can you talk a
little bit about that change in the language um and you know like what what are your thoughts about
the way you know ditching the idea of the original fourth and going forward in this way
yeah the the original way would be my preference that you rarely reference a word within itself
more likely you want to redefine the word add some functionality to its previous definition
but that was complicated and awkward and in color fourth i just threw it away and said okay
i'll i'll have to live with the fact that if i want to redefine the name of the word
i'll have to say word colon word word zero word word zero stuff stuff stuff that's awkward
but it doesn't happen very often yeah
actually i found that in my fourth that doing it the way that you did it before
it's simply a matter of linking the word that you're compiling into dictionary
after you hit the semicolon at the end and it works
basically like how it was where were you if you redefine the word you referred to its
old meaning from within the new word without any work at all yes that is that is exactly right
um but in my current fourth semicolon does not indicate end of word it merely indicates return
from word return yeah and so i have no word that identify the end of a word
okay john another question or no that's it actually you're done thank you very much
thank you no satisfied uh okay uh the last question for today comes from james norris
uh i was wondering what the most fun thing you ever worked on was
most fun thing
a fun thing is something that gives you frequent positive feedback
um
i have to say my um
my chip layout and simulation
um it it it took years five years
but i was immediately doing good work after a one week
so i got this positive feedback which continued and continued and continued
the hard part of that was when you submit a chip for for uh fabrication
and you have to wait three months before you know whether it worked or not
and what do you do during those three months
but i have to say that was a lot of fun for a lot of years
thank you this is great asking another question
the chip simulation is fantastic i think one of your very first projects you ever worked on
was the the telescopic pointing and the data analysis you did interactively
in that on the system with all the other astronomers watching the work output because
that is that is quite significant to use something as large as a radio telescope
to capture the data live and to manipulate the data to generate those graphs that i think
are going to be significant it was at the time there was um this this millimeter radio telescope
was being used to discover interstellar molecules molecules wow okay and you would
you would you would collect data and display it and if there was a peak where you expected
a peak you'd discover the molecule right and the immediate feedback was very useful for the
astronomers but they still required that i record the raw data so they could take it home and repeat
the analysis even though that was completely unnecessary brilliant you've done the processing
already they were going to redo it probably not as well because i had good statistics
live statistics forget about post statistics well guys i see and we had a fantastic meeting today
we need to thanks a thousand times to chuck but there are people in the meeting
i see rob jude from australia do you want to say hello and anything to chuck not not questions but
only hi okay or do you have questions sorry no questions okay who else i see a ray gardener
also from australia very late in the night ray
ray showed us in the group in the facebook group fantastic pictures of his boards
with the rtx 2000 and image vision in australia for machines for different machines so he's the
he's a wonderful father and incredible incredible stuff i see in the meeting
ashley fanielo wanted to show us the wonderful cognition do you want to say anything ashley
something to chuck oh just hello chuck we met once in 2013 at the strange loop conference
but it's great to see you again it's always great to hear what you have to say
who else i see ilia tarasov almost cow he's chatting but he does not like to talk what
happens ilia too much vodka today
say hello to chuck okay okay i'm here but i'm afraid with my new microphone
uh it's it will be not too possible to hear me okay very good it's very good i just want to say hello
no more what what else hello what else and wish everyone to be healthy thank you thank you to you
3 30 in the morning in australia it's a indeed this is a word-by-word translation of russian
hello be healthy yeah wonderful thank you ilia i see also jonas carlsson where are you in the
world jonas do you want to say hello to chuck you are muted
oh yeah one moment yes so yeah i'm in a Bangkok at the moment and uh well at the moment we're
all stuck where we are right so it's two years so i had time to play with a lot of things and the
last thing i played a few months ago was a 6502 fourth and i was reading in parallel a lot of
things about color fourth in and and i found similarities when i was basically creating
a system with an online editor running on a 6502 where each page 256 bytes was maybe it was
buffer size basically and and this fourth was a byte coded fourth actually it's alphabetical
byte coded fourth so i use d for dup and i use s for swap and so on and of course the arithmetic
operations are plus and i remember reading when i was working on this that you actually liked the
idea of a byte coded fourth um but you never really went to do that do you have any comments about
that and especially about the code bloat today we have so big systems and they are compiled
to yield hundreds of bytes um yeah so that's my my general question
if shock is there i i i've thought about byte coding um other people have also
if it's a good strategy the closest i've come to it is the uh the g144 instruction codes
they are uh five bits
so i've effectively done byte coding on the hardware
right um microcontrollers with um v7m have the tbh and thh instruction which are basically
uh what you're asking for bytecode jump tables in mass manufactured CPUs which can be used
yeah byte coded fourth with a very tiny interpreter
yeah i'm finally building my my so-called alph alphabetical fourth which is supposedly half
readable kind of bytecode with letters and and symbols and i'm writing a very tiny
c compiler that compiles c to this fourth and i have it kind of working for functional c
with no variables and just the other day i added variables so as soon i would be able to compile
c to fourth and the uh rational for this is uh esp32 which i calculated that yes it's a very
powerful thing but one line of c code usually ends up being about 80 bytes of machine code
Jonas we are saying bye bye bye bye bye we are finishing bye bye thank you great another another
one here um holy neppu holy neppu is this correct holy yeah holy how are you
no you invite us to join this in uh join this meeting actually i want to to say that i have
developed the the cross compiler for different micros mcu's and the cross compiler includes
assembler disassembler and compiler and cross compiler and one special trick is that once the
assembler is generated the disassembly is automatically generated and the assembly that i
designed is based on algebraic assembler so every micro control can be seen the same because we use
i use the same same instruction like a register and the immediate word you can see that the all
micro control can be seen as a fourth chip not the really fourth chip but the actually we if we say
it is for chip and it contains only register and and immediate word so that way based on these two
words two characters i can design the assembler based on these two so every micro controller
seems the same and the assembler has i can design the assembler in different way fantastic this is
this is great news so we we love to hear from you and we send all our regards to the fantastic
thick taiwan and all the great members you have also in uh in the name of talk talk team who is here
and he wanted to show to show something but we will do this in the next meeting because we are out
of time thank you holy looking forward to hearing more about that later time yeah if you are
interested another friend here is Igor Matznitsa from Estonia is this correct the name Igor
yes do you hear me only to say hello to Chuck and wish wish him well and etc but
do you hear me yes yeah but the mic is not making noise but it will do
hello Chuck thank you very much for your creation and i meet for the first time in my school and it
made a big movement in my development as a programmer thank you very much one more time and
be healthy in this time and i wish you one years and a lot of implement your plans
thank you Igor Karsten do you want to say hi to Chuck and bye bye where are you from Karsten from Germany
i cannot Karsten yeah your microphone i cannot
maybe you have to put on the volume increase the volume Karsten
but okay then just uh wave in wave into the camera next time so Karsten is from Hamburg
actually oh cool across the city and yeah thank you very much Karsten for participating next next
time we we talk with you and rof also from Germany do you want to say bye bye to Chuck and
thanks etc or rof has no microphone who else i have you're muted bro check i want to say hello
from Germany benefit and i was motivated to write my own force my own tiny force
because everybody should write its own tiny for before using a professional force i think
and i learned it from you i see also tomas guepel from Germany he helped us putting the link in
the hackaday so i thank you very much to tomas and he's also a great participant here in our meetings
no sound tomas hello
thank you then if you have no sound thank you very thank you again uh who else
uh atle from norway do you want to say bye bye and thank you to chas
uh i'm a relative newbie and for it and i just want to say thank you and i find it brilliant
thank you antony forgola do you want to say bye bye and thanks to chuck yes i say hello
i say hello to chuck and thank you so much for all the difficult nights i have to work
too to find books in my programs for me later it was very enjoyable and still today
two months ago i started a new project with force so it is still very alive for me thank you
well uh who else georgia from brasil georgia genaite do you want to say
oh hi i release me yes oh hello i'm georgia night from from brazil i'd like to to say thank you
everyone especially peter for organizing this haven't chuck for discover discover like he says
that this incredible language it's amazing it's more than a language it's a philosophy
the the fourth way to to think i don't know i i i i really love this it's a it's a pleasure to
to to talk about forfe with people who likes forfe it's uh oh thanks thanks thanks peter
uriki john hardy chucky dr tingy everyone everyone it's really really really nice to
to stay with that today thank you for your love in in in the language georgia you are a great
father i have also uh here tomas from cern tomas uh yeah apola thank you can you hear me thank you
chuck thank you everybody for this very marvelous meeting and i was using force uh beginning uh i
think 85 to 87 brought my ph oh no my thesis in felix was a great time so thank you all and have a
good time chuck see you soon bye bye thank you tomas pablo de argentina pablo reda hi i like to
say thank you to chuck more uh i am a color for fun i'm learning for reading the color for the
source and uh i changed my life with this marmalose uh language thank you thank you pablo who is
somebody else and then we close cesil bayona i don't know philip ellie yes so chuck again many
thanks for the inspiration you gave me during those years when i was a student and still now and
and clearly you are a wonderful person so thank you for everything
thanks again chuck for being here uh i've been following force for many many many years
and in my youth when i first heard about force i was so excited somebody who wanted to keep things
simple rather than the abortions we had for programming at the time so thanks again for
your great idea and what can i say thank you again
well guys this was fantastic i don't know if chuck agrees to that and we do all these meetings
thinking and thanking everybody in the force community all people from svc also who helped
us every meeting and from all the communities in the world uh how are do you have a race
racing hand yeah uh chuck is there any chance i could get my hands on your clock code i like to
put it in as an app in color fourth you do you have any plans to post it anywhere
hey i don't have a vehicle for posting things can you send it by email
i could send screen captures maybe i'll keep it in mind okay i'd also like to see the source for
your character generator code that interests me that i would have would gladly publish
again if i had some way of doing it i used to have a website i keep thinking maybe i should
reactivate the website but um i haven't yet okay if you come up with any way of transferring it
i can help in any way let me know and i'll um i'll help you gladly okay however
is i want i want to thank you all for inviting me it's been fun and it's gratifying to see
so many interested fourth people i wish you all well in your endeavors
thank you thank you
thank you very much thank you thank you very much for joining us thank you thank you thank you
everybody thank you thank you guys save the check
