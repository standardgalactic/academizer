Welcome, this is the tutorial for a conch.
If you're not here for a tutorial on conch,
you're really in the wrong room.
But we hope you're in the right room.
Yeah, we think this room is the best, actually.
You made a good choice.
You can introduce yourself.
Hi, I'm Anthony Scopatz.
I work for Quonsite.
And according to the slide, I am both a madman and a poet.
So I hope that this inspires you in some way today.
I'm Gil Forsythe, not Gorsythe.
I am also a madman and a poet, according to the slide.
I currently work for Capital One.
Yeah, that's what I got.
And thanks for being here with us 8 AM on a Monday morning.
Not everybody wants to learn about new show languages
at 8 AM on Monday morning.
So we have a few bits of, I guess, bookkeeping.
And just want to get everyone kind of set up and ready to go.
If you've been to a lot of, or any slide pipe tutorials
before, sort of the usual mode of presentation interaction
is Jupyter Notebooks.
And those are great.
It works really badly if what you're teaching
is like a show language and prompt.
So we actually just do need you to install the stuff.
And then we will be sort of live coding
and have slides at the same time.
And we'll be running around and helping stuff.
But so if all of you can just take a few moments
and we'll run around to Troubleshoot and install Conch,
we highly recommend using Conva for this.
But there's other options up there.
And there's a new release as of last night at 10 PM.
So if you haven't updated since then, please.
There's a bug fix.
Sorry, the code has bugs, like all code.
So yeah, please grab the 0.9.8 release.
And we'll go from there.
So who has Conch installed right now already?
OK, most of you.
And if you don't, just grab it.
It should take two seconds because it is pure Python,
thankfully.
So you don't have to deal with weird Fortran rust extension
interactions and stuff.
Or Readline.
Readline.
Oh yeah, we don't have to deal with Readline.
Everyone's favorite library.
Three cheers for Readline?
No, no cheers.
Wow, wow, tough crowd.
One cheer, wow.
Nice.
Input RC, there you go.
Thank you, I'll be here.
What?
I'm showing my agent.
Yeah, no.
All right, so oh, and we should send out the link
to the slides as well.
So yeah, the slides should be at condos.
This is, what's that repo called?
Is it like Conch?
Conch, sci-pi, something, something.
Yeah.
While people are installing Conch,
and for people just coming into the room,
please install Conch, I just want
to sort of do a quick poll of the room,
get a sense of who y'all are and why you're here.
So who here uses Bash on a regular basis?
OK, any Z shell users?
OK, fish.
One, OK, yeah, one cheer for fish, one cheer for Readline.
Two cheers.
OK, fish got two cheers.
All right, has anybody used Conch already?
All right, yeah, cool.
One, two.
No, that's better than fish.
Yeah, that's true.
OK, who here really likes Bash?
That's OK, no, no, there's nothing to be ashamed about.
There's an open question.
We're not here to know.
Who here remembers the syntax for a for loop in Bash
without looking at Stack Overflow?
OK, no, no, some people can do that.
That's totally cool.
Who here remembers how to tokenize a non-whitespace string
in Bash without looking at Stack Overflow?
Bold so, I'll believe you.
I'm not going to call you out there.
That's good, it's good.
OK.
So while we get the slides everybody,
I mean one of the things, conscious for many things,
partially it's to suit our mad desires.
But also it was a lot of these things
which seem like they should be simple and easy to remember
aren't.
And a lot of us are dealing on our daily workflows
with language decisions from the 70s,
which made a lot of sense.
But maybe we don't want there to be a difference
between single and double quotes all the time.
Or maybe we don't want to have that many square brackets
in a row.
And so this is an effort to remove that pain
because this should be a relatively seamless and fun
interaction.
And you should just be able to do the things you want to do
without struggling through it.
I think we probably can.
I don't have the slide link.
OK.
Are people mostly installed and ready to go?
I have contra-running?
Cool.
Does anybody not have contra-running?
That would be, I guess, the question to ask.
OK.
We're still going to be talking for just a bit.
And we can catch up as we go.
Also just a quick sanity check.
If you can run, every time we say the sound like co
or something, it's always going to start with an x, just a
fair warning.
So if you can run config, it's x-o-n-f-i-g in your conch
shell, that should probably not say what it says here.
Maybe it should say 0.9.8 at the top just so we're sure we're
on roughly speaking the right versions.
I do have the link, but I don't know of a good way to get it
to you guys, other than I'll just put it here.
So if you want to follow along with the tutorial, you can go
to this link.
So it's conch.github.io, scipy-2019-tutorial, slash
remote.html.
We're sorry about the URL.
Only a little sorry, because it's pretty readable.
But yeah, you can click along and follow.
So you can skip ahead in the slides or go back.
There's some exercises and things like that.
So bring that up now.
OK, I'll let you guys do that.
And then we'll continue.
OK, that seems good.
Yeah, great.
OK, so quickly just an overview of just some things
that you'll see us doing a lot.
And you should also feel free to do while you're interacting
with the shell.
We don't have explicit slides about this,
because they're just sort of general overall things
you can do in a shell or in continuity way.
But if you see us do something, like we obviously hit one key
and something happens and you want to know what just happened,
please just ask us if it seemed like it came out of nowhere
or we're not trying to make this opaque.
So generally speaking, there's tab completion.
Ah, yes?
Oh, from the tutorial?
There's an L right at the end.
Yeah, sorry, it wrapped a little.
Yeah, I was getting, well, the directory
doesn't have an index.html.
I can fix that in a moment, but yeah.
Yeah.
Generally speaking, there's tab completion
for almost everything, so it'll save you time
when you're typing.
Be aware of that.
Does anyone not know what tab completion is?
No?
They're the same.
All right, great.
This will mean less for you at the beginning of the tutorial.
There's a lot of history search functionality.
You probably don't have much of a conscious history
at the moment, so that won't mean that much.
But there are several ways to search up.
We'll kind of touch on those a little bit later.
Control R is your friend.
That will kind of give you an anywhere line search back
in your history.
If you start typing a command, you can press up,
and it will do a prefix search match.
So like any line that started with that initial bit
will show up in the results as you arrow up.
And you'll see this sort of ghost text showing up
if you're typing the same command.
This sort of a history match autocomplete thing.
And you can just hit right arrow, or I think Control E,
to sort of expand out to that if you want.
Don't worry about taking all that in at once,
but we'll come back to it.
Ah, yes.
For all the pythonic bits in Conch,
and we'll find out what those are a little bit later,
you can always append a question mark to a command,
and it will bring up a little help screen in the pager,
or you can do a double question mark for super help.
For even more, if you've used IPython a fair bit,
this will maybe be a familiar pattern.
Yes.
Probably not alone about not knowing what the Wi-Fi password is.
I don't think there is one.
It's UT Guest.
UT Guest, and should just be an open, wide open network.
Yeah.
Is there another question over here?
Okay.
I think the SSH doesn't work on the UT Guest network.
I think we did discover that, yeah.
Someone posted something on the Slack general channel
on using 2.5-core authentication to get around that.
Get it as a offensive SSH.
Okay.
Yeah, okay.
Not gonna do that live.
We are gonna ask everyone questions about that
during the break so we can fix something that wasn't working.
But that's good news.
Awesome.
Okay.
Are there any questions?
Okay, great.
All right.
So yeah, there's, oh, was that a question?
No.
All right, so everyone has com working the,
if you ran the, sorry, the config,
let me just go into the,
oh, okay.
So you should have been able to run the config command
and see some output like this.
So if, is everyone kind of at that stage?
What was the key?
The, oh yeah, it's config with an X.
Gonna love that X key in the next four hours.
All right.
Okay, so we've got our agenda here.
We'll be taking some breaks in between these things
and we're gonna be building up
to sort of greater and greater capability over the time.
These are links.
So if you have the slides up,
you can jump around if you want to.
And there are exercises at the end of each little section.
So,
that's gonna do the shuffle here.
So,
Conch is a superset of Python three.
So what that means is that all of the syntax
that's in Python is also valid Conch, right?
So there's no,
so if you know Python pretty well
or really well or extremely well,
everything should be familiar to you.
And so you can do a bunch, like basically everything
that you would be able to do in Python, right?
Like define classes, functions, modules, et cetera.
So we can go ahead and do these along with us,
like when they come up.
So let's try some in the mount.
Oh, these are our first exercises actually.
So the first one is to compute the product of two,
three, and seven.
The second one is to import numpy or import sys.
If you don't happen to have numpy installed.
And then also define a function.
You can do all this right at the command line.
You don't need to go anywhere else.
You don't need to do this in a file.
So try these out.
You can click on the details to get the answer.
And we'll give you guys a couple of minutes
to try this stuff out.
And also be solving it very slowly in real time.
I think you can go.
Wow, 42.
What an auspicious number there.
My goodness.
Can we import a module, Gil?
Yes.
Wow.
That's pretty impressive.
I want to just take a random numbers.
Oh, we're in a redline.
We should probably.
Redline, yeah.
Yeah, sorry.
We're not.
Nope.
All still in redline.
Are you doing that random start again?
Yeah.
There we go.
Okay.
Somebody stop and close this one.
Yeah.
Sorry, I was in developer mode right there.
There we go.
So you're saying, yeah, you should see
there's a lot of tab completions available.
So if you import, or I'll do sys actually too,
because that's one of them.
You can just hit tab after the dot
and those will be all of the attributes
and modules that are available in sys.
Yep.
I forgot the last one.
The function.
Oh, cool.
Does anyone have any problems or questions with these?
Pretty simple, right?
So this is just to prove to you
that cont really is Python.
Yes.
Yes, you can.
Well, we will get to that question
later.
So Dhar Haas's question for those of you
who are listening at home was can you define a function
that's all a command on your system?
And the answer is yes.
And we'll get to how all that resolves and works later.
So great question.
Okay, and we'll get to it pretty soon I think actually.
So conscious of shell.
So conscious also a shell language.
Or more precisely, it's really a scripting language
that is mostly shlang compatible,
which if you go back to like the 60s and 70s,
sh is a shell language that we all have inherited
a la bash and z shell and other languages like that.
But unfortunately, it's actually impossible.
The syntaxes collide and it's impossible
to be both a Python and shlang compatible language.
And so you have to kind of choose.
And in conch we have chosen that Python will always win.
There's a couple reasons for this,
but mostly it's that Python is the same language
and sh is not really sane in some ways,
like the splitting strings on non-white space characters
and the machinery for how all that stuff works
is kind of crazy if you dig into how the shlangs work.
But Python always wins.
So if you've found a place where Python syntax
isn't working, that is a bug.
And you should please report that.
Should we do an LSTashL?
Yeah, yes, sure.
Just as an example of this,
there's issues where,
so this is a command that you may be familiar with.
But this is also a valid Python syntax
if L, S, and L are defined.
So,
right.
So the rule is that if one of those things
isn't defined, it'll still function, right?
You can just delete the variables,
but it is possible to overwrite those built-in names.
And there's a way to escape that, which will,
this is just a convenience,
but that we'll get to in a bit here.
So the purpose of the shell is to run commands, obviously.
And so we've got some commands here, right?
So we just saw L, S, dash L,
simple one, yeah, please type this out if you want.
Just prove it to yourself that this works.
You can do echo.
You can make directories and CD into those directories,
touch files, do all the kinds of normal things
that you would want to do.
So, and I think I actually have all the test code here still.
But, and the other thing that you can do is you can pipe,
right?
If you're familiar with piping from other shell languages,
you can take the output from one command
and make that the input to another.
And so that all works normally,
like you would expect in Conscious Well.
And basically under the covers,
this is a horrible abuse of the sub-process module,
as you would expect,
with a lot of fancy features added to it.
So, okay, so the next bit of kind of basic syntax
in the language are environment variables.
So these function a little differently than other SH langs,
but similarly.
So you can refer to any environment variable
by prefixing a name with the dollar sign character.
So if you want to look up, right?
If you want to look up a variable in the environment,
you can say dollar sign that variable name,
and then you'll get back the result.
So the environment is this special namespace
that processes use to communicate with each other,
and Conch gives you access to that.
And you can set and delete environment variables
more like you would do in Python,
than you would do in other shell languages, right?
So these are just normal variables that happen to live
in a special dictionary mapping somewhere.
And so because of that,
you would set them with an equal sign,
and then you would delete them with the Dell operator.
So shouldn't be anything too out of the ordinary there.
Anyone have any questions about that?
Is there any difference between this and OS environment,
OS.environment, and the answer is yes, there's a lot.
We'll get to that in a section coming up.
And yeah.
I have two questions.
The first one is will export still work
for environment variables?
No, export is not a feature of Conch.
Or so exporting, so okay,
this is getting into the weeds a bit,
but I think export is a bad idea.
You shouldn't need to explicitly export things, right?
You're already doing that with the dollar sign, right?
So SH links, when you export,
or when you define an exported variable,
actually don't put the dollar sign.
So we've collapsed those seven characters export plus space
into just the dollar sign.
So we can assume these variables are full?
They're process wide.
Yeah, they go into the environment for the process.
Yeah.
And the other question is what about dollar zero?
Oh, so dollar zero for those,
so the question is what about dollar zero?
Dollar zero is how you refer to arguments,
or you get the command that you run.
We use dollar args for that when you're running a script.
It's an environment variable.
It's in the docs,
which we'll have a link for very shortly, so.
Okay, well, I just realized this screen,
we're standing in front of it.
Yeah, okay.
But we'll maybe fix that during the break.
Okay, yeah, these pretty normal.
The other thing that you can do
is you can do environment lookup with Python expressions
using dollar sign curly brace.
So if you wanna compute an environment variable arbitrarily,
you can use dollar sign curly brace.
So this is a little different
than how other languages do it.
But for example, say you have an X variable
that equals a string in your namespace, so your user,
you can do dollar sign curly brace X,
and then that'll look up the user environment variable.
So that looks up the name.
Oops.
Sorry, I skipped ahead a bit.
And, or if you wanna compute it with some other expression,
you can just stick that right in there.
In most SH links, these are actually dollar sign
and dollar sign curly brace
have effectively the same meaning,
but they have distinct meanings here.
Effectively, there's subtle differences, I know.
But they're very different here.
Okay, the source command.
So, is everyone familiar with source
and other languages, like bash and things?
Okay, yeah, so if you're not,
what source does is source takes a file
that's written in that language.
So if you're in bash and you can source a bash file,
and it will run the commands
as if you had typed them into that session.
So it's just a shortcut for executing everything
in a file in your current interpreter session.
So conch, the source command does basically the same thing.
It reads in the contents of a file,
and then it executes them,
and it brings all the global variables
and everything in the environment, et cetera,
into the current execution context.
But of course, this doesn't work on bash,
this works on conch code.
So if you have a very simple example file,
sorry, this is, yeah, oh, you can do that.
So here what we have is,
we're setting an environment variable in this file.
We're setting a password, which is a terrible thing to do.
And then we're defining a function.
You can install VAM right now if you want.
Go for it.
See if I care, Gil.
Just-
Yeah, I can't do that to your laptop,
but it just seems main.
How do I do this?
Well, I mean, we're talking about sharing passwords,
so I'll just say my root password out right now.
Yeah, so you can then use this function in its scope.
So basically what you do to use source
is you just say source, and then the file name.
So here, sourceexample.xsh,
and then you'll see that those variables that we had,
like dollar sign email, are available,
as well as the combined function
has been brought into your local,
or your current sessions execution context,
and you can run it.
You can also import .xsh files as well.
So if you wanna write Python modules as conch files,
you're totally welcome to do that,
and you can import them even in other normal Python projects.
Not gonna show that here,
but if you're interested, that's something you can do.
Okay, any questions on source?
Pretty simple.
All right.
The thing that you can't do in a lot of other languages
that you can do in conch
is that we have a notion of sourcing files
from other shell languages that we call source foreign.
So imagine you have some bash script somewhere,
and you wanna bring that in and execute that in conch
and bring all the things into your local execution context.
You're able to do that just by saying source bash,
and then the bash script.
So if you've got 100,000 lines of Z shell,
well one, I'm sorry, and two, you can still use that.
So this is a way to slowly integrate with other languages,
which is pretty cool, actually.
So that's pretty nice.
Any, and by default, sorry, we have a,
so source foreign is a generic infrastructure for doing this,
but we have shortcuts for doing source bash,
source Z shell, and also source command, or CMD.
So if you're on Windows,
using the Windows batch processing language,
you can source that stuff too, which is madness, but.
But, but.
What was the haunt to welcome Windows?
I mean, we've got a core Windows developer
for the past four years who's like,
it works pretty well.
I mean, there's, I imagine there's folks here
using it on Windows, right, so.
Are there any Windows users in the room, actually?
Okay, cool, let it, I mean,
who are on Windows right now?
Okay, enough, please let us know how it's going.
I mean, seriously, I think that the biggest problems
are usually just that our examples are very like Unix-y,
and so we say, like, run this command,
and it's like, what command is that?
That's often the problem.
Yeah, true, I'm gonna check the window.
Oh, okay.
Okay.
Well, so we found with that, like,
if you're on a base Windows install,
and you just install git bash,
then you get all the Unix-y commands,
and everything works normally.
And supposedly it works really well
on Windows subsystem for Linux,
but I have not tested that.
Sorry.
Since I'm on, I'm in the same situation for WSL,
WSL2, which I'm testing out.
Do you want me to just try to run everything?
I mean, you can.
We would be very happy for you to do it.
We may not be able to help if it goes wrong, but we'll try.
I saw another question over here somewhere.
All right.
Okay, so source foreign,
really nice capability, really helpful,
especially if you're just getting started.
The other thing, like most shell languages,
we've got a configuration file that lives in home.conchrc,
and this is just a particular special XSH file
that's loaded before basically everything else is loaded.
So this is where you can stick all of your customizations.
Mostly a lot of people just stick
environment variables in there.
If you're a condi user, conda as activate,
or whatever, and it will throw some stuff in there as well.
And yeah, so, but basically,
if you want to read about all of the customizations,
they're in the doc, so every environment variable
that we touch has documentation associated with it.
And there's a lot of tweaks that you can do
if you need to.
All right, so here's some more exercises.
So let's go ahead and take a few minutes to do these.
So the first one is to just set a random integer
to the environment variable dollar sign secret.
The next is to print the secret value.
And then the third is to put a generating,
just some generating code for that secret value
into your conchrc when conch starts up,
if a dollar sign safe variable does not exist.
So we'll give you guys a couple,
we'll give you all a couple moments to try this out.
And if anyone's having problems,
just raise your hands right now,
and Gil and I will walk around and help.
The next thing, or for part two,
there's actually a couple different ways to do this.
The first is that you could either echo that,
so if you're thinking more in a shell language,
you could echo that, you know,
my secret value is dollar sign secret as a string,
and that will all push out normally.
Or if you're in more of a Python mode,
you can just print it like you would print anything else.
Okay, both of those are totally valid.
And then the last one is,
if you wanted to, this is getting cut off I guess,
but this is why you have it on your own machines too.
You can say in your conchrc,
because it's Python, you can import random,
because it's conch, you can set the environment variable
to whatever random value, and then,
oh, we actually didn't cover this in text in this exercise,
but, because we've moved around some slides,
but we'll get back to that last one soon enough, so.
Okay, so very briefly.
So remember how we said dollar sign curly brace
is an expression, you do look up by expression.
So this dot dot dot in Python
is the syntax for the ellipsis object.
So we use that, numpy uses it too.
So we use that to be a reference to the environment itself.
So if you do dollar sign curly brace dot dot dot,
you get back the environment object,
because dot dot dot is obviously not,
or an ellipsis is obviously not any environment variable.
And it's a big mess,
which is why we didn't wanna cover it this soon,
but there it is, and we will get back to it in a bit.
Okay, so yeah, the goal here is like,
because it's just a mapping,
you can test if things are in the environment
through the self lookup.
Okay, wow, a break already.
That can't be right.
No, probably not.
Okay, so we're not gonna break, yeah,
because it's too early.
I built up your hopes,
and then I'm just crushing them right now.
Crushing it, yeah.
Okay, so Gil's gonna take over for this next part.
And maybe.
I'm not gonna move this one.
Yeah, yeah, it's impossible.
Okay, so we've sort of looked at,
you can still run sort of a sub process command,
like a regular terminal command, shell command,
and you can also run Python modules and functions,
and you can sort of set them to environment variables
and then use that.
But where this really starts to come into play
is when you wanna be able to start
mixing those two things together
to sort of get the best of both worlds.
So the idea here is that,
in a lot of ways, conscious makes up,
using sub process really, really simple.
Instead of trying to remember,
wait, you set this sub process.pipe thing somewhere,
and how are you gonna parse the output and all that.
We just, all that's being handled for you
in sort of a more intuitive way.
And we have a number of operators we've added
to sort of help with this interaction
between sort of sub process mode and Python mode.
So the first of these is dollar curly brace.
Or parentheses.
Parentheses, yes, sorry.
I do remember what these are, sort of.
And what it does, actually similar to bash,
is it captures the output of a command,
but then it returns it as a string.
And it really does return the whole string, right?
So the output of LS has a bunch of line breaks in it,
so there are a bunch of line breaks in the output.
What that means is that if you print it,
you actually get what the output of that was.
Similarly, it is a string, right?
Like a Python string.
So if you type X dot and then hit tab or something,
or just like you have all of the Python string methods
available to you.
So if you wanted to split that, say on new lines,
which might be a useful thing to do with LS,
or you really like uppercase letters,
and you wanna do that,
or however you want to mutate and parse and change
that captured output,
all of sort of Python's built in helpers
are already there for you.
You don't need to sit there
and like try to write these things yourself.
Cool.
Okay.
So the second is bangparens,
and this does the same thing,
and then also other stuff.
So what it actually is returning,
if you run a command with this,
is a command pipeline object,
which is sort of a const thing.
And it includes the output of the command as well,
but also a bunch of information
about like the PID of the process,
what the return code was,
what the actual argument you ran was,
if it was an alias,
what did it expand out to,
what are the starting, stopping timestamps of that command,
and also this object itself is truthy.
So if the return code is a success,
then you can actually say like,
if bang this command,
like print this command,
and if it's successful,
then you can use that for control flow.
So there's sort of a way to easily figure out,
like I tried to do this thing,
was it successful, yes or no?
What was the output if it was successful?
How long did it take?
Like all of this is just available to you
in sort of the command pipeline object that's returned.
I think this is what I just said.
Yeah.
I didn't do a failed command, but that's okay.
That's all right.
Does anybody have any questions about those?
I am ready to choose the negative condition.
Yes, in some, although in Python it's a tilde, yeah?
Yeah, yeah, that's right.
So in Python, if you wanted to negate something,
you use not or tilde,
or tilde is the invert operator, but yeah.
Yeah.
Oh yeah, also so you can iterate over the output
of these commands line by line.
In bang exclamation point.
Yes.
In enumerate ls and then print, what is it, f string?
Mm-hmm.
And then just i and loke.
Oh, probably should have stripped loke, but that's.
That's okay.
That's okay.
We can do it next time.
Yeah.
Or this time.
For example.
Right, so the new lines are still in that loke,
in that object, that loke object that ends up there.
And this is streaming, by the way.
So that if you wanted to stream through your command,
right, if you got output that's larger than memory,
this is how you would bang parentheses for that, so.
Also in the list of things that we may have not mentioned,
there is this multi-line prompt thing that keeps happening
that we've just sort of been using without mentioning.
But yeah, so it's like in the same way
that I Python functions,
this is a full, you can just keep,
as long as your, you can either shift return to maintain,
like to force a new line,
but as long as the command isn't complete,
it'll just keep adding a new line for you to type on.
Two entries at the end will run the thing,
and then when you arrow up through your history,
it will load up the full command,
like the full command block for you,
you don't need to like go and hit arrow up
for each of those individual lines you were doing.
Right, so I just hit arrow up there once,
and I returned the whole input, so.
And arrow down, returned.
Okay, thanks.
So we just went over, those are captured sub-processes,
and then there are uncaptured sub-processes.
So here again, we're using dollar sign and bang,
but this time using square braces.
And they function the same way as the captured ones,
except they don't capture.
And so the output of the command
still goes through to the screen to standard out,
or standard error depending,
but you can still capture that metadata along with it.
So in the case of dollar sign square braces,
it always returns none, actually.
And so this is more for forcing sub-process mode
where a context may be a little ambiguous,
and you wanna say like don't try to interpret this as Python,
just run this as a command instead.
The bang bracket there.
So the output gets streamed to standard out still,
so you see it and it runs as if you just ran
the command regularly, but at the same time,
similar to the information from the captured sub-process
about the starting and stopping times,
the arguments that were passed in,
if it was successful or not,
all of that is returned as a result of that operator.
So you can have the output still showing in front of you,
but still be operating on what were the conditions
of that command that it executed successfully?
Should I stop?
Should I continue?
Right, so you get this rich command pipeline object
back out that you can manipulate.
And this particular bit of syntax
is the thing that really underlies a lot of conch.
So what's actually happening?
So if you just run LS here,
what conch is doing is it's secretly adding
in a bang square bracket around that LS.
That's it.
Yeah.
Okay, right column type, good.
Oh, good, yeah.
So now, I would suggest we just take a few moments
and just to play with each of these a little bit
to get a handle on them.
This is basically the end of new syntax
that we're gonna introduce largely.
Wait, except for one big one coming up.
But just to kind of get a sense of how they work,
make sure that they match your expectations,
like what should be captured, what shouldn't be captured?
How do you interact with the attributes
of these returned command pipeline objects?
What is in there?
Is there something you would like to be in there
that's not, we can talk.
You can definitely work on that.
And just as a general mnemonic for this,
because it's a bunch of stuff,
I've sort of come up with curly captures in square streams.
And it's a bit misleading
because it's all sort of streaming in one sense.
But like if you want output to not show up,
use the curly things.
If you do want it to show up, use the square things.
Does anyone have any questions about this stuff?
No, we just threw a lot at you.
Yeah, back there.
So the last one, we put bangSquareBracket,
but that will print it and not save anything from the variable.
Almost, so bangSquareBracket prints it,
but does save it to the variable.
And then bangParentheses prints it,
but then doesn't save it to the variable.
I know, yeah.
So basically what's going on here is that
dollarSignParentheses returns a string, right?
It doesn't print it.
But if we wanted to stream that, so we use bang,
what should that return?
Command, pipeline, sorry, is that all right?
Yeah, so what should that return?
None, right?
Because, oh, no, it's not none here.
Did I do something wrong?
Yeah.
What did I do?
Did the guy-
No, it's not.
That was, no, not, no, it's not.
Oh, it's still, maybe it's not,
it's like when you do a sign,
no, that's still the thing, so.
Oh, no, sorry, ha, ha, I did this wrong.
Yeah.
So if you do dollarSign, if you change these
to square brackets, because you want to stream,
because square brackets kind of look like pipes,
that should return none rather than a string,
because there's nothing to return.
You're already, the output that's coming in
has already been consumed and printed,
and so it's been streamed,
and there's nothing left to return.
Which is why you see, because we did this is none,
we actually got this, we got this true printed behind us,
even because the command actually printed, right?
We didn't capture it.
If you wanted to capture it,
or if you wanted to do bang parentheses,
the bang is what gives you the object back,
and whether it's streaming or not is determined
based on whether it's square brackets or not.
Yeah, so the way to think about it,
this is dollarSign returns strings,
and bang will return something else,
and then square brackets,
or in parentheses will capture,
and square brackets will stream.
Nine, yeah.
So what is then the difference between bang with square brackets
and just typing the LS command?
There is functionally no difference
between bang with square brackets
and just typing the LS command,
except in ambiguous cases.
So in cases where you have both a Python function
and a system command with the same name,
or a Python variable,
and a system command with the same name,
like say I just said echo equals wow, or something.
Right, if I now went to run like echo,
hello world,
well that'll work because the syntax is not ambiguous,
but let's say I went to write like echo,
like dash,
what's another echo minus echo for example,
which would be totally normal?
Well, okay, but we would want to print minus echo,
right, in a normal shell,
but both of these are variables.
And so if you need to,
you can always explicitly put it in bang, square brackets,
and then it'll run.
So I can escape from sort of the Python?
Yeah, so there's two things going on here.
So, or there's one thing going on here, one or two.
So there's many things going on.
If you're observing it, there are two, and then.
Yeah, it's complicated.
Basically, what's happening is
there's a formal conch language
that always uses bang, square bracket, okay?
And then we have what we call,
so there's a context free grammar that we use
that always uses the square brackets.
Then we do this context aware grammar munging.
So we know, because we know what commands are available
and what your execution context is,
we can, we actually go back and rewrite the AST
of your code in such a way that we think it will execute
before we try to execute it.
And that's what's going on.
And so if you need to,
you can always go to the formal grammar.
And you can even turn that off in the exact,
we're definitely not doing that in this tutorial,
but you can turn that off and make sure it's always formal.
That's a terrible way to live
because you always have to type this bang exclamation point
and the whole idea behind conches
to make the things as easy as possible
and match what your brain thinks it should be doing.
Like your brain thinks LS-L should be a command.
And just because that's not a Python variable
doesn't mean it shouldn't be something that works.
And so we have a lot of like heuristics
that are relatively simple that get you incredibly far.
But if those heuristics fail for some reason,
which they are, it's very, very infrequent,
you can always go back to the formal grammar.
So.
Yeah.
Yeah, I should maybe say curves,
mnemonics are hard.
So the curly braces are for,
like with the dollar curly braces
for like an environment lookup
or for accessing the environment.
Whereas these are more just generally capturing
a command that you're running
and capturing the output of it.
Right, so this looks up a variable in the environment.
Yeah, rather than, yeah,
rather than running a command.
So, yeah.
Okay, so the question is
what's going on here?
So you're saying LS equals.
So if you say LS equals one here.
Okay.
And then you say LS,
then you were saying LS.
Right, so why does this happen?
Well, this happens because L is not a variable
in your Python context.
If you just do LS and then we dot it, right?
This is a LS itself is just the integer one.
Right, the, the, the, the bang square brackets
are capturing the whole thing.
So yeah, so if I set L equal to one
and I do LS minus L,
you'll get zero because they're both variables.
Python always wins, right?
So the Python invi,
the Python context always wins.
Yeah.
Your system is whatever.
Nothing.
All right.
Okay.
Having thoroughly confused everyone,
I think now we can just take a few minutes
for people just to play around with these a little more,
get a sense of what's capturing and what's not,
what comes back from these commands,
what's returned and what's printed.
Just to build up a little familiarity with it
and then we'll continue on.
And feel free to raise hands
and we can either circulate and just answer from the podium.
And we can fix this curly captures thing.
Yeah, yeah.
This is mnemonics.
Is anyone having issues with their system still
or, or installing or anything?
Yeah.
Or do you want me to come over?
Just really quickly, we had a question about
for people who have used VI mode in terminals
or in shelves before and want to do that.
You can do that.
You just need to set VI mode equals true.
Yeah.
And then you can bounce around your current line
using, you know, zero G, whatever.
Yep.
And then we'll just load it by default.
Yeah.
All right.
So I think Gil, you want to take it away?
I will take it away.
Are there any lingering questions
from our, our personal explorations?
Great.
You can also ask us later.
That's fine.
Yeah, that's totally.
So I think this is really the last bit of new syntax
we're going to introduce, but I could be wrong.
I'm wrong, but for a while it'll be fine.
So this is the, the Python mode operator.
So we've been talking for the last bit
about how you kind of capture sub-process output
and then, you know, turn it into like a Python string
of this command pipeline object
and then how you can play around with it
and inspect it and do things with it.
But the, the at-paran operator lets you go the other way.
It lets you insert things from your Python
sort of scope or environment into a sub-process command.
So what we mean is generally conscious,
like parsing is pretty clever at this stuff.
So if you give it, for instance, this command,
like for something in range two
and then just run echo high underneath that,
it will do the right thing, right?
You can put your like echo or LS
or whatever sub-process command you want
in the body of a for loop
and it will just execute as many times as you tell it to do.
And you don't need to do anything special.
That actually just works.
What does not just work is if you do this.
So you want to instead, you know,
iterate over the value in the for loop
and have it be printed.
You just get I twice, right?
So because it runs that command twice.
And so what the at-paranthesis operator does,
it lets you capture that Python variable
and insert it into that command.
So what it does, what it's actually doing
is it's evaluating an arbitrary Python expression
and then returning that value as a string
and that can be fed into the sub-process command
in this case, echo.
And if the output is not a string,
in case of like lists or sets,
it just gets joined and returned as a string.
So that's what that would look like.
So it's a little different than that, actually.
Sorry to...
Womp, womp.
Womp, womp.
Each element of the string is actually getting passed in
as its own argument to the command.
So each of these are their own command arguments.
So, and it's just that echo happens to join them together.
Yeah, thanks for closing the door.
We're gonna close it.
Not a good idea.
Any questions about this syntax or what it's doing?
Yeah.
So if you didn't use echo,
you said echo runs,
you got a few something else fault with it.
Yeah, so like if we did ls,
ls would try to search for all of these files individually.
So it's running it on each?
Yeah, it's running it for each, yeah.
Cause ls takes a big argument list like that.
How does it know when it can iterate and when it can't?
If it's iterable, it's not a string.
Right, yeah, the normal way.
Okay.
Yeah.
Just to clarify, echo here and ls,
the book that's called once.
Yes.
Yep.
And it just, right, echo, put them all together
because that's what it does.
ls, it runs about what it does because...
That's what ls does.
Yep.
Yep.
It's just passing each Python thing as its own,
each element of the list in its own argument
or tuple or whatever, so.
So it's essentially echo zero one two.
Yes, exactly.
It's essentially echo zero one two or echo,
or ls zero one two.
Yeah.
Okay, yeah.
Oh, yeah.
So if the result of the operator two is in the first position,
it gets treated as an alias.
So you can actually have this execute commands.
Probably like not something you wanna do.
Don't do this.
Mine is a really bad pattern, but it does that.
Right, but this is different because if you,
I've got my trace back printing on,
but you can see if you try to just print this
or if you try to run it without splitting,
that is treated as the command,
the name of the command, spaces included.
And so then it can't find the command
because hello, hello there, echo hello there
is not a valid command.
Okay.
Your promise for Morse syntax is already broken.
You should just stop.
I'm gonna stop saying it now.
So with apologies.
So you can wrap a regular expression in backticks.
And what it will do is return a list of every file
or thing in a directory that matches that regular expression
as a list.
And it's a Python list, which means you can iterate over it.
You can stick it in list comprehension
and mutate all the names.
And you can actually do even more stuff with these things
as you kind of go along.
If you're, oh, sorry, yes.
Yeah.
Yeah.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
So which version of which kind of regex
is the Python regex?
It's the Python regex, yeah.
Yeah, it's just the RE module.
Yeah, just a handy way to get into RE.compile.
Yeah.
Yeah.
So but those are, those are globs?
No, no, these are not globs.
Dot star is a regex.
A glob would just be star.
So that would be any dots and then XSH.
Yeah.
Anything.
And so we could, maybe a better example would be,
what's a,
what can I do?
Okay.
So we've got some pings in here, right?
So like, what if we wanted to,
if we wanted to like grab,
I guess we don't have a lot with anything
with.
I want pngs that have the letter O in them.
Yeah.
So like that's right.
So do dot star O dot star dot or slash dot png.
But also regular expressions are hard.
So if you, if you wanted to use globs,
let's just say somebody had mentioned that.
Then you can prefix the back ticks with the G
and then it is glob matching.
So you don't need to do the dot thing.
That's just, you know, like star.md, star.png,
star, whatever.
And as an extra special bonus in Python,
I think three six and above,
this supports recursive globbing,
the way that the glob library does.
So if you do like a star star slash star.md,
that will recursively glob
through the entire directory structure from where you are
and find every single markdown file in that whole chunk.
This can take a long time.
Like be like use this, you know,
like if you'd run find at your root and it takes forever,
like same thing.
But it's really, really handy for finding all of the sort
of files or patterns matching something in a large area.
Any questions on this before we go on?
All right.
I'm just curious as to the use cases
of letting you guys to create all of these.
Yeah, so we can't, we can't,
I'll say this, so the question is like,
what are the use cases that led us to create all these things?
And just as a general like, cont creation story,
almost everything in here is something we were like,
you know what we really need to do,
thing we need to do today is this thing.
And then we did that.
So they were all created from actual,
and us and other contributors,
people who were like, I really need this to do thing X.
And then what we discovered along the way is that a lot
of it tied in together really well,
without us having to do anything extra.
We'll come up on some of that stuff around the way,
some of the string matching and string literals work.
So like one thing I just showed for the globs
in particular, right?
Like being able to loop through a glob list is,
with this syntax is a lot nicer, right?
Yeah.
You're doing that a lot.
Yeah.
So at what point do you switch between writing a script
and conch through just writing a Python module with a CLI?
Like, is that a size?
So yeah, so the question is about trading off
between Python module CLI and writing something in conch.
For me, it's really about how much you're hammering
in sub-process.
So if you're interacting with sub-process a lot,
like do not write it in a Python CLI,
write it in conch.
If you want some of these extra fancy features,
like you really just want to be able to glob tick things
very quickly or you want to search through whatever,
then do it in conch as well.
That's my kind of, we'll see some other syntax later
where there's conch specific things,
but at this point it's kind of like,
if you're doing a ton of basically scripting,
you know, like then you should be using conch
because it's actually meant to the scripting language
unlike Python.
Do you have examples of like CSD pipelines
and stuff like that?
Oh yeah, yeah, yeah.
Well, we can talk about those afterwards.
Yeah, yeah, yeah, for sure.
For people who work at a certain institution,
they can also use all my internal ones,
just saying like, sorry, everyone else.
I'll show you other things, but yeah.
Tom, I think you're next.
Can I work conch and grab some of this stuff
directly in Python?
Yes.
Yep, so the question is, can you import conch code
and use some of this stuff in Python?
I mean like, can you personally,
like if I just want this like nice,
some of this like string matching,
can I do like conch.
Give me the list of files and have it.
So we don't have a, so yes-ish.
We don't have that particular use case
lined out so much, but so I would say
there are two things there.
So one, we have a quote unquote standard library
where we have sort of extensions and updates
to standard library things to make it easier.
So you can do like import conch.lib.os
and you get some like, like you get a remove tree
that actually works on all platforms
and you get like, if you do like sub process,
you get a version of run that uses our thing
and returns a command pipeline object.
And you can also just get an executor back
and then you can like, like you would run conch code
and you're like, you would run Python code
through a normal like exact thing and you can do that.
That might not be what you want exactly,
but I like the way your brain is thinking.
So maybe we should talk more about that after, yeah.
So, and there was another question back there, I think.
Yeah.
Yes.
For, if I wanted to find files like .conch.rc,
how do I compare the .conch.rc
to regex and I can get it, is there a way in regex?
Yeah, in regex, right?
So it's just a normal, you just have to do, right?
Like say, let me just go back to my home directory.
So the question is about how do you get your .files
with a regex?
Well, you just use backslash. which is the regex,
regex escape character for the .character.
So the, oops, let me go back up and show you.
Apparently I've got a lot of configuration going on.
So you would do, are we?
Anthony.
Don't tell anyone.
Yeah, I'm secretly a bash user.
The, so you would do backslash. and then .star
to match anything, right?
So the backslash. is a literal period.
Since we have batch history,
how does .conch deal with multi-terminal history?
Is it sane or not?
So I would argue that it's more sane than a lot.
So the question is about history.
How does .conch deal with multi-terminal history?
So conch sort of cribs from the Jupyter playbook a bit.
So by default, all of your history is stored per session
in a JSON file in the standard configuration location.
So you can go back and get each session's history.
And then the terminal application itself
will present that to you in whatever nice way it needs to.
You can also switch to a SQLite history backend
if you want to store SQLite.
There is tons of, there's basically as much metadata
as you want in the history.
And that's very configurable through environment variables.
Not gonna go through that right now.
But.
That was the thing that sold me on conch initially
was I was trying to figure out
how I'd compile the certain version of Petsy.
And I couldn't remember which environment variables
I had set when I ran the thing.
And you can't figure it out.
You look at your batch history,
you're like, well, it was one of these seven.
Because then you do this in conch,
you're like, oh, it was this term,
it was this session when I ran this thing in the tests past.
Those are all the environment variables I need
because they're just in one self-contained file.
Do you have a question over here?
Yeah, sir, is there really important alias
for the batch in the training?
Yes.
If you run source bash,
you'll get the aliases from bash.
With one caveat, you might have actually seen this pop up
on the screen, which is that if there are,
there are collisions in certain aliases
and also there are things,
the Z-shell specialty does is they have like their own built-ins.
And if the alias refers to those built-ins,
we don't pull them in because it'll just break
when you try to run it.
Because it's gonna look for a command that doesn't exist.
Can I get the history of a batch into...
I think there's some experimental,
some people have done that,
but yeah, I don't use it.
But yeah, there are people who do that.
We're happy to help try to figure that out though.
Well, I am anyway.
Okay, move on, but cool.
So, next up, this is not new syntax for const anyway,
but it's for Python.
So, formatted string literals are great.
And they're part of Python,
which means if you are running punch on Python three, six,
or higher, which you should be, then they just work.
And they're really fantastic.
If you haven't played with these,
I think they're my favorite simple thing
that should have always been there, I think.
I really enjoy them.
And yeah, the way they work,
if you have a variable defined,
then instead of doing a dot format
or doing like the parentheses argument,
you can just have a string pre-pended with an F.
You wrap curly braces around the variable
and it just gets evaluated at that time
and then prints the results.
So, it's very handy.
We also have a thing that is not in Python,
which is called a path string literal.
And this, if you pre-pended string with a P,
and then you have a quote,
what it returns is a pathlib path object
of the string that's there.
So, for instance, if you were,
I went the wrong way.
If you do like path equals thing,
you got a, you know, on Linux,
you got a POSIX path on Windows,
you got something else,
but it's just using pathlib under the hood,
so it'll work.
If you save that to a thing,
you can also then use tab completion on this object,
like check, does that folder exist or not?
You could then create that folder,
or I mean, pathlib, this is just using pathlib.
Pathlib is great, but we have this sort of short cut syntax
to get into it.
Oh, and the other, just a little great thing about pathlib
is that you can do path joining,
using the, they overloaded the division operator for this,
so you just do like,
pathlib object divided by thing,
and it does the join correctly,
depending on the underlying operating system,
so it takes like all of that deep pain out of like,
trying to get stuff to work on Windows and Linux
at the same time.
Yeah, so there are F strings from Python.
We've added P strings.
The natural question is, what does a PF string look like?
And it looks like awesome is what it looks like.
So you can define variables,
and then you can say PF,
and then the string,
and then you can treat it like an F string
in the sense that you can put curly braces
and it will fill in the value of those variables
in the string,
but it's also saying this should be a pathlib path,
so it returns you a pathlib path
of the result of the F string.
If you've ever done a lot of painful DevOps,
this just might seem appealing in some way.
And the other really handy thing here
is that the environment variables,
they are also Python objects,
so you can evaluate those in F strings,
which means you can evaluate those in PF strings,
which means you can start chaining together
environment variables and other values
and other things to construct paths and folders
and file locations programmatically.
And then once you have the pathlib thing,
you can start saying, does this exist?
Great, if not, touch it, like now add it over here
and now move it over here and now do this thing.
And all of these things will be cross-platform
because it's just using pathlib under the hood,
so you don't have to worry about which slash you're using
or what's being escaped appropriately.
Hopefully your eyes don't bleed.
Yeah, hopefully.
Any questions on this stuff?
Probably not too bad?
Okay.
Okay, so we have a couple of exercises here.
The first one is to look up the absolute file path
of every markdown file in the tutorial repo.
You can use whatever you want,
you can use bash if you want to too, that's fine.
But PF strings and glob ticks
are probably your friends here.
And then a phone here is to load up a dictionary
of every conda package you have installed
in your current environment.
If you're not using conda, you can just skip this one,
that's okay.
If you have questions, of course,
just ask us and we'll all come around.
Yeah, so load it up as a Python dictionary.
What's the name of the conda package?
Well, the hint is important.
Yeah, run that conda list JSON command
and then I would go from there.
All right, okay, well then I think we'll go on
to the next section, which is the environment.
So we touched on this earlier just for a moment,
but this will be a little more of what's going on
and what you can do with it.
So the environment actually lives in dunderconch.env,
that's the everything in conch is living
in this dunderconch thing,
that's where all of the various bits and pieces are,
if you want to explore and play around, it's all in there.
But the dollar curly brace ellipsis
is a shortcut to that object,
so you don't have to always just type dunderconch.m
to get there.
As we mentioned earlier,
you can check for membership in the environment
just using string in environment.
And you can also ask for help for environment variables.
So there are a lot of different modes
and kind of extras are enabled via environment variable.
So if you know the name of the environment variable,
you see it, they all have default values.
So if you see something that is in your environment,
you're like, what is auto CD and why is it false?
You can ask for help and it will tell you
that if you turn it on,
then you can just type the name of directory
and if it exists, it'll just CD into it
without you having to type CD.
Huh?
Yeah, the help is a method.
Yeah.
Yeah, and also the docs will tell you
if something's configured a month.
There are a few environment variables
that you are not allowed to configure.
We don't let you.
So also something that's very different from Bashland here
is that contra environment variables are Python objects
and that also means that they're typed.
You can have arguments about typing in Python,
but not now please, but they do all have types
and sometimes those types are actually imposed
based on a variable name, particularly
and the important ones are anything that ends
with path is going to automatically be converted
into what's called an end path.
And if you've ever had the scenario,
let's just, we can do a show of hands or not,
but where you've like sourced your Bash RC twice
and now your path is your entire path
and then your entire path and then something else again.
Wow, we've got four best.
Wow, that just, that was a raised hand.
Yeah, so many of us have been in this pain place before.
That's terrible.
So in conch that is not,
this is not a colon delimited string
and which comes back to how do you split a non-whitespace
delimited string and yeah, anyway,
you don't because that's terrible.
But so path is an end path,
which just means that it's a list of the items on your path,
but this acts like a list,
which means you can do things like pop individual elements
at arbitrary positions out of the path
or you can insert directories into arbitrary positions
in the path, which is great, really, really great.
Sorry, one more question.
Yeah.
So if I do this and then exit the conch,
so that stays the same in my path.
No, so just in this,
if you're mutating your path in your session here,
it will last for that session until you exit out.
It won't like also, it will not like translate
to like a separate terminal when you have opened.
Those are gonna be totally separate.
So I think the question is if you start conch,
when you play the path and then exit it,
you're backing to the root of the bash shell.
Yeah, yeah.
But if you wanted to do path manipulation
for all of conch, you would put that in your conch RC.
But can I push this back up to the bash
that I launched conch?
No, because.
Why are you launching conch from bash?
Just that is your conch.
I mean, that's the real answer,
but the reason you can't do that is,
it has to do with how processes communicate.
And so if you want to push environment variables
into a parent process,
the parent process has to source
something coming from the child.
And so you have to be able to source,
like you would have to get conch
to dump out the environment
in a way that like bash or something could source.
But it's mostly because it's obviously so much easier
to manipulate your environment.
But maybe that's not always how you will be,
if you have, let's say, some protected environment
that you have to work in,
some other place that's manipulated easily.
So it would be an environment export?
So we do that, yeah.
Yeah, so you could, okay.
So maybe there's a solution for you.
It'll be ugly, but it'll work, maybe?
We'll find out.
Subprocess.
Yeah, all sub-processes get this path.
How are you supposed to stock conch?
Sorry, the question is how are you supposed to start conch?
So there's basically two ways to do it,
maybe three, I'm gonna say two.
One is you open a terminal,
it's running some 1970s piece of software
that doesn't work really well,
and then you type conch
and then you're in something better and newer.
The other thing is,
depending on your operating system of choice,
you can just have it start as your default shell.
On Linux, this means adding it to Etsy shells
and then setting it on,
if using I term, you can actually just have a profile
that you can say, like,
I want you to launch this executable
when I open a terminal or this profile.
Yeah, basically any terminal emulator
in the Unix land will let you set the launch program.
So you just set that to conch.
Or you change your Etsy shadow.
Or you change your Etsy shadow
if you want it to be a true login shell,
which conch can be, so.
Right, so yeah, in conch back to-
There's docs, also there are docs on that on the website.
So if you really, there's platform-specific docs.
So if you want to go look up that, you can see that.
It's right at the very top.
So the paths are nth paths, sorry, back environment stuff.
Other variables are booleans, other ints.
Whatever they are,
like when you grab that environment variable in conch,
it will be its true type, you know, it'll tell you that.
That said, if you need to,
like some subprosk commands require, you know,
these things to be fed to them to strings.
And so conch does that for you by de-typing it.
And you can also explicitly request these de-typed things.
So you're asking like, how do you manipulate your path
and then do it?
You could, I mean, like de-type it,
overwrite your bash rc, exit out, and then source again.
That would be moderately terrible.
But it would work, as long as it was an absolute path
and you weren't like recursively sourcing it,
it would probably work, yeah.
Yeah, you can also do de-typing.
Yeah, and so that will,
depending on what it should look like
in the base environment it'll do,
you know, give back zeros or ones, not trues,
and paths get turned into cold and delimited strings.
Yeah.
There's a couple of other handy methods
on the environment itself.
In particular, one that's very handy is swap.
And so what swap does is what swap does with,
in general, actually.
But so you can swap in a new value,
basically overwrite something, and it's a context manager.
So only for that block of the context manager,
you can mutate certain elements of your environment
and then they will get undone
as soon as you are out of the context manager.
And then,
like,
that.
And then, if we try to access this down here,
it doesn't work,
because some of our has been removed from the environment.
So this is really useful for like,
temporarily modifying your path
or temporarily entering like a new,
like a new context that you need to run something in.
Like say you wanna switch between a million versions
of CUDA for some reason, like this is a way to do that.
No one would ever do that.
No one would ever do that, yeah.
Come see my tutorial tomorrow at ADM.
Okay.
Yes, question?
Maybe one question about this.
Uh-huh.
So traditionally, the way you would do this
is you would sort of prefix the command
that you enter on the command line
with sort of the environment variable
and the version to use or the value to use.
Yep.
Does that work in conch as well
or do I need to use this context monitor?
So the answer is both yes and no.
So we don't have a particular syntax for doing that yet,
because that turns out to be pretty complicated
in some edge cases that we'd like to work in conch
that don't work in bash,
but that's a whole separate thing.
But you can always run commands through nv.
So if you wanted to do nv sum var equals 10 echo
sum var,
well actually that, so that doesn't work in bash either,
I think is the thing.
Yeah, that's one of those.
This is one of the things that doesn't work in bash
that we would like to have work in conch.
And so this is why this,
this is why this, like we really want that to work
and the fact that that doesn't work
is why we have swap and other things.
But if you wanted to set other environment variables
and things like that, you can.
So the biggest export that should work in bash?
In bash, I mean?
Well yeah, so that's a different line.
Right, so export will export it to everyone
and then you have to unset it, which is annoying,
if you want to remove it afterwards.
Right?
Yeah, so that's what swap gets you.
Yeah.
Can you specify multiple variables in swap?
Oh yeah.
Yeah?
Okay, so then could I have a context,
like maybe like a dictionary or something?
Yeah, yeah, you could star-star keyword arcs into that.
Oh, definitely.
So that would be really nice for kind of
here at work, because you're talking about.
That's there.
Okay, so we have a few more exercises here using this stuff.
These are things that I'll say,
like I both do on a regular basis,
like these are true life examples.
So one is use get pass
to temporarily set your password and environment variable.
So this is actually, so far as I can tell the only way
to securely type your password into a terminal session
without it ever being saved anywhere,
like including in your terminal history.
And the second exercise is this also happens to me a lot,
which is like if your native package manager
doesn't like condo curl and keeps yelling at you
because like there's some sham is match,
you just want to run an install command
and just for that one install command,
pop like the front element of your path off,
but you don't want to mutate your path forever.
You just want to do that, this one thing.
So just, you know, temporarily mutate your path,
run some command and then return it.
I'll give you guys a few minutes
so we can circle around and answer questions.
All right, so before we move on,
any questions on the previous stuff?
Yeah, the break's over, anything?
All right, so the next section we're gonna be talking about
what we call callable aliases.
So callable aliases are basically a way
for Python functions or Python callables
and sub-processes to exchange code
in a more integrated way than what we've seen
through sort of the at operator
and some of these other curvy braces or curvy,
I forget the mnemonic, this is curvy, curvy captures,
that's right.
So we're gonna be building up sort of data pipelines
in a more integrated fashion.
And basically what callable aliases allow us to do
is run any Python function as a sub-process command.
It's not any Python function really
because it requires a certain set of known signatures,
but assuming you adhere to that
and we're gonna be going through what those are,
then you'll be able to run them.
So they're callables, right?
So that part makes sense.
They're aliases because they get stuck
in what's called the aliases dictionary
or the aliases mapping.
So this is something that gets shoved into built-ins as well
and it's just a mapping between all the possible
different aliases that exist.
If you're familiar with other shells,
you sort of know what an aliase is, right?
So, and if you're not, you'll see it's just another way
to look up commands.
It's another dictionary to look up commands in.
Does this need to be plugged in?
No. Okay.
All right.
So the first function signature
is just an empty function signature.
And it can return either a string
or an integer return code where zero means success
and everything else means various degrees of failure.
So you can do this with a lambda if you want.
So go ahead and type this out.
So if you say aliases set item banana equals lambda
with no arguments and then banana for scale new line,
you can then run the banana command.
That is it.
That's the essence of callable aliases
and that should just work.
So this is serverless for your shell.
Yeah. So as Tom Caswell,
I'm going to say his name out loud.
Tom Caswell says this is lambda for your shell.
Serverless for your shell.
I'm going to misquote him shamelessly as well.
So, okay.
Map plot live?
Map plot live, that's right.
Yeah. As long as we're mispronouncing things, I think.
Okay. So you can pipe this into any other command.
So the WC command counts characters and lines and words.
So if you pass the dash W flag,
that means to count the words based on white space.
So you can say banana pipe WC dash W
and that'll tell you that the output of the banana command
has three words in it.
And if you think about what it would take to do this
in using sub-process with streaming data in and out,
this is doing a lot behind the cover,
under the covers to make all of this work for you.
But it feels pretty natural, right?
Because it's just a command,
just a Python function you're running as a command
in sub-process mode.
And of course, if you want to get rid of that aliases,
alias because you don't like bananas,
you can delete that alias in the same way
that you would delete any other item out of the dictionary.
Any questions? Yes.
You can do the swap function on that.
So swap is for environments
and aliases is a totally different mapping.
Yeah. Having a swap is not a bad idea though.
Please open an issue.
There's a banana command on Ubuntu.
I did not know that there was a banana command on it.
And boss do.
I don't know.
What are you doing?
Where do they live, Anthony, if you don't want me to ask them?
Where do what?
Yeah, aliases live in their own dictionary
that gets shoved or unfortunately aliased into built-ins.
So we're not really in this tutorial talking
about how Conch does all these tying of things together
under the covers.
But in built-ins, there's an aliases dictionary
that you can access at any time.
Yeah, and that allows it to persist.
So you can modify aliases
or add these commands in your Conch RC
and then they all live indefinitely.
Okay.
The next is that you can take a single argument
which is the command line arguments.
So like sys.rv, if you're familiar with that.
And it comes in as a list of strings.
So if you provide one argument that's called,
it's typically called args,
then you can take command line parameters.
So here's an apple function which takes an args.
It'll look at it and it'll say,
is my args list of length one?
And do one thing and succeed, return zero, right?
Because you can return the return code from these functions.
And if not, it'll,
and otherwise it'll return one.
So yep, and then,
and just showing off another bit of syntax.
If you use this with the at Python mode operator,
you don't even need to stick this in aliases.
You can just call it directly
because it's a Python object.
So if you put the command,
the function at parentheses function as the first argument,
and then pass in some command line arguments after that,
it'll read it in.
Any questions on how this works?
Any callable will work.
Any callable will work.
So callable classes are?
Callable classes are, yes.
Yes, go callable classes.
Yeah, this is not limited to functions
and lambdas and things.
Okay.
Yeah, and of course, there's a formatting bug,
but that's whatever, yeah.
I actually have a quick question.
Sure.
So how do you, if you're treating aliases
that do different functions,
what is it, so would you rather do a function,
create a function in your environment
and have it be stored in your building
rather than doing like an alias function
like you would do in bash?
Yeah, so the question is would you just want this
to live in your cont execution context,
the Python execution context,
or would you want this to live in aliases
specifically like you might do in bash?
Oftentimes, you just, you stick them
into the aliases dictionary like you do in bash
because it's easier to call them,
it's simpler to call them.
It's kind of, that's kind of what that's there for
and where it lives.
If for some reason you don't want to have it there
and you just want it to have it
in your execution context, that's fine too.
Yeah.
All right.
Okay, so let's move on.
So in the next case,
you can provide in sequential order
any of standard and standard out and standard error.
And these are keyword arguments
and they default to none.
You may not have one of those streams,
although usually you have standard in.
So those come immediately following
the arguments parameter.
So here we've got a grape function
or an underscore grape function.
This is actually the most common pattern, sorry,
is you have the function name preceded by an underscore.
And then you put that into the aliases dictionary
without the underscore.
And basically what these do is these give you file-like handles
for standard in, standard out, and standard error.
So if these are present, you can access them
and do whatever you would do normally with those handles.
So we do some contact switching under the covers too.
So like if you just write to sys.standard in
or sys.standard error, et cetera, that works as well.
But it's usually better to write directly
to those file handles.
So here, if you wanted to implement something
that's streaming, but not asynchronous,
you would do four line in standard in.
You'd be reading lines from standard in
and then we'd be writing them out,
but write back out to standard out,
lowering them as we go.
Okay.
Yep.
The underscore pattern is there because when you source,
you don't get the underscore variables
in your execution context.
Those don't get brought in automatically.
So it's a way of hiding things from your execution context
if you don't want to pollute the namespace
that you're just working in all the time.
Yeah.
Okay, so usage, here we go.
So this takes a standard in and kind of needs it
because we didn't check if it was none here.
So if we use spell echo rath with a,
and then pipe that to our grape command,
it will lowercase that and write it back out.
This makes sense to everybody, right?
So the standard in, the output of echo rath
becomes the standard in of the grape function,
which then operates and then writes back out
to what is our terminal's standard out.
Because that the grape is being called last in the pipeline.
Okay.
You can use any of these,
but if you want to use standard error,
you have to use standard in and standard out.
Yeah, that's about it.
Okay.
Whoops, yeah.
So next up is you can also get a handle
or a reference to the command specifications.
So this is a specific object
that the command pipeline also has access to.
It's basically how Conch thinks
you should be running the command.
It's how the command pipeline got set up
for that particular sub command.
So this is a rich Python object.
You can go look at the API if you want to,
but it effectively contains all the metadata
about how you should be running that command,
including what goes in and what goes out.
So that'll come in after the standard in,
standard out, and standard error.
And you can do kind of like funny things here.
So one of the things you can do is you can use this for
is you can check whether the command is meant
to be in a captured sub process.
So that we talked about that before.
So you can check to see like,
am I running this in a captured sub process or not?
So this is particularly useful
if you want to know if you're connected
to a live terminal or not.
Or if you want to like,
this is actually used in the which command pretty frequently
where you don't want to append a new line
if you're capturing it.
If you're just printing it out to the screen,
you want the new line to be there
because you want everything to look nice,
but otherwise you don't want the new line to be there.
So, and you can import part of Conch
to do this check for you.
If that makes it easier.
And here's just our Kiwi.
And this will have output that looks sort of like this.
So if we just run the Kiwi command,
and then end equals end,
but you didn't close the quote.
And then,
yeah, so if you just run the Kiwi command on its own
in an uncaptured way,
it will produce the new line and the extra text.
And if you capture the Kiwi command,
then it doesn't actually have the new line in it.
Okay.
Any questions on this or use cases?
All right, so let's move on.
So the last form of these functions
is you can get back the stack frame
of the call site of the alias.
So if you need to know the locals and global variables,
where the sub-process command was being called from,
you get back the stack for that.
If you don't understand what this means,
like don't worry about it,
you definitely don't need it.
But if you do, this is like a ridiculous tool.
So please stack responsibly.
But it is something that's like,
we don't need to necessarily dive into this,
but it is occasionally useful to know what the variables are
around where the sub-process is being called.
And Conch does that tying in for you automatically.
Any questions on this?
I know this one in particular is a little wacky.
Okay, so we've got some more exercises.
They're all related, which is nice.
So the first exercise is to write a callable alias,
which just pulls down the contents of Frankenstein
and writes them out to the screen.
So if you look at that link,
it's basically the Project Gutenberg link.
And so you can just copy that and provide an alias
that prints out Frankenstein to the screen,
grabbed from the internet.
Or you can grab it and then print it out however you want.
The next is to write an alias that calls upper
on the standard input and returns that as output.
The next one is to write an alias that returns
all of the unique sorted words coming from standard in.
The next one after that is to write an alias
that counts the number of white space separated tokens,
red from standard in.
And then finally combine all of those
into a single command pipeline that executes.
And we will definitely walk around and help,
or you can look at the details.
Each of these is basically a one-liner,
so don't overthink it.
But it's okay to overthink it if it gets the job done.
I think that's fully qualified.
Okay, so for the first one,
you don't need to use Python necessarily
to do this so much.
You can just set an alias to Frankenstein,
that is a lambda that calls curl or wget
or whatever on that URL.
And that will grab that URL that we listed just straight away.
So if you're using requests or something,
you can definitely do that, that's totally fine,
but you don't need to.
So you can use a command here.
Yeah.
So if you're getting stuck on that, that's there.
And then, yep, I'm sorry.
All right, I'll come over.
But we should, should we do the second one too?
Yeah.
So for the second one, if you want an upper,
all you have to do is take both args and standard in,
just read everything from standard in,
and then call, which is a string,
and then return the upper of that string.
You could also do it in this streaming version
where you have lines that you're reading from,
and then writing them back out to standard out.
It's a little more complicated,
you don't really need to do that here.
So for the third example, or the third exercise here,
we do something pretty similar where to the other,
where we want to count of words.
So the way that you do this is you read from standard in,
and then you split those, split based on the white space,
right, we're all pretty familiar with that.
If you want the unique, right,
so that'll give you this big word list in order.
If you want to unique that, you call set around it
to get the unique words, and then if you want them sorted,
you call sorted around that,
and then you join based on new lines
so that you output a string again,
and that's the thing that you return.
Kind of a lot of parentheses,
but it gets the job done in one line.
You could do it in more lines if you wanted to clean it up
like we did in some of the other examples,
but there's no need here.
Do we have the, we don't have these loaded in.
Oh, you do, okay, oh yeah.
Oh, nope, okay.
That's probably in the, yeah.
So for example, if you ran thus,
it's not perfect, right,
because this is text processing,
but there it is.
Then for the fourth example, or fourth exercise,
if you wanted to count the length of that thing coming in,
you'd have to basically do the same thing, right?
So here you'd read it in,
you'd split based on white space again, whoops,
and then instead of calling set or something else,
you call length, which returns an integer.
You don't want that integer to be the return code,
so you have to convert it to a string, add a new line,
and then you go from there.
So that's how you do,
or you can do WC.dashL,
because reasons.
You could also do that, that'd be a better example here.
You could do that in the alias, yeah.
You could run.
Yeah, that's the simplest form of the alias, really.
Then pull down Frankenstein.
Oh, I think we just did.
We really love this Frankenstein thing.
That's my fault.
That's your fault.
Thank you, Mike McCarty.
Yeah.
All right. Let's do it though.
Yeah, do it the right way.
What was it? Upper?
I want you to do this.
Then we'll debug that later.
Oops, sorry, you want the,
yeah, it's just words and then count, the real count.
Then the point here is that you can merge all of
these together in a single command pipeline.
That executes.
Okay. Any questions on this?
All right. If there's no questions on how this works
or what it uses, we'll move on.
Not a break, because we're doing breaks differently.
Our next topic will be events,
so switch with Gil.
Okay. It's hard to actually describe an event,
I discovered this, but it's a trigger that you can fire,
and then if you have something that's
set up to listen to that firing,
which we would call a handler,
it will then execute that thing.
That is a horrible vague description,
but I think it will be a little
clear when we actually go through an example.
I'll just say the events,
a system in Kant was written by one of
our contributors, Jamie Bliss,
and is just an incredible piece of work,
and I can say that because I had nothing to do with it.
It's really incredibly powerful,
and it lets you do a lot of really interesting things.
If you want to introspect your code or
have all sorts of things happen in response to all kinds of events,
you can really start to do
some very interesting, clever, and powerful things here.
Right. So I said this,
a handler is just a function that is called when an event is fired.
So something says event, this kind of event fires,
any handler that is attached to that event will then be run,
and you can have as many handlers as you want on a given event.
So several functions can be executed in
response to something just happening somewhere.
Okay. So one of the events,
all of these live in just the events built in at the base,
so you can say events.
One of the common ones,
there's several that are built in to Conch.
Later we can look at like defining your own,
but there are many that are built in.
The first is on change year,
which fires if you can imagine whenever you change directory.
So this event already exists.
So what we want to do is just create
a handler that will execute in response to that event being fired.
So the way that you do that is with this decorator syntax.
So you just say at events and the name of the event.
In particular, this event hands off
two variables to whatever function is being called as handler.
We'll show you how to inspect that later.
They're called olddir and newdir,
or olddir and newdir,
depending on your preferred pronunciation of words that aren't words.
Then in this case, just for a simple example,
I'm just printing out a message that says,
hey, we just changed from this directory to that directory.
So now you can just move around in your terminal like do a c, dot, dot,
and it'll tell you this thing.
You could go back into the like directory you were just in.
Of course, now your terminal is probably a little
overlever boasts and you don't want this to happen all the time.
So you can always remove handlers too,
because maybe you've made a mistake and it's saying way more than you meant it to say,
and you would just like to have your terminal back.
So the simplest way is just there's
a set of handlers on each event and you can just pop them off.
So in this case, events on changedir.pop,
and then you should see the thing come up,
and then you can just test to make sure that your terminal has recovered by going somewhere else
and confirming that in fact,
there is no longer something being printed every time.
So that was just a quick example to show you what an event will do.
We can now just dive in a little deeper into what's happening and
what all you can do and how you can hook into things.
So as we showed, you register a handler by just using the name of the event as a decorator.
Those input arguments, the keyword arguments that are there,
are being supplied by the event itself.
There are two ways to figure out what an event provides.
You can just do help and then event.name event.
Currently in const, that has the unfortunate side effect of also printing out a bunch of
like metaclass stuff that you maybe don't care about at the moment.
If you just want the simple succinct definition,
the better thing is just to look at the dunder doc of the event you want.
So in this case, you can see that it is specifying
the types of the two arguments that will be provided.
Yeah, and it's returning none.
So you have this type hint signature that describes what arguments will be provided,
their types, and then what will come out of the event if anything.
Is there any way to get a list of events available?
Yes, there are two ways to get a list of events that are available.
Currently, the tab completion on that events shortcut is a little bit
borked, which we're going to fix in a couple of days.
But if you go to dunderconch.buildins.events and then hit .tab, all of those.
And the other way is if you go to the docs, there's xon.sh slash events.
I think it is .html.
But on the website, there's a list of all of them, what they do when they fire.
Yeah.
Also, I should say, if you want to register a handler for an event,
but you don't actually, I mean, it's
going to provide those arguments no matter what you do.
Like, that's what the event does to the handler.
You can choose not to use them, but you do need to say, like, you need to give it
like a star, star, quarks or something to at least capture them,
or it will throw an error because you're
going to pass arguments to a function that doesn't know how to accept them.
So it's just, you know, you can make these future, basically, future proof,
just so long as you always pass it star, star, quarks.
And then you don't have to worry about something firing or, like,
passing unknown arguments to your handler.
So events get fired when we tell them to fire or when you tell them to fire
is effectively the short answer to how these things get set off.
But so we'll walk through an example of setting up our own event
and telling it to fire just to give you a notion of what this all looks like
and how you would put all of this together.
OK, so first, we need to create an event.
And the way you create an event is actually by writing a doc string for it.
It's sort of like the ultimate self-documenting code.
Like, it's impossible to create an event in Contra without it having documentation
because that's the only way to create it.
It's kind of amazing.
So we're going to create an event that just raises an alarm if it's called,
it's unhappy.
So the way you do this is you say event.doc.
And then the first argument you give it is the title, is the name of the event,
which in this case is never run this.
And then you give it a doc string, which should be the signature.
In this case, this event takes no arguments and returns none.
So it's just a simpler thing.
So it would just be events, never run this, parens, arrow none.
And then on the next line, you can kind of provide a description of what
you're expecting it to do.
That's more for other users or other people.
So if you were writing a plugin and you wanted to have some events,
you would kind of try to put your explanations in here
so people understand how they can use the events you provided to full effect.
OK.
OK.
So now what we're going to do is the way you would use this event is you would,
it's an event that you basically want to never be fired.
So you would put it in a function that for some reason you have,
like really, should never be run.
But you want to recognize that it may exist.
And so you put this event in there to kind of alert you that this thing is
happening.
So if you wrote a function that deleted everything on your computer,
I don't know why, but let's just say you did.
Then what you would do in, let's say, the first line of that function
or somewhere along is that you would just say events.
And then never run this, which we've defined in that previous doc string
thing, and then dot fire.
And then what happens is that whenever that function is called
and it gets to that line, the event management system will basically
fire that event.
So we can go ahead, actually, and run, delete my computer.
And nothing happens.
So in fact, actually, something does happen.
The event fired, but we have nothing listening to the event.
So you don't get anything out of it.
So then the final step is to set up a handler to add it.
So we create the event.
We tell the event to fire, and then we
have something that listens for the event firing that then reacts to it.
So these three separate components.
And given the fact that this is an event that's
supposed to fire when somebody has done something horrible to you,
you can make it a suitably chastening message.
And as always, you have access to the full contract spectrum here.
So in this case, the who am I is a nice thing you can figure out
exactly which user is responsible for doing this horrible thing to you.
That's a good table.
Yeah, perfect.
So then if you run delete my computer again, then the event fires.
And now you know that it was Scopats that deleted your computer.
I'm sorry.
Can't take him anywhere.
OK.
So are there any initial questions?
Otherwise, there's some exercise here
that should help kind of like cement the general pattern in place.
But we're happy to take questions first.
OK, great.
So these sort of build on one another.
So I'll like reveal them as we go.
But the first is just to create a handler for the event that
is called onEnvarchange.
This is a built-in event.
You don't need to create the event.
You just want a handler for the event.
And you want to have it print out the old value and then the new value.
And of course, the name of the variable is just changed.
So you should probably check on the under doc of the event
to figure out what those variables are called.
Otherwise, it's going to be hard to refer to them.
And Anthony and I can sort of wander and help.
So as Gil showed up here, if you just
write a simple if condition to check if the name, which comes in
as a string, like the doc string says, is either PWD or old PWD.
And then only print if it's not.
We can check to make sure that it works normally
for most environment variables.
But if we change directory, it no longer gets called.
So.
And then I think we're running a little low on time.
So maybe we'll skip this particular exercise.
But you can go.
Feel free to do it at home and email us, too.
Do you want to just show it?
OK.
So one of the really handy ones for doing some control flow,
we don't take time to actually do it right now.
But there's onPost command, which has a bunch of those items
that you get in the command pipeline object,
including timestamps, the name of the command that
was run, and other stuff.
So in this case, this is all it takes basically
to set up a power line style, like the timestamps
of the previous command, and just throw it
onto your write prompt over on the side.
It's really just this three line event handler thing
that you can use.
And then you kind of set up this interactive thing to track.
You can also get return codes and start
coloring things differently.
I mean, it gets really easy to build stuff up there
to get sort of the responsive prompt that you want.
That's all I wanted to say.
OK.
So now we're going to talk about macros.
So macros are syntax that replace a small amount of code
with one of a few things.
So either another expression or a syntax tree or just a string
rather than being evaluated normally.
So basically what happens in conch
is that the parser gets paused.
And then we skip the normal parsing.
We gather up whatever macro inputs are going to be handed off.
We'll get to what those are in a moment.
We evaluate the macro with however we're told to evaluate it.
And then we resume normal parsing and execution.
So conch's macro system is more like rusts than other macro
systems you might be familiar with.
So who knows rust even a little?
So this gets used all the time in Rust.
So if you know that, it'll look familiar.
If not, hopefully it won't be too much of a learning curve
here.
But basically the point of this is that you're already
familiar with macros nominally.
Jupyter magics are just a macroing system effectively.
They pause normal execution and do something else.
So like in Rust, the conch macros
use the special exclamation point syntax.
And there are three types of macros that we have.
So one are subprocess macros, which we'll go over first.
The next are function macros, which we'll follow after.
And then third is context macros.
So we'll see what all of these look like in a moment here.
So let's start with subprocess macros.
So basically if you put an exclamation point anywhere,
a lone exclamation point anywhere in your command pipeline,
anything after that will just be interpreted
as a single string argument to the rest of the command.
So if you say echo exclamation point,
I'm Mr. Meeseeks, for example, then that entire thing
is just a single string after the exclamation point.
It's stripped, but to show some counter examples,
if you just echo xyz, echo doesn't really
care about the white space.
So normally you'd have to pass this in as a string,
which is two characters.
But if you use a macro, you only have to use one.
It's echo exclamation point xyz in that whole thing.
It's equivalent to having put that everything in the string.
OK, now this is sort of a contrived example.
Oh, but before we get into that, it's
important to remember that macros pause all syntax
until you escape the sub-process command.
So environment variables will just
be listed as the string you typed in, not anything else,
because we're not parsing that as an environment lookup
anymore.
So if you want a more extended example,
you can say you're going to have an environment lookup
on both sides, and you'll see the first one is the value,
and the second one is actually just the string
that you typed in.
So this is really useful when you want to pass in a very
large string to a command.
So for example, time it.
Time it's like a classic case for this, right?
So if you do time it and then some Python code,
time it is a built-in alias in console.
You don't need to worry about implementing it.
It's there.
All of that is a Python string that follows,
or a con string that follows.
Or similarly, if you wanted to do some bash code,
normally you'd have to put that bash code in a string
and then execute it.
But with the sub-process macro, you
can just type in the exclamation point, and it's done.
Or you can do this with Python.
Basically, any of the things that you want to pass in a dash C
to, it'll work.
I think what did you?
Yes, friends.
Oh, yeah.
There you go.
OK.
Any questions on the sub-process macros?
They're pretty simple.
That's why we did them first.
OK.
So let's move on to the function macros.
So these get a little more fun.
So macros don't require a special function definition.
They only require a special function call.
They modify how the function is called.
And it's just normal Python callables.
What you do to call something as a macro
is you stick an exclamation point between the name
and the open parentheses.
And macro arguments are split on commas,
like normal functions.
So here's a few simple examples.
So if we had an F function, if we wanted to call it
as a macro with no arguments, we would say F exclamation point
parentheses.
You're used to us that should look pretty familiar.
If you want to call it with a single argument,
you would do sort of the normal Python single argument
methods, or you can call it with multiple arguments
splitting on those top-level commas.
How the function is defined determines what happens,
or specifically how the function annotations,
what the function annotations look like,
determine what actually happens in the macro
when you do a macro call.
And that's matched up with each individual parameter.
So here's an example.
So say you have an identity function
that has its annotation for its x parameter set to string.
That x that comes in when it's a macro call
will always be a string.
Even if what's normally put into that is not a string.
So here's a comparison between the two different versions.
So in the top, we have the identity function.
We call it with a string.
We get a string back.
On the bottom, when we call it with the identity with a string,
but as a macro call, we get the wrapper string effectively,
returned.
Similarly, for ints, in a normal Python call,
you'd get an int back.
In the identity, you always get, or in the macro call,
you always get the string, and same thing
with the others.
You get the string form of the argument
rather than the actual object itself.
Each argument is stripped.
This is basically done for consistency
so that things like 42 and 42 don't end up being different.
They're not really meant to be different.
So in this string one, they end up being the same.
Feel free to raise any questions or deep concerns
or anything as we're going.
Yeah, Tom?
Why?
Why?
Well, we're getting to why in context macros,
which we'll see some cool things.
But it's the same underlying infrastructure for functions.
OK.
Yeah, wow.
So consistent.
OK, so here's some funny examples
that are really pretty bad.
So if you macro call import OS, obviously this
is not valid Python syntax, but in any way, shape, or form.
But you can get that code back.
You could embed some C++, because I don't know why.
I forget C++.
Wow, if only I could forget C++.
You don't have to type that.
No, you don't have to quote that.
It's a way of circumventing that quoting, yeah,
in this particular example.
But there's more things that you can do than just strings.
We just showed the strings here.
So if you said you wanted this to be an AST,
there's kind of flag codes for this
if you want to annotate it in different ways.
You can get back the AST of what you put in,
if it's Python or Contra code.
So you can get that tree object back out,
which is pretty nice and useful if you're
doing a lot of tree rewriting.
You can get a code object out if you
want to put in exec or a val or something,
or if you put in the C flag, or sorry, if you put in compile.
There's six of these, so here are the first three.
The others are a val, so that would just
eval the argument as normal, so that means that you basically
could only put in Python expressions.
If you wanted to put in exec, you could put in basically
anything that you wanted, or you could say T
and get the type back.
So in theory, this could be extended
if there are other things out there
that people would want to see done.
But this is what's available right now.
Any questions on this stuff?
OK.
So here's an example of some annotations, a simple function.
So we're annotating with the first argument.
By default, since it's got no annotation,
we'll just come back as a string.
The second one will be an AST object,
and the third one will be a code object,
because we're passing in compile, the built-in compile
function.
If we do a macro call, let's see.
A lot of pensive people.
Head's exploding.
OK.
Do you have an example on a USAM macro?
Of this one?
Yeah, so just call it with anything, or any Python
exclamation point.
I don't know, like 3 plus 5, I guess.
Oh, yeah.
I think you have to do a new line after the 3 plus 5, right?
Or after the OS?
I think it's after the OS, because you did a statement.
No, no, no.
Like a literal new line.
I'll do it.
It's too, uh, no, I guess not.
String, interesting.
I thought there was an example here.
All right, well, this is not working right now.
I don't know what the, this should know for their code.
OK, well, it's not, it's failing to compile one of these things.
So let's maybe just do this.
Nope.
Yeah, I don't know what the problem is.
I'm sorry.
We'll have to figure it out afterwards.
So we have a parser error.
All right.
OK, sorry about that.
So the next, the last bit of macros
that we'll get to are context macros.
So these use the exclamation point
right after the with word.
So you can use with exclamation point.
And then everything after the colon
will be captured like it was in a normal with statement.
So this provides both named blocks and anonymous blocks.
So if you say, this isn't going to work because there's no x
to enter, but you say with x equals 10, print y,
this would come back as a string.
And what this can be thought of really is doing the follow.
So you can think of this as saying,
whatever your context is, x dot macro block
equals the string of the code in the block, d indented,
and then assigning the locals and globals
to attributes of that as well, and then
passing for the actual block.
So it's a bit of code rewriting.
Macro block is d indented.
And these attributes are set before the enter method is called.
But they're not cleaned up on the exit method,
so you can do that if you want to.
But they stay around and live if you need them.
Like with functions, by default, the contents of the block
are returned as a string.
However, they don't need to be.
They could be any of the other special annotations
that we saw before.
And that just lives as this conch block attribute
on the context manager.
So that's how it knows what to look up,
what type to convert it to.
So here's an example.
And this gets to the use case a bit.
So we can write a simple XML block.
So if we say, we're just going to be pretty explicit.
You don't need the comments, obviously.
So we say, it's going to come back as a string.
We write an enter method that takes the contents of the block
as a string and will parse them into an element tree,
an XML element tree, and return that as the object
in the context manager.
Then when it exits, we're just going
to clean up those things, the things that we had before.
Yeah, I think you need this star or whatever.
Macro locals?
Yeah.
OK.
And then you can use this.
Oh, it's cutting it off a bit.
But by saying, with exclamation point, XML block,
a new object as tree, colon, and then everything,
you can just do a short one.
So just do like, you could even just do, yeah, you,
and then just close out the note, I think.
And now, if we can inspect the tree object,
tree is an instance of, so I think, what is it?
If you do tree.tag, that gets the note.
So it parses that XML.
So this lets you write documents and other languages
right in Conch, and then do whatever you want with them,
which is somewhat insane, but actually kind of useful
occasionally.
And you saw writing that context macro object.
That class was actually pretty simple.
It didn't take a lot of lines of code to do that.
So yeah, that's kind of the scenario there.
And hopefully, that answers, at least partially,
the use case question.
OK.
So we have a few exercises.
The first is to use a sub-process macro.
So just run time it on the string and formatting a string.
The second is to call the import module as a macro,
so you don't have to use quotes.
And the third is to run write a JSON block context manager.
Then we need to get into our exam.
And then we need to get into our longer thing.
Any questions on any of these?
Or if there are questions?
Format was 42.
And you see what this really prevents once time it completes
is you having to run it with an extra set of quotes,
because time it expects just a single argument that takes.
So this is fundamentally the same,
but you don't have to type that extra set of quotes.
You want to move on to the next?
And then, yeah, for the standard library import lib,
this is just showing you can actually just use existing
functions, but call them using the macro syntax.
And so in this case, you get back the import lib dot import
module, so if we do sys, right?
Because the first argument is a string, you can just get that.
So it'll turn whatever you type that into a string.
OK.
And then the third one is this JSON block.
So this should be very familiar to the XML one, where now we
just have, or now we have JSON.
We don't need the macro block part, because that's optional.
But we, oops, on enter, we'll assume
that the code that comes in is valid JSON.
So we'll return JSON dot loads of self dot macro block.
And then on exit, we'll do the same delete portion, just to
clean up after ourselves as well.
And so a use case for this is just with JSON block as what's
called x, and we can write just some random JSON.
And now x is a dictionary that was parsed from that JSON.
Pretty silly example, because JSON and Python are so similar
here, but it's one way to do things.
Any questions on these exercises?
Yeah.
So where does this JSON block object end up in this case?
What do you mean?
So x ended up as the return value of enter.
Yes.
So where did the JSON block instance?
It's gone.
OK.
So the cleanup is a little, I guess you keep showing the
cleanup, implying these things are leaking.
Well, so the macro block and macro globals and macro
locals, yeah.
So this would leak in the case where you instead returned
self from the enter method.
Right?
But is that like conscious of keeping a cache?
No, no, it's not keeping a cache.
It would only leak if you, so the place where it would leak
potentially where you wouldn't want it to necessarily is like
if you wanted to have the same instance of JSON block be
re-entrant, that's what this makes us.
So you could have one instance of JSON block and then just
re-enter it every time and always get the tree back.
Or if you returned self and were doing something else with
it later.
Right?
So, yeah.
That's where the references get added.
Does that make sense?
Sort of?
Close enough.
Yeah.
I guess the thing is if you returned, so if you
said like self dot, maybe you wanted to keep the j object
around so you did like JSON dot or you wanted to keep the
tree, so you do JSON dot loads of self dot macro block.
And then you return self, you might not want to keep the
globals, you might want to keep the macro block itself
around, but you might not want to keep the other locals and
globals here.
And so just using this, so now x is the JSON block and then
x dot tree is the actual version, but you still have
access to the string of what the macro block was.
Yeah.
Are the local and global?
They're the local and global dictionaries, as if you had
called locals and globals the Python built-ins, where the
macro block was called, or the context macro was, was written.
Yeah.
Yeah.
OK.
Yeah.
Any other questions on this?
So you're given the use case of writing a different language.
What are the use cases that typically may use for macros?
Yeah, so the most common use case is really something like
time that, right?
It's really those.
There's a couple of cases where, that we've used these
things, where if you wanted to write some bash and you really
needed it to be bash in a local context, then you would, then
you write like a little bash thing.
There's been some other use cases where we take input or
configuration files in as these macro blocks.
But otherwise, yeah, that's kind of the use cases.
I think that's the most interesting part of it,
is the way that's especially useful.
Sorry, saying?
The second, second example.
Oh, yeah, yeah.
That's just a toy.
That's kind of a toy example to show.
Right, this comes from the standard library.
And the standard library doesn't know anything about
conscious macro system.
So it didn't annotate these functions in any particular
way.
And this is just showing that you can use the macros on
those functions, if those functions happen to
take string arguments.
It's demonstrating, yeah.
But the function macro stuff just ended up having to, it
kind of had to be there for the context macro stuff.
That infrastructure all had to be the same.
So it's there and available in the language if you want it.
But I wouldn't say there's a killer feature for it, unless
you're coming from Rust, or you really like doing a lot of
AST syntax, AST tree rewriting and stuff.
In which case, this makes it easy for you to provide those
rewriters or pattern matchers inside of Conch.
But that intersection is basically me, so.
Yeah.
OK.
Cool.
Good question.
Great question, though.
Let's, we should maybe skip this.
Well, except we don't know if we can.
Yeah.
Well, I can try to upload this stuff real quick.
So this is going to be interesting as we discover if
this is even possible anymore.
But there is an example here, which is that we were working
in a lab that had a bunch of MRIs of mouse lemurs.
That's a mouse lemur.
So we had all these MRI data, but it was set up on a web
server by a postdoc who disappeared last week.
And we have some other bad news, which is that he used
bash to handle all the data collection.
He didn't know how to make sure that different data sets were
saved to separate directories.
So he just added a random four digit number to the end of
all of these NII MRI image data files.
And he also neglected to do this with the JSON metadata
that was included with it.
So that's all been overwritten and lost.
And then he ran, removed with an overly permissive glob,
deleted all of them.
And the files are kind of big in the postdoc's web
servers at his house.
We don't want to have to download all of them.
That being said, the web server at the house, which is on
my laptop, is completely inaccessible to everyone on
this network, it turns out, which makes
this a little trickier.
The data is now on GitHub in this repo called MRI data,
sorry.
And this may not be possible, so we'll find out.
It's going to be a learning adventure for all of us.
We do know a couple of things about the data.
So this is sort of our exploratory thing.
They all do follow this naming convention.
So you just have sub-2-digit number underscore
four-digit number dot nii.
The files are large, but the first 348 bytes of each file
is a header.
So you can nominally just pull down the header.
We're pretty sure there are 19 mouse lemur scans, and the
circle spine study going on in the lab next door, which is
mixed in with all of this data, only has six subjects.
And nominally, this is how you would use curl to only pull
down the first 348 bytes of a file if there were a
functioning web server available.
We're going to discover together if you can do this
from the raw link on a GitHub repo, but we're not sure.
So having said that, if you would like to even try this,
and we welcome your support and efforts, you can install
nibabble, n-i-b-a-b-e-l, on ContaForge, which is a nice
package for loading in this MRI data.
It's on PIP, right, too?
I don't know.
Oh, you don't know.
OK.
I don't even look on PIP anymore.
Yeah.
Um, and then we are all going to try together to see if we
can just download the headers of each of these files, sort of
determine which of them are the ones we want, so we don't
just download everything, which is never usually the right
answer to these sorts of questions.
Maybe we should see if we can curl one of them right now.
Yeah, let's try it.
OK.
Um, all right.
So it's curl dash r, and then what's the GitHub URL?
Well, the GitHub API should be, this feels way too much like
real science right now.
So it would be github.com, g4-sci, MRI data, sorry, blob,
master, raw equals true.
That didn't work.
No, I thought there was like a real, not like a raw user
data kind of thing.
Or does that live at?
I think usually it's there unless the file is too big.
Oh, OK.
This is why you don't store big data on github.
This is why it's a really bad pattern.
Let's try this one.
Received.
No such key.
Or maybe that one's not up yet.
It's another one of these file names.
It's definitely up.
Woohoo, that worked.
OK, time to rewrite the slides.
Which you'll be able to reload and copy from.
What's that digital ocean droplet?
I'll put it in this chat.
Sorry about this overall.
Sorry about this overall.
You're getting this put screen by you're in a Google meeting
sharing your screen.
Yes.
Yeah, no, the network's all kinds of fun today.
Google.
Oh, I hate Google.
Don't help me, Google.
I don't want your help.
Your help is terrible and poison.
It's not help, it's spying.
Stop spying on everything we do.
They're watching us right now.
That's true.
But we asked them to this time.
Can you curdle down a file list from there?
Does that work?
No.
Well, I don't know.
What was the command for doing this?
I don't know.
I think it should just be this.
OK, this will work.
Yeah, that's it.
The information's in there.
OK, so you've got an XML block.
So you've got an XML block.
All right.
We are happy to answer questions along the way.
This should actually work, though, which is kind of amazing.
So the post doc is better than we thought it was.
And it's uploaded the files to this digital ocean droplet
that I've just added to this slide.
If you reload the slide deck, you should be able to do that.
Oh, I haven't pushed it up yet.
Oh, OK.
I'm sorry.
I can't push anything right now because I haven't set up the SSH thing
and it wasn't working.
I'm sorry.
But if you curl that URL, you will get this looking kind of blob,
which does have all of the file names in it.
So you can see there's one.
I lost it there.
Sub 187785.nii.
And you should be able to pull out from this a list of all of the names
that match that pattern.
And then you can pull down only the first 348 bytes of each of them,
load them into NI Babel, and then inspect sort of the dimensions
of the thing to figure out which are sort of the correct images.
Can you get back to that link?
Yes, I can.
No.
Good question.
If I could install what would be reflected in a very conscious environment?
You probably need to, well, actually.
Yeah, it should just work.
Yeah.
Yeah, it works.
I do that all the time.
I can't install something and then import it immediately.
Yeah, and if you're having a problem, or if you're running into issues,
come just raise your hand and let us know.
And thanks for dealing with our debugging live here.
So for a quick update on our progress here,
is there anyone doing on this, if at all?
Sorry to hear that.
So one thing you can do for some of this is you first want to get the raw kind of page.
So that would be you could just curl down that base URL there.
I actually got encoded this as a, yeah.
Can you make the font bigger?
I sure can.
You want to show the other command?
Oh, yeah, base URL.
Yeah.
So then if you have this really long, painful string like this,
but you know that the files look like somewhere there,
you can try to use XML, but XML is horrible.
So you could also use a regular expression to scrape over that
and pull out any that matches a certain pattern.
So then that's sort of the list of files that match that.
So now you might want to try just like downloading one of those,
which would be to grab the first 348 bytes,
save it to the same output file or just put together the base URL
and then the path of a single file just to kind of test it out.
Seems to work.
You import Nebabel.
You can load that file.
And then if you explore some of the different options here,
you might see this header thing.
Yeah, back there.
Yeah, so the question is about why shouldn't you use a path string here?
Well, yeah, so the answer is basically that it's a URL.
So it's not really a path in a normal way.
And the second is that you're just passing it back down to a sub-process command,
and so it's going to get turned back into a string anyways.
So you don't really need the path object.
Yeah, having said that, as you go along on this,
you might maybe curl it down using just a string
because you want to pass that to curl.
But then in terms of loading the file after you have it there,
you could first make it a pathlib path, load it from that,
and then depending on the results of how you're inspecting it,
then use pathlib of that file to move it or change it or mark it or delete it.
So you can work that into the process.
Probably just.
Yeah, I think so.
Okay.
I'm going to keep working on this at lunch,
so people want to, on this contrived example that we created,
but you want things to work.
Thank you, everyone, for coming.
I know it's like a lot of information just to dump into people's heads,
but we appreciate you guys kind of toughen it out with us.
We also, there's a bunch of stuff we haven't covered.
There's even some more new syntax probably that I've forgotten about.
But we're here all week and we're happy to help you answer questions.
If you have a certain thing you like to do and you just want it to,
you think it could work a little better,
you want to try and see what it would look like on Conch,
please stop us anytime.
We have stickers on our badges and you probably would recognize at this point.
We also have stickers up front,
so feel free to take as many as you want of those.
And yeah, thanks for coming and trying out Conch.
And hopefully, you know, it improves your life in some meaningful way.
So, and then, yeah, we'll be around and open bug reports,
find us on Gitter, open issues, contribute.
We're a friendly community, so thank you so much, everybody.
Thank you.
