MeTTa Formalization with Metagraphs
Open sidebar
ChatGPT
4
You
Ref l ective Metagraph Rewriting 
as a Foundation 
for an AGI ���Language of Thought��� 
��� 
Toward a Formalization of OpenCog Hyperon���s MeTTa Language 
in Terms of Algebraic Metagraph Rewriting 
Ben Goertzel 
SingularityNET Foundation 
December 16, 2021 
Abstract 
MeTTa (Meta Type Talk) is a novel programming language cre- 
ated for use in the OpenCog Hyperon AGI system. It is designed as a 
meta-language with very basic and general facilities for handling sym- 
bols, groundings, variables, types, substitutions and pattern matching. 
Primitives exist for creating new type systems and associated DSLs, 
the intention being that most MeTTa programming takes place within 
such DSLs. 
Informally, MeTTa is Hyperon���s lowest-level ���language of thought��� 
��� the meta-language in which algorithms for learning more particular 
knowledge representations, will operate, and in which these algorithms 
themselves may be represented. Tractable representation of a variety 
of knowledge and cognitive process types in this sort of formalism has 
been explored in a long history of publications and software systems. 
Here we explain how one might go about formalizing the MeTTa 
language as a system of metagraph rewrite rules, an approach that 
i ts in naturally to the Hyperon framework given that the latter���s core 
component is a distributed metagraph knowledge store (the Atom- 
space). The metagraph rewrite rules constituting MeTTa programs 
1 
can also be represented as metagraphs, giving a natural model for 
MeTTa ref l ection and self-modifying code. 
Considering MeTTa programs that compute equivalences between 
execution traces of other MeTTa programs allows us to model spaces 
of MeTTa execution traces using Homotopy Type Theory. Consider- 
ing the limit of MeTTa programs mapping between execution traces 
of MeTTa programs that map between execution traces of MeTTa 
programs that ..., we i nd that a given MeTTa codebase is ef f ectively 
modeled as an ��� ��� groupoid, and the space of all MeTTa codebases 
as an (���,1)���topos. This topos is basically the same as the so-called 
���Ruliad��� previously derived from rewrite rules on hypergraphs, in a 
discrete physics context. 
The formalization of MeTTA as metagraph rewrite rules may also 
provide a useful framework for structuring the implementation of ef i- 
cient methods for pattern matching and equality inference within the 
MeTTa interpreter.
ChatGPT
ChatGPT
This abstract from Ben Goertzel's paper presents the concept of MeTTa (Meta Type Talk), a programming language developed for use in the OpenCog Hyperon Artificial General Intelligence (AGI) system. MeTTa is designed as a meta-language with fundamental capabilities for handling symbols, groundings, variables, types, substitutions, and pattern matching, focusing on creating new type systems and domain-specific languages (DSLs). It is described as Hyperon's "language of thought," where algorithms for learning and representing knowledge operate.
The paper discusses formalizing MeTTa as a system of metagraph rewrite rules, fitting into Hyperon's architecture, which centers around a distributed metagraph knowledge store called the Atomspace. These metagraph rewrite rules, which constitute MeTTa programs, can also be represented as metagraphs, enabling reflection and self-modifying code in MeTTa.
Furthermore, it explores the idea of using Homotopy Type Theory to model spaces of MeTTa execution traces by considering MeTTa programs that compute equivalences between execution traces of other MeTTa programs. This approach leads to modeling a MeTTa codebase as an ���-groupoid and the space of all MeTTa codebases as an (���,1)-topos. This concept aligns with the "Ruliad" derived from rewrite rules on hypergraphs in discrete physics.
Lastly, the formalization of MeTTa as metagraph rewrite rules might also aid in structuring efficient methods for pattern matching and equality inference within the MeTTa interpreter, enhancing its computational efficiency and effectiveness in AGI systems.
You
1Introduction 
OpenCog is an integrative software framework aimed to foster the creation 
of systems with AGI at the human level and beyond [GPG13a] [GPG13b] 
[GPea21].The core design feature is a distributed metagraph called the 
Atomspace, consisting of nodes and (hyper)links labeled with various types 
and other information.Multiple AI algorithms originating from dif f erent 
AI paradigms (logical reasoning, probabilistic programming, attractor neu- 
ral networks, evolutionary learning) are then implemented leveraging Atom- 
space for internal representation as well as cross-algorithm communication. 
An associated cognitive systems theory explains how this approach can en- 
compass all the central aspects of human intelligence, with a focus on the 
���cognitive synergy��� among the dif f erent algorithms and dif f erent modes of 
memory organization involved. 
Concurrently with leveraging the existing ���OpenCog Classic��� codebase to 
carry out various practical functions, a portion of the OpenCog community 
is now engaged in developing a new version of the system called OpenCog 
Hyperon [GPea21]. The motives underlying Hyperon are multiple, including 
desires for greater scalability and usability, and to leverage tools and methods 
from branches of math such as dependent type theory and intuitionistic and 
paraconsistent logic at deeper levels in the system design. 
A key ingredient of the Hyperon design is the MeTTa (Meta Type Talk) 
programming language, which serves as the key structural principle of the 
Hyperon version of the Atomspace, as a language for internal use by Hyperon 
algorithms, and (with appropriate surface syntax) as an end-user language 
for developers to use in coding algorithms and applications for Hyperon.
ChatGPT
ChatGPT
The introduction to this document provides an overview of OpenCog, a framework aimed at developing systems with Artificial General Intelligence (AGI) at or beyond human level. Central to OpenCog is the Atomspace, a distributed metagraph consisting of nodes and hyperlinks labeled with various types and other information. This structure enables the integration of multiple AI algorithms from different paradigms, such as logical reasoning, probabilistic programming, attractor neural networks, and evolutionary learning. These algorithms use the Atomspace for both internal representation and inter-algorithm communication.
The theory behind OpenCog emphasizes "cognitive synergy," highlighting the interaction and cooperation among different algorithms and memory organization modes, which is believed to be critical in replicating aspects of human intelligence.
Alongside the existing "OpenCog Classic" codebase, there is ongoing development of a new version called OpenCog Hyperon. This new iteration aims to address scalability and usability enhancements and incorporates advanced mathematical tools like dependent type theory and intuitionistic and paraconsistent logic.
A critical component of Hyperon is the MeTTa (Meta Type Talk) programming language. MeTTa underpins the Hyperon version of the Atomspace and is used internally by Hyperon algorithms. It also serves as a language for developers to code algorithms and applications specifically for Hyperon, with appropriate surface syntax adjustments. This positions MeTTa as a versatile tool within the OpenCog framework, facilitating both the development and implementation of AGI systems.
You
Informally, MeTTa is Hyperon���s lowest-level ���language of thought��� ��� the 
meta-language in which algorithms for learning more particular knowledge 
representations, will operate, and in which these algorithms themselves may 
be represented. 
Why we consider MeTTa a viable ���language of thought��� for human-like 
(and some forms of non-human-like) AGI will not be richly explicated here; 
however, tractable representation of a variety of knowledge and cognitive 
process types in various precursors to the MeTTa formalism (e.g. OpenCog 
Classic���s Atomese) has been explored in a long history of publications and 
software systems. The recent papers [Goe21b] [Goe21c] [Goe20] building on 
prior work such as [GPG13a] [GPG13b] tell this part of the story. The goal 
here is to add a necessary piece to this overall story via going beyond ���MeTTa 
as a language for manipulating knowledge metagraphs��� to ���MeTTa as knowl- 
edge represented in knowledge metagraphs, enabling knowledge metagraphs 
to l exibly self-transform in a cognitively useful and meaningful way.��� This 
latter perspective is by no means conceptually surprising in the context of 
the overall OpenCog and Hyperon programmes, but nevertheless requires its 
own detailed explication. 
The initial MeTTa specif i cation [Pot21] is semi-formalized and articulates 
the language mainly by way of examples accompanied with textual descrip- 
tions. Implementation of a prototype MeTTa interpreter is underway. The 
end-user syntax for MeTTa is not yet decided; the prototype and early doc- 
umentation uses a vaguely LISP-like syntax but this is fairly likely not to 
survive, especially as there is currently considerable discussion of design di- 
rections such as integration of MeTTa into Python and Julia as a framework, 
and use of a graphical interactive expression editor. 
As part of the development and analysis of MeTTa and the overall Hy- 
peron system, it will be useful to have a more formal presentation of the 
MeTTa language. This article does not provide such a formal presentation 
in detail, but it outlines what we believe is the most natural approach to 
creating one, via partially l eshing out a framework presenting MeTTa as 
a system of metagraph rewrite rules.We will describe in fair depth one 
route to creating such a formalization, and then brief l y explore some of the 
follow-on consequences expected to follow from this formalization, including 
connections to topos theory and strategies for ef i cient implementation of core aspects of a MeTTa interpreter.
ChatGPT
ChatGPT
This section discusses MeTTa, the programming language used in OpenCog Hyperon, and its role as a "language of thought" for AGI (Artificial General Intelligence). MeTTa serves as a meta-language for algorithms that learn and represent knowledge. The text explains that while the reasons for considering MeTTa a viable "language of thought" for both human-like and some non-human-like AGI are not deeply elaborated here, the feasibility of representing various types of knowledge and cognitive processes has been explored in previous works and iterations of OpenCog, such as OpenCog Classic���s Atomese.
The goal of the current discussion is to extend the understanding of MeTTa beyond merely a language for manipulating knowledge metagraphs. It aims to view MeTTa as knowledge represented in these metagraphs, allowing for the self-transformation of these metagraphs in ways that are cognitively useful and meaningful. This perspective is consistent with the overall goals of the OpenCog and Hyperon projects, but it requires detailed explanation.
The initial specification of MeTTa is semi-formalized, mainly exemplified through examples and textual descriptions. There is an ongoing development of a prototype MeTTa interpreter, and the final syntax for end-users has not been decided yet. The current prototype uses a LISP-like syntax, but there is discussion about potential changes, including integrating MeTTa into programming languages like Python and Julia and possibly using a graphical interactive expression editor.
Finally, the text highlights the need for a more formal presentation of the MeTTa language to aid in the development and analysis of MeTTa and the Hyperon system. This article proposes that the most natural approach to such formalization is to present MeTTa as a system of metagraph rewrite rules. It plans to explore this formalization and its consequences, including connections to topos theory and strategies for efficient implementation of key aspects of a MeTTa interpreter.
You
Conceptually the MeTTa language as described in [Pot21] could be formu- 
lated and implemented in contexts other than metagraph rewriting. However, 
the actual initial practical intention is to implement MeTTa in the context 
of the Hyperon design, which has to do with storing MeTTa scripts in the 
Hyperon Atomspace (metagraph), and using these scripts to act on said 
Atomspace etc. So for near and medium term purposes, a formalization in 
terms of metagraph rewrite rules seems like a broad enough scope. 
We reiterate that the aim of this sort of formalization is pragmatic as 
well as theoretical. To implement MeTTa as a programming language in 
practice, one has to some mapping of MeTTa into underlying operations to 
be carried out in the computer; and mediating this mapping via mapping 
MeTTa into a relatively simple syntactic formalism like metagraph rewrite 
rules has promise to make the process more orderly and comprehensible.
ChatGPT
ChatGPT
In this section, the conceptual basis and practical implementation of the MeTTa language within the Hyperon framework are discussed. While MeTTa, as conceptualized in [Pot21], could potentially be formulated and implemented in various contexts beyond metagraph rewriting, the immediate practical goal is to integrate it within the Hyperon design. This integration involves storing MeTTa scripts in the Hyperon Atomspace, a metagraph, and utilizing these scripts to interact with and modify the Atomspace.
The decision to formalize and implement MeTTa in terms of metagraph rewrite rules is driven by the immediate needs and design choices of the Hyperon framework. This approach is deemed sufficiently broad for the near and medium-term objectives of the project.
Moreover, the pursuit of this formalization is both pragmatic and theoretical. Practically, implementing MeTTa as a functional programming language requires mapping MeTTa constructs into underlying computer operations. Theoretically, translating MeTTa into a syntactically simpler formalism like metagraph rewrite rules is expected to streamline the implementation process, making it more orderly and comprehensible. This translation aims to facilitate the implementation process by providing a clear and structured approach to how MeTTa interacts with and manipulates the underlying structures in Hyperon's Atomspace.
You
2MeTTa Language Overview 
This section gives a brief overview of some key aspects of the MeTTA lan- 
guage and its core library; for a fuller treatment see [Pot21]. 
The textual MeTTa syntax used here, drawn from the MeTTa spec, is 
merely preliminary and illustrative, and will potentially be changed radically 
before the language hits any users. 
2.1MeTTa Vocabulary 
MeTTA symbols come in three forms: grounded symbols, constant ungrounded 
symbols, and variables 
Each grounded symbol is associated with some software object which is 
able to identify if a given digital entity i ts the ���grounding criterion��� of that 
symbol. Some grounded symbols are provided in a core library, e.g. numbers 
and strings; others may be added by the developer. 
A grounded symbol F may be a grounded function symbol, meaning that 
evaluating (F,A) according to F���s grounding involves feeding A into the 
code providing this grounding. The code grounding F may either ask for the 
value obtained after feeding A to the MeTTa interpreter, or it may ���quote��� 
A and ask for A as a literal expression (an object of ���meta-language type 
Expression���). 
Expressions are formed by combining symbols, using the concatenation 
operator that lets us group symbols aand b into the list (ab). Concatena- 
tion can be recursively nested into constructs like ((a,b),c), which makes 
5 
expressions into familiar-looking trees of symbols. 
The use of MeTTa in practice is centered on a few key grounded symbols 
provided in the core library: 
��� The : type-assignment operator and Type symbol for specifying types 
��� The ��� > arrow operator for specifying type restrictions 
��� The = ���equality��� operator for specifying expression-evaluation rela- 
tionships 
Atomspaces are sets of expressions. The default way of storing Atom- 
spaces is as metagraphs (which involves deduplication of repeated sub-expressions 
among multiple expressions in the same Atomspace). An alternative would 
be to store a set of expressions as a forest of dags, which then requires some 
other way of accounting for duplicated sub-dags.
ChatGPT
ChatGPT
In this section, the MeTTa language and its core library are briefly overviewed, with more detailed information available in [Pot21]. The textual syntax used for MeTTa in this context is preliminary and may undergo significant changes before its final user version.
2.1 MeTTa Vocabulary
Forms of MeTTa Symbols:
Grounded Symbols:
Each grounded symbol is linked to a software object that can determine if a digital entity meets the symbol's grounding criterion. The core library includes basic grounded symbols like numbers and strings, and developers can add more.
Constant Ungrounded Symbols:
These symbols are not explicitly discussed in this extract but are another form of MeTTa symbols.
Variables:
The third form of symbols in MeTTa, likely used for more dynamic or variable elements in the language.
Grounded Function Symbols:
These are a type of grounded symbol where evaluating an expression like (F,A) involves feeding A into the code that provides grounding for F.
This code can either interpret A directly or quote A, treating it as a literal expression.
Expressions in MeTTa:
MeTTa constructs expressions by concatenating symbols, allowing for combinations like (ab) or nested constructs like ((a,b),c).
These expressions form tree-like structures of symbols.
Key Grounded Symbols in Core Library:
Type-Assignment Operator (:):
For specifying types.
Arrow Operator (->):
For indicating type restrictions.
Equality Operator (=):
For defining expression-evaluation relationships.
Storage of Atomspaces:
The default method is storing Atomspaces as metagraphs, which includes deduplication of repeated sub-expressions.
An alternative method is storing them as a forest of directed acyclic graphs (DAGs), requiring a different approach for handling duplicated sub-DAGs.
This overview emphasizes the foundational elements of MeTTa, highlighting its flexible structure for expression and symbol manipulation, which is central to its functioning within the Hyperon framework.
You
2.2Types 
A MeTTa Type is basically ���a symbol whose associated constraints, as re- 
gards the usage of symbols and expressions that belong to it, get proactively 
checked by the MeTTA interpreter in the context of evaluation.��� If a symbol 
is not a Type, then checking any constraints regarding its usage has to be 
done via explicitly invoked and scheduled inference. If a symbol is a Type, 
then checking of its constraints is done automatically along with the evalua- 
tion of expressions involving the symbol. This is a ���control��� issue more than 
an ���underlying logic��� issue. 
Saying e.g. 
( : Human Type) 
uses the keyword Type to specify that Human should be interpreted as a 
MeTTa type. Saying e.g. 
(: Bob Human) 
then specif i es that the symbol Bob is of type Human. Saying 
(: a (-> B A)) 
specif i es that if b has type B then (ab) has type A (or if b is undef i ned in 
type then (a,b) is undef i ned in type). 6 
2.3Further Enrichments 
Other enrichments aside from types as typically construed may be treated 
similarly.An example would be vector embeddings.A user could def i ne 
an enrichment of type ���EmbeddingVector��� and associate it with symbols as 
follows: 
(:EmbeddingVector Enrichment) 
(: KPCAVector EmbeddingVector) 
(: BobV KPCAVector) 
(Association (Bob BobV)) 
There will certainly be implementation subtleties associated with such en- 
richments ��� e.g. properly handling the changes to the grounding of ���match��� 
needed to make matching properly handle additional enrichments like this 
(because unlike most symbol groundings, grounding of ���match��� is core to 
the operation of the MeTTa interpreter).
ChatGPT
ChatGPT
This section delves into the concept of types in the MeTTa language and introduces the idea of enrichments, which extend the language's functionality.
2.2 Types
Definition and Function:
A MeTTa Type is defined as a symbol with associated constraints regarding the use of symbols and expressions that belong to it.
These constraints are proactively checked by the MeTTa interpreter during expression evaluation.
If a symbol is not a Type, constraints on its use must be checked through explicitly invoked inference processes.
If a symbol is a Type, constraint checking is automatically integrated into the evaluation of expressions involving that symbol.
This distinction is more about control flow within the interpreter rather than the underlying logic of the language.
Examples of Type Usage:
Declaring a Type:
( : Human Type)
makes 'Human' a MeTTa type.
Specifying a Symbol's Type:
(: Bob Human)
declares 'Bob' as of type 'Human'.
Type Relationships:
(: a (-> B A))
indicates that if 'b' is of type 'B', then the expression '(ab)' has type 'A'.
2.3 Further Enrichments
Beyond Basic Types:
MeTTa allows for enrichments beyond conventional types, like vector embeddings.
Users can define a type like "EmbeddingVector" and associate it with symbols.
Example of Enrichment:
Defining an Enrichment:
(:EmbeddingVector Enrichment)
Specifying an Enrichment Type:
(: KPCAVector EmbeddingVector)
Associating a Symbol with an Enrichment:
(: BobV KPCAVector)
and
(Association (Bob BobV))
Implementation Challenges:
Implementing enrichments like vector embeddings may involve subtleties, particularly in how the MeTTa interpreter's grounding of the "match" operation is handled.
Since the grounding of "match" is crucial to the interpreter's operation, adapting it to properly handle additional enrichments presents a unique challenge.
This overview of types and enrichments in MeTTa highlights the language's flexibility and depth. Types and enrichments allow for a proactive and integrated approach to constraint checking and extend the language's capability to handle complex data representations, crucial for advanced AGI functionalities.
You
2.4Pattern Matching 
A ���pattern��� is an expression which is specif i ed for use as a query in the 
context of one or more Atomspaces. 
Matching a pattern P against an Atomspace or other expression-set A 
(match P A) 
returns a set of all the expressions in A that can be made to instantiate P 
by assigning particular values to the variables in P. 
Pattern matching automatically invokes type checking; so if some vari- 
ables in P are associated with types, they will only be assigned matches that 
are compatible with their types. 
When P and some expression E in A both contain variables, the match- 
ing process must try to bind both the variables in P and those in E; but 
precedence is given to binding the variables in P. 
Patterns can be combined via various operators. The role of disjunction 
or conjunction operators is clear. To what extent negation will play a role, 
and in what form (e.g. subject to what form of guarding) is a current research 
topic. 
The matching function 
((transform P T) A) 7 
involves an ���output template��� T that is an expression containing a subset of 
the variables in P. The transform process performs matching of P against A, 
and then returns a version of T with variables assigned to their corresponding 
values from P. So e.g. 
(transform ((has Sam $o) $o) ( ? (has Samballoon ) (has Sam ball))) 
returns the list (balloon ball). 
Intermediate expressions created during the matching or transformation 
process are by default put into an auxiliary Atomspace, separate from the 
Atomspace A being matched against. 
The recursive matching algorithm behind the ���match��� function may in- 
volve various subtleties, depending on the type systems according to which 
���match��� needs to perform checking. E.g. some complex unif i cation problems 
will in many cases appear behind the scenes here. 
���Match��� and ���Transform��� may be considered as grounded symbols, grounded 
by the underlying algorithms. 
Variations of basic matching might be introduced to handle various sorts 
of enrichments, e.g. 
(matchEV P A e) 
for some numerical threshold e, might perform matching using embedding 
vectors, accepting only matches for which the proximity of the query and the 
match in embedding space exceeds e.
ChatGPT
ChatGPT
In this section, the concept of pattern matching in the MeTTa language is explained, emphasizing its importance and functionality within the context of working with Atomspaces.
2.4 Pattern Matching
Definition of a Pattern:
A pattern in MeTTa is an expression specified for querying one or more Atomspaces.
Functionality of Pattern Matching:
Matching a pattern
P
against an Atomspace
A
(
match P A
) returns all expressions in
A
that fit
P
by assigning specific values to the variables in
P
.
Pattern matching automatically includes type checking, ensuring that variable assignments in
P
are compatible with their associated types.
When both
P
and an expression
E
in
A
contain variables, the matching process tries to bind variables in both, prioritizing those in
P
.
Combining Patterns:
Patterns can be combined using operators like disjunction or conjunction.
The role and form of negation in pattern matching are currently research topics.
Transform Function:
The function
((transform P T) A)
involves an output template
T
that includes some variables from
P
.
This process matches
P
against
A
, then returns a version of
T
with variables assigned from
P
.
For example,
(transform ((has Sam $o) $o) ( ? (has Samballoon ) (has Sam ball)))
yields the list
(balloon ball)
.
Storage of Intermediate Expressions:
Expressions created during matching or transformation are typically stored in an auxiliary Atomspace, separate from the primary Atomspace
A
.
Complexities in the Matching Algorithm:
The recursive algorithm behind
match
may involve complexities depending on the type systems and may deal with complex unification problems.
Grounding of 'Match' and 'Transform':
Both 'Match' and 'Transform' functions can be seen as grounded symbols, grounded by their underlying algorithms.
Variations for Handling Enrichments:
Additional matching variations might be introduced for different types of enrichments, like
matchEV P A e
for matching using embedding vectors with a numerical threshold
e
.
This overview of pattern matching in MeTTa reveals a sophisticated system for querying and transforming data within Atomspaces. The integration of type checking and the ability to combine patterns through logical operators demonstrate MeTTa's versatility. The potential for handling complex enrichments, like embedding vectors, further highlights its capabilities for advanced AGI applications.
You
2.5Equalities 
The MeTTA equality operator 
(= A B) 
has the rough semantics ���A can be evaluated as B.��� It is not symmetric. 
E.g. a Boolean random variable may be conf i gured via 
(= bin 0) 
(= bin 1) 
A simple deterministic function might be set up as 
(= (double $x) ($x $x)) 
Equality should be considered as a built-in Type. However, the static type 
checking carried out automatically during type checking does not incorporate 
8 
inference using equalities (including type equalities). (If it did, this would 
basically turn pattern matching into full-on MeTTa interpretation. Instead, 
in the MeTTa design, the equality inference is put into the interpreter loop, 
which invokes static pattern matching.) 
2.6Interpretation 
The MeTTa interpretation process is triggered by providing the interpreter 
with a query, which is either: 
��� A pattern matching request 
��� A request for execution of a grounded symbol (on certain arguments) 
��� A request for evaluation of an expression (including an ungrounded 
symbol) 
Any of these options may recursively trigger additional steps drawn from 
any of the options. 
In the third case, a request to evaluate expression E will be interpreted 
as an equality query of the form 
(= E $t) 
(whose interpretation may then involve multiple recursive steps). 
For the interpretation process to ef f ectively evaluate the truth of expres- 
sions, the additional equality 
( = (: $t Type) (transform (: $w $t) True)) 
is needed to instantiate the mapping from inhabited types to true expressions 
(i.e. if the Type is nonempty then it should be evaluated to True).
ChatGPT
ChatGPT
This section details the concept of equalities in the MeTTa language and its interpretation process, crucial for understanding how MeTTa handles expressions and their evaluations.
2.5 Equalities
MeTTa Equality Operator:
The equality operator in MeTTa is expressed as
(= A B)
and implies "A can be evaluated as B."
It is not symmetric, meaning that
(= A B)
does not imply
(= B A)
.
Examples:
Boolean Random Variable:
(= bin 0)
and
(= bin 1)
configure a Boolean random variable to take values 0 or 1.
Deterministic Function:
(= (double $x) ($x $x))
defines a simple deterministic function.
Equality as a Type:
Equality should be considered a built-in Type in MeTTa.
Static type checking during pattern matching does not include inference using equalities (including type equalities).
Instead, equality inference is part of the interpreter loop, distinct from static pattern matching.
2.6 Interpretation
Triggering the Interpretation Process:
The MeTTa interpretation process starts when the interpreter receives a query, which can be:
A pattern matching request.
A request for executing a grounded symbol with certain arguments.
A request for evaluating an expression, including ungrounded symbols.
Recursive Triggering:
Any of these requests may recursively initiate additional steps from any of the options.
Evaluating Expressions:
Evaluating an expression
E
is interpreted as an equality query
(= E $t)
, which might involve multiple recursive steps.
Evaluating the Truth of Expressions:
To effectively evaluate the truth of expressions, the equality
(= (: $t Type) (transform (: $w $t) True))
is used.
This maps inhabited types to true expressions, meaning if a Type is nonempty, it should evaluate to True.
The explanation of equalities and the interpretation process in MeTTa illustrates a complex and nuanced approach to expression evaluation. The distinct treatment of equality as a type and its integration into the interpreter loop underscores MeTTa's sophisticated design in handling logical and functional aspects of AGI programming.
You
3Graph and Metagraph Rewrite Rules 
Existing algebraic formalizations of graph rewriting can be extended to han- 
dle rewriting on directed labeled metagraphs; the only signif i cant step needed 
is to def i ne an appropriate notion of homomorphism on the latter, which re- 
l ects the semantics of types and enrichments used as labels and also deals 
appropriately with the complexities of combining ordered and unordered edge 
targets. 9 
3.1Algebraic Formalization of Graph Rewriting 
We begin with the single-pushout (SPO) formalization of graph rewriting, as 
outlined and utilized e.g. in [GBG+06] 
Paraphrasing the above paper: A SPO graph rewrite rule p : L 
r 
��� R 
consists of a pattern graph L, a replacement graph R and a partial graph 
homomorphism r between L and R. An application of p to a host graph G 
is called a direct derivation. It requires a partial graph homomorphism m 
from L to G , which is called a match. The direct derivation leads to a result 
graph H . For each node or edge x in L there exists a corresponding node 
or edge in G, namely m(x). The overall process is depicted in the following 
diagram: LR 
GH 
�� 
m�� 
�� 
Note that the mapping m does not need to be injective. The preservation 
morphism r determines what happens to m(x): It maps all items from L to 
R, which are to remain in G during the application of the rule. The images 
under m of all items in L which have no image under r are to be deleted. 
The others are retained. Items in R which have no pre-image under r are 
added to H . Note that in general the morphism �� from G to H is neither 
surjective nor total. It is partial, because nodes from G may be deleted to 
get H. Homomorphism �� can be non-surjective, because new nodes may be 
introduced in H��� ��� these new nodes are not in the image of �� but in the image 
of ��. 
The main alternative approach is the double-pushout approach (DPO) 
[CMR+97] . The main dif f erence is how dangling links are dealt with when a 
node is deleted. DPO only deletes a node when the rule specif i es the deletion 
of all adjacent edges as well, whereas SPO just disposes the adjacent edges 
automatically.
ChatGPT
ChatGPT
This section introduces the concept of graph and metagraph rewrite rules in the context of algebraic formalizations, focusing on how these formalizations can be extended to metagraphs and outlining key approaches like single-pushout (SPO) and double-pushout (DPO) graph rewriting.
3 Graph and Metagraph Rewrite Rules
Extending Algebraic Formalizations:
Algebraic formalizations for graph rewriting can be extended to metagraphs.
A significant step is defining a suitable notion of homomorphism for metagraphs, considering types, enrichments, and the handling of ordered and unordered edge targets.
3.1 Algebraic Formalization of Graph Rewriting
Single-Pushout (SPO) Approach:
Based on the SPO formalization of graph rewriting (referenced from [GBG+06]).
An SPO graph rewrite rule
p : L r ��� R
involves a pattern graph
L
, a replacement graph
R
, and a partial graph homomorphism
r
between
L
and
R
.
Direct derivation applies
p
to a host graph
G
, producing a result graph
H
.
The process involves a partial graph homomorphism
m
from
L
to
G
, called a match.
The mapping
m
is not necessarily injective.
The preservation morphism
r
determines the outcome of
m(x)
: items in
L
with no image under
r
are deleted in
G
, while others are retained. Items in
R
without a pre-image under
r
are added to
H
.
The morphism
��
from
G
to
H
is partial and may be non-surjective, as nodes from
G
may be deleted or new nodes may be introduced in
H
.
Double-Pushout (DPO) Approach:
DPO (referenced from [CMR+97]) is an alternative to SPO.
DPO differs mainly in how it handles dangling links when a node is deleted.
In DPO, a node is only deleted if the rule specifies the deletion of all adjacent edges, whereas SPO automatically disposes of adjacent edges.
This section sets the foundation for understanding how graph rewriting principles can be adapted to metagraphs, a crucial component of the MeTTa language and the Hyperon framework. It emphasizes the importance of defining appropriate homomorphisms for metagraphs and compares two fundamental approaches in graph rewriting, highlighting their differences and applicability.
You
In the DPO approach, roughly speaking, a production is given by p = 
(L,K,R), where L and R are the left- and right-hand side graphs and K 
is the common interface of L and R, i.e. their intersection. The left-hand 
side L represents the preconditions of the rule, while the right-hand side R 
describes the postconditions. K describes a graph part which has to exist 
to apply the rule, but which is not changed. L/K describes the part which 
10 
is to be deleted, and R/K describes the part to be created. A direct graph 
transformation with a production p is def i ned by i rst i nding a match m of 
the left-hand side L in the current host graph G such that m is structure- 
preserving. 
When a direct graph transformation with a production p and a match 
m is performed, all the vertices and edges which are matched by L/K are 
removed from G.The removed part is not a graph, in general, but the 
remaining structure D := (G/m(L)) ��� m(K) still has to be a legal graph, 
i.e., no edges should be left dangling. This means that the match m has to 
satisfy a suitable gluing condition, which makes sure that the gluing of L/K 
and D is equal to G. In the second step, the graph D is glued together with 
R/K to obtain the derived graph H. Since L and R can overlap in K, the 
submatch occurs in the original graph G and is not deleted in the i rst step, 
i.e. it also occurs in the intermediate graph D. For gluing newly created 
vertices and edges into D, the graph K is used. This def i nes the gluing items 
at which R is inserted into D. 
LKR 
GDH
ChatGPT
ChatGPT
The description here elaborates on the Double-Pushout (DPO) approach in graph rewriting, explaining its structure and the process of graph transformation under this model.
Double-Pushout (DPO) Approach:
Structure of a Production:
A production in DPO is represented as
p = (L, K, R)
.
L
is the left-hand side graph representing the rule's preconditions.
R
is the right-hand side graph describing the postconditions.
K
is the common interface, or intersection, of
L
and
R
, indicating parts of the graph that exist but are unchanged by the rule.
L/K
represents the graph part to be deleted.
R/K
represents the graph part to be created.
Graph Transformation Process:
Finding a Match:
The first step involves finding a match
m
of the left-hand side
L
in the current host graph
G
.
The match
m
must be structure-preserving.
Performing the Transformation:
When the transformation occurs, vertices and edges matched by
L/K
are removed from
G
.
The removal results in a structure
D := (G/m(L)) ��� m(K)
that must still be a valid graph, meaning no dangling edges are left.
The match
m
must satisfy a gluing condition, ensuring the union of
L/K
and
D
equals
G
.
Creating the Derived Graph:
In the second step, the graph
D
is combined with
R/K
to form the derived graph
H
.
Since
L
and
R
can overlap in
K
, the submatch in
G
is retained in the intermediate graph
D
.
New vertices and edges from
R/K
are glued into
D
using
K
as a reference for insertion points.
Illustration:
The overall process is illustrated as follows:
LKR
to
GDH
, where:
L
transitions to
G
(initial graph).
K
represents the common, unchanged part.
R
transitions to
H
(resulting graph).
The DPO approach emphasizes precise control over graph transformations, where specific conditions must be met for successful application of a rule, including the handling of edges and vertices to maintain graph integrity. This method is essential in contexts where graph transformations need to be managed accurately, such as in complex AGI systems using graph-based representations and computations.
You
3.2Algebraic Formalization of Directed Labeled Meta- 
graph Rewriting 
SPO and DPO are about graphs, but the generalization to hypergraphs 
or metagraphs (including directed labeled metagraphs) is immediate. One 
merely needs an appropriate notion of homomorphism. 
A hypergraph homomorphism is a map from the vertex set of one hyper- 
graph to another such that each edge maps to one other edge. Metagraphs 
are similar but slightly tricker. 
We consider here labeled metagraphs, by which we mean metagraphs 
whose edges are potentially labeled with types and also other enrichments, 
such as e.g. numerical vectors or tensors, where: 
��� The types may be drawn from any appropriate type theory 
��� e.g. in a Hyperon context we are working with variations on prob- 
abilistic dependent type theory, inspired by [Goe20] and various 
11 
references therein, and the Idris 2 type system [Bra20] and other 
sources 
��� Key is that there is a notion of type inheritance so that with two 
types T and T1we can evaluate whether the inheritance relation 
T < T1holds. 
��� For other enrichments used as part of labels, it will be convenient if 
they come with a notion of homomorphism 
��� For instance, if tensors are used as enrichments, then linear trans- 
formations on tensor space are homomorphisms 
��� If there is no more sophisticated notion of homomorphism avail- 
able for a particular sort of enrichment, then the identity mapping 
can serve as homomorphism operation, meaning that metagraph 
homomorphisms will need to preserve these enrichments precisely 
Note that, fundamentally, the types and enrichments involved in a meta- 
graph may be considered as shorthands for pointers to metagraphs embody- 
ing the information in these types/enrichments. In the end one could make 
do without labels via encoding label/enrichment information in connectivity 
structure, but this would be awkward and not a useful approach for practical 
implementation in current hardware/software infrastructures.
ChatGPT
ChatGPT
This section discusses the extension of algebraic formalizations from graphs to hypergraphs and metagraphs, focusing particularly on directed labeled metagraphs. The key to this extension is the concept of homomorphism suitable for these more complex structures.
3.2 Algebraic Formalization of Directed Labeled Metagraph Rewriting
Generalization to Hypergraphs and Metagraphs:
SPO and DPO formalizations for graphs can be generalized to hypergraphs and metagraphs.
The primary requirement for this generalization is an appropriate definition of homomorphism.
Hypergraph Homomorphism:
In hypergraphs, a homomorphism maps the vertex set of one hypergraph to another, ensuring each edge maps to another edge.
Metagraphs and Labeled Metagraphs:
Metagraphs are similar to hypergraphs but with additional complexity.
Labeled metagraphs are metagraphs whose edges can be labeled with types and other enrichments like numerical vectors or tensors.
Types in metagraphs may come from various type theories, such as probabilistic dependent type theory.
A key aspect of these types is the concept of type inheritance, where one can evaluate whether a type
T
is a subtype of another type
T1
(
T < T1
).
Homomorphism for Other Enrichments:
For enrichments beyond types, it's beneficial if they have an associated notion of homomorphism.
For example, if tensors are used as enrichments, linear transformations in tensor space act as homomorphisms.
If no sophisticated notion of homomorphism is available for a certain enrichment, the identity mapping can serve as the homomorphism operation, requiring precise preservation of these enrichments in metagraph homomorphisms.
Fundamental Nature of Types and Enrichments:
Types and enrichments in a metagraph can be seen as pointers to other metagraphs that embody the information in these types/enrichments.
While it's theoretically possible to represent label and enrichment information solely via connectivity structure, this approach is impractical for current hardware and software infrastructures.
The extension to metagraphs involves incorporating complex structures and relationships, which are essential for the sophisticated functionalities required in systems like the Hyperon framework. Understanding these algebraic formalizations and homomorphism concepts is crucial for working effectively with metagraphs, particularly in the context of AGI development.
You
A (directed labeled) metagraph homomorphism would then be naturally 
def i ned as follows.Suppose the edges of the metagraphs of concern are 
labeled with types T drawn from type-system T and additional enrichments 
S drawn from the algebra S on which a notion of homomorphism is def i ned. 
A metagraph homomorphism �� is then a map from the edge set of one 
metagraph M to edge set of another metagraph M���with the property that 
there exists some homomorphism �� on S so that 
��� If in M 
��� E links to F with type T and enrichment S 
then in M��� 
��� ��(E) links to ��(F) with type T ���, enrichment S��� 
where the inheritance T 
��� < T holds, and S���= ��(S) 

��� If in M 
��� E links to F with index i1and type T1 
��� E1links to F1with index i2> i1and type T2 
, then in M���, 
��� ��(E) links to ��(F) with index j1and type T 
��� 1, and enrichment S 
��� 
1 
��� ��(E1) links to ��(F1) with index j2> j1and type T 
��� 
2 and enrich- 
ment S��� 
2 
where T 
��� 
1 < T1, T 
��� 
2 < T2, S��� 
1 = ��(S1), S��� 
2 = ��(S2). 
Note that ���Edges��� in this case include vertices as degenerate edges. 
With this def i nition of a homomorphism, the formalization of algebraic 
graph rewriting given above, in both the SPO and DPO scenarios, carries 
over perfectly to the labeled typed metagraph case. 
Basically, this def i nition of a labeled directed metagraph homomorphism 
provides a def i nition for what it means for one sub-metagraph to form a ���pat- 
tern��� that ���matches��� another sub-metagraph. This is a more basic form of 
pattern-matching than the pattern-matching in the MeTTa language, which 
explicitly involves variable binding, but it���s a suitable under-layer both for 
MeTTa pattern-matching and other aspects of MeTTa. 
The treatment of enrichments beyond types implicit in this def i nition is 
mildly subtle: basically M is said to match M���if there is a match in all 
aspects besides enrichments, and if there is a homomorphism that maps the 
enrichments of M into the corresponding enrichments of M���. This require- 
ment is necessary and suf i cient to ensure that the commutation diagrams 
presented above for SPO and DPO rewriting will still work in the context of 
enriched metagraph edges.
ChatGPT
ChatGPT
This section defines a metagraph homomorphism for directed labeled metagraphs, crucial for understanding pattern matching and rewriting in this context, particularly relevant for the MeTTa language in the Hyperon framework.
Definition of Metagraph Homomorphism
Homomorphism in Context of Types and Enrichments:
Edges of metagraphs are labeled with types
T
from a type-system
T
and additional enrichments
S
from an algebra
S
.
A metagraph homomorphism, denoted as ��, is a map from the edge set of one metagraph
M
to another
M'
.
It requires a corresponding homomorphism �� on
S
.
Conditions for Metagraph Homomorphism:
Type and Enrichment Matching:
If an edge
E
links to
F
in
M
with type
T
and enrichment
S
, then in
M'
, ��(E) must link to ��(F) with type
T'
and enrichment
S'
.
T'
should inherit from
T
(
T' < T
), and
S'
should equal ��(S).
Order and Index Preservation:
If
E
links to
F
with index
i1
and type
T1
, and
E1
links to
F1
with index
i2
(where
i2 > i1
) and type
T2
in
M
, then:
��(E) must link to ��(F) with index
j1
and type
T'1
, and ��(E1) to ��(F1) with index
j2
(where
j2 > j1
) and type
T'2
in
M'
.
T'1 < T1
,
T'2 < T2
,
S'1 = ��(S1)
, and
S'2 = ��(S2)
.
Inclusion of Vertices:
"Edges" in this definition also include vertices, treated as degenerate edges.
Applicability to Algebraic Graph Rewriting:
With this homomorphism definition, the formalizations of graph rewriting (both SPO and DPO) are directly applicable to labeled typed metagraphs.
Underlying Pattern Matching:
This definition forms the basis for pattern matching in MeTTa, providing an underlying layer for its more complex pattern matching which involves explicit variable binding.
Handling of Enrichments:
The treatment of enrichments is subtle:
M
matches
M'
if there's a match in all aspects except enrichments, and if a homomorphism maps
M
���s enrichments into
M'
���s corresponding enrichments.
This requirement ensures that the commutation diagrams for SPO and DPO rewriting remain valid in the context of enriched metagraph edges.
This comprehensive definition and explanation of metagraph homomorphism are fundamental to understanding how MeTTa language handles complex patterns and structures within the Hyperon framework. It highlights the intricate relationship between types, enrichments, and structural integrity in metagraphs, forming a critical foundation for advanced AGI system development.
You
4MeTTa as Metagraph Rewriting 
We now review the basic concepts needed to represent the MeTTa language 
as a collection of metagraph rewrite rules. Full formalization along these 
lines will be left for a subsequent, auxiliary document. 
At the high level, MeTTa may be understood in metagraph terms via 
13 
��� Portraying MeTTa expressions as dags (similarly to the standard por- 
trayal e.g. of LISP expressions as trees) 
��� Portraying the MeTTa grounding domains as directed labeled meta- 
graphs, where the ���labels��� may include types and also potentially other 
enrichments such as numerical vectors or tensors 
Obviously this represents taking the i rst step toward metagraph-rewrite-rule 
representation of MeTTa via observing: If the expressions and the grounding 
domains are all metagraphs (a dag being a sub-case of a metagraph), then one 
can conceive and analyze MeTTA entirely in terms of metagraph rewriting. 
Interpretation of a MeTTa expression is then a matter of a MeTTa ex- 
pression dag (which is part of a metagraph) being interpreted as a metagraph 
rewrite rule, and enacted on the metagraph which it specif i es as its target. 
This may include ref l exive self-rewriting. 
So from a metagraph view, the crux of MeTTa can then be viewed as: A 
way of interpreting certain sub-metagraphs of a directed labeled metagraph 
M, as rewrite rules to be enacted on some sub-metagraph of M.What 
MeTTa provides is a particular way of doing this, which is designed to be 
reasonably ef i cient for implementing and experimenting with rewrite rules 
corresponding to AI algorithms like reasoning engines, evolutionary learning 
processes, algorithmic chemistry, neural architecture learning and so forth, 
such as have been explored in the context of the OpenCog project.
ChatGPT
ChatGPT
This section discusses how the MeTTa language can be represented as a collection of metagraph rewrite rules, a perspective that is crucial for understanding its implementation and functionality within the broader context of the OpenCog project and AI algorithm development.
4 MeTTa as Metagraph Rewriting
Basic Concepts for Representation:
MeTTa is approached from a metagraph perspective, with the intention of formalizing it as metagraph rewrite rules in future documentation.
Representation of MeTTa Expressions and Grounding Domains:
MeTTa Expressions:
Portrayed as directed acyclic graphs (DAGs), akin to how LISP expressions are represented as trees.
Grounding Domains:
Represented as directed labeled metagraphs. The labels may include types and potentially other enrichments like numerical vectors or tensors.
Metagraph-Rewrite-Rule Representation:
Observing that both expressions and grounding domains in MeTTa can be represented as metagraphs, it becomes possible to analyze and understand MeTTa entirely in terms of metagraph rewriting.
Interpretation of a MeTTa expression involves treating it as a metagraph rewrite rule that acts on a specified target metagraph, which could include reflexive self-rewriting.
Crux of MeTTa in Metagraph Terms:
The essence of MeTTa is in interpreting certain sub-metagraphs of a directed labeled metagraph
M
as rewrite rules to be enacted on other sub-metagraphs of
M
.
MeTTa provides a specific approach to this interpretation, aimed at efficient implementation and experimentation with rewrite rules.
These rewrite rules correspond to various AI algorithms, such as reasoning engines, evolutionary learning processes, algorithmic chemistry, neural architecture learning, etc., explored in the OpenCog project.
Implications for AI Development:
The representation of MeTTa as metagraph rewriting highlights its potential in handling complex AI algorithms and processes. By utilizing the concept of metagraphs, MeTTa offers a flexible and powerful framework for AI development, particularly in areas requiring sophisticated pattern recognition, knowledge representation, and learning processes. This approach aligns with the overarching goals of the OpenCog project to create versatile and efficient AI systems.
You
4.1Formalizing MeTTa Structures and Spaces 
A bit more formally, construction of MeTTa in the metagraph context starts 
with: 
��� A space S of symbols, which can be taken as labels of metagraph edges 
or targets 
��� A grounding map G : S ��� F, which maps symbols into a grounding 
domain F. This map may be represented in a metagraph by directed 
edges labeled ���G��� for grounding 
��� A ���variable��� property which identif i es certain symbols as variable- 
names (this could be implemented in many ways in a metagraph, e.g. 
via associating such symbols with a unary edge labeled ���V���) 

��� A space T of ���types,��� drawn from an appropriate (possibly dependent 
and/or probabilistic) type system. Types are a subset of the possible 
edge labels. Type-space comes with a notion of inheritance, according 
to which it can (hopefully tractably) be determined whether type T1is 
a sub-case of type T2and whether x inhabits type T1, etc. Indication 
that a label is a type could be implemented formally e.g. by associating 
the label with a unary edge labeled ���T��� 
��� MeTTa type-assignment and type-restriction symbols become labels on 
metagraph edges, where they can be found and utilized via the MeTTa 
interpretation process 
��� An equality operator A = B that has the rough interpretation: The 
interpretation process can replace A withB (sometimes, depending on 
situation). But from a syntactic perspective ���=��� is just another meta- 
graph edge label.
ChatGPT
ChatGPT
In this section, the process of formalizing MeTTa structures and spaces within the metagraph context is further elaborated, providing a more detailed framework for how MeTTa integrates into the metagraph structure.
4.1 Formalizing MeTTa Structures and Spaces
Key Components in Metagraph Context:
Symbol Space (S):
A space of symbols that serve as labels for metagraph edges or targets.
Grounding Map (G):
A mapping
G : S ��� F
that associates symbols with a grounding domain
F
.
Represented in metagraphs by directed edges labeled "G" for grounding.
Variable Property:
Identifies certain symbols as variable names.
Implementation could involve associating these symbols with a unary edge labeled "V" within a metagraph.
Type Space (T):
A space of "types" drawn from an appropriate type system (possibly dependent or probabilistic).
Types are a subset of possible edge labels in a metagraph.
The type system includes a notion of inheritance for determining sub-case relationships and type inhabitation.
Types can be formally indicated by associating the label with a unary edge labeled "T".
Type-Assignment and Type-Restriction Symbols:
Integrated as labels on metagraph edges.
Accessed and used through the MeTTa interpretation process.
Equality Operator (A = B):
Roughly interpreted as: the interpretation process can replace A with B in some situations.
Syntactically, "=" is treated as another metagraph edge label.
Implications for MeTTa Implementation:
The formalization of MeTTa within a metagraph framework involves creating a richly structured environment where symbols, types, and variables are interconnected through a network of labels and edges. This setup allows MeTTa to efficiently process complex AI algorithms and reasoning tasks, harnessing the power of metagraphs for advanced computational processes. By mapping these elements onto metagraph structures, MeTTa leverages the inherent flexibility and scalability of metagraphs, making it well-suited for the dynamic and diverse requirements of AGI development.
You
4.1.1Formalizing the Grounding Domain 
Now what does an element of the grounding domain F look like? In general, 
we may say it looks like a function from E ���F into E ���F ��� where E is the 
space of MeTTa expressions (to be def i ned below). 
MeTTa expressions may refer to the labels of metagraph edges as constant 
���data���, so we can handle groundings that involve e.g. strings or numerical 
tensors by considering these as edge labels. 
This general approach encompasses both standard grounding functions 
involving strings and vectors and such, and also further potentials. In gen- 
eral, this approach allows us to model F as a space of non-well-founded sets 
[Acz88]. These can be represented as ���apgs���, i.e. as labeled directed graphs, 
which are a species of metagraph. 
4.1.2Symbolizing the Activation of a Sub-Metagraph Encoding 
a MeTTA Program 
Next we need to formalize the interpretation of a sub-metagraph as a MeTTa 
program to be enacted on a metagraph. Let the label @ denote the ���ap- 
plication��� symbol, with the semantics that: When the MeTTa interpreter 
encounters an edge labeled with a grounding function symbol, which has attached to it a unary edge labeled with ���@���, then it applies the grounding 
function to its specif i ed arguments. 
When a grounding function f is applied to an expression e, then if e is 
a grounding function with @ attached, f i rst executes e and then acts on 
the result. Otherwise, f assumes e is a ���literal expression���, and acts on the 
metagraph e directly. 
For the formalization of MeTTa as metagraph rewriting to work out in 
full glory, one would like the grounding functions to be implemented as meta- 
graph rewriting rules also ��� so the grounding functions should in principle 
be metagraphs represented via ���MeTTa expressions��� headed by application 
symbols. This means that the matching of a grounding function to a meta- 
graph argument should follow the ���pattern match as metagraph homomor- 
phism��� approach described above, which seems sensible and unproblematic. 
In actual practice, however, grounding functions in MeTTa programs will 
often be functions written in other programming languages (e.g. Python, Ju- 
lia, Rust) to which MeTTa is connected. This is not problematic in practice 
and often will be in the interest of greater usability and ef i ciency, but it���s 
not a formal or semantic necessity. So long as it works out equivalent (except 
for ef i ciency and UX wise) to what would happen with a pure MeTTa im- 
plementation, it���s all good as regards the formal analyses and models given 
here.
ChatGPT
ChatGPT
This section delves into formalizing the grounding domain and the activation of sub-metagraphs that encode MeTTa programs, providing a deeper understanding of how MeTTa operates within a metagraph framework.
4.1.1 Formalizing the Grounding Domain
Nature of Grounding Domain Elements (F):
Elements of
F
can be conceptualized as functions from
E ��� F
into
E ��� F
, where
E
represents the space of MeTTa expressions.
MeTTa expressions can reference metagraph edge labels as constant data, allowing for groundings involving strings or numerical tensors by treating these as edge labels.
This approach supports both standard grounding functions (like strings and vectors) and more complex potentials.
F
can be modeled as a space of non-well-founded sets, representable as "apgs" (labeled directed graphs, a type of metagraph).
4.1.2 Symbolizing the Activation of a Sub-Metagraph Encoding a MeTTa Program
Activation of MeTTa Programs:
The label "@" denotes the "application" symbol.
When the MeTTa interpreter encounters an edge labeled with a grounding function symbol and a unary edge labeled "@", it applies the grounding function to specified arguments.
Application of Grounding Functions:
If
e
(an expression) is a grounding function with "@" attached,
f
(another function) first executes
e
and then acts on the result.
If
e
is a literal expression,
f
acts directly on the metagraph
e
.
Metagraph Rewriting Rules for Grounding Functions:
Ideally, grounding functions should also be metagraph rewriting rules, represented as MeTTa expressions with application symbols.
The matching of a grounding function to a metagraph argument should follow the pattern-match-as-metagraph-homomorphism approach.
In practice, however, grounding functions in MeTTa programs might be written in other programming languages (like Python, Julia, Rust) for usability and efficiency.
As long as the practical implementation is equivalent to what would happen in a pure MeTTa implementation (except for efficiency and user experience), it aligns with the formal models presented.
Implications for MeTTa Implementation:
The formalization process described here underscores the sophisticated structure of MeTTa within a metagraph framework. The ability to handle complex data types and the integration of grounding functions, whether native to MeTTa or external, highlight MeTTa's flexibility and power. This approach facilitates advanced computation and reasoning processes in AI systems, aligning with the broader goals of the OpenCog project in creating versatile and efficient AGI systems.
You
4.2Formalizing the MeTTa Interpretation Process 
To complete the MeTTa picture we then need to introduce a few further 
processes apart from basic execution as encoded by @: 
��� An equality query ���= x $t��� whose interpretation tries to i nd something 
to i ll in the variable slot $t fulf i lling the given equality. Clearly the 
i lling in of the slot is a species of metagraph rewriting. 
��� A VBTO (variable binding term operator [dCM83] ) that takes an 
expression and binds one of its variables to some symbol or expression. 
It must obey type inheritance restrictions. Clearly VBTO is a species 
of metagraph rewriting. 
��� A Pattern Matcher (PM), which when given an expression as a query 
tries to i nd expressions on which you can do VBTO for all the variables 
in the expression in a consistent way. 

��� A ���Transform��� query type, which executes a PM query and then returns a version of the query that is transformed via having its variables 
filled-in with appropriate concrete values 
A MeTTA expression is then def i ned as one of the four cases: a grounded 
function application headed by @, a Pattern Matcher or Transform query or 
an equality query. 
The interpretation process begins with an expression, whose interpreta- 
tion then leads to other expressions being passed to the interpreter for interpretation, etc. The action of the interpreter, and its intermediate states, 
can be represented as metagraphs, which is standardly done inside functional 
programming interpreters. The interpreter is then carrying out a series of 
metagraph rewrites. 
Among the various processes involved here: An expression with variables 
can basically be understood as function whose interpretation requires the 
PM, i.e. it���s a boolean predicate on the space of expressions. So the MeTTa 
interpreter internally requires an EVB (expression variable binding) function 
B that (repeatedly using VBTO) maps expressions into boolean predicates 
on expression-space, and the PM is the back end of B. 
One can fully formalize the interpretation process using appropriate interpreter- 
focused metagraph edge labels such as ���Evaluate Next���. The interpreter���s 
process then evaluates the edges labeled ���Evaluate Next��� , which rewrite the 
metagraph accordingly, and part of this rewriting is adding ���Evaluate Next��� 
to some other edges, etc. 
The formulation of MeTTa interpretation as execution of metagraph rewrite 
rules relies on the fact that the four processes listed above can be implemented 
as metagraph rewrite rules, i.e. as metagraph-level pattern matches formulated in terms of metagraph homomorphisms, followed by metagraph trans- 
formations (that may be non-surjective and non-total, potentially involving 
e.g. inserting new edges into the metagraph). This implementability basi- 
cally boils down to the implementation of the pattern matching underlying 
VBTO, potentially with consistency or equality constraints, as a metagraph 
homomorphism. But this is evident.The substitution of a variable with 
a referent in a metagraph M does not modify the structure of M, and the 
nature of this matching is that the type of the referent must inherit from 
the specified type constraint on the variable, which comes along from the 
definition of homomorphism given above.
ChatGPT
ChatGPT
This section outlines the formalization of the MeTTa interpretation process, detailing the key components and processes that facilitate the execution of MeTTa programs within a metagraph framework.
4.2 Formalizing the MeTTa Interpretation Process
Key Processes in MeTTa Interpretation:
Equality Query (="x $t"):
Attempts to find a suitable substitution for the variable slot
$t
that fulfills the given equality.
This process is a form of metagraph rewriting.
Variable Binding Term Operator (VBTO):
Binds one of the variables in an expression to a symbol or expression.
It must adhere to type inheritance restrictions and is also a type of metagraph rewriting.
Pattern Matcher (PM):
Given an expression as a query, it looks for expressions where VBTO can be consistently applied to all variables.
Transform Query:
Executes a PM query and then returns a version of the query with variables filled in with concrete values.
Definition of a MeTTa Expression:
A MeTTa expression is defined as either a grounded function application headed by "@", a Pattern Matcher or Transform query, or an equality query.
Interpretation Process:
Starts with an expression whose interpretation leads to other expressions being interpreted in sequence.
The interpreter's actions and its intermediate states can be represented as metagraphs, similar to functional programming interpreters.
Essentially, the interpreter performs a series of metagraph rewrites.
Further Process Details:
An expression with variables is essentially a function requiring PM, acting as a boolean predicate on the space of expressions.
The interpreter requires an Expression Variable Binding (EVB) function
B
that maps expressions into boolean predicates on expression space, with PM acting as the backend of
B
.
The process can be formalized with interpreter-focused metagraph edge labels like "Evaluate Next".
The interpreter evaluates these edges, rewriting the metagraph and adding "Evaluate Next" to other edges as part of this process.
Implementation as Metagraph Rewrite Rules:
The four processes listed can be implemented as metagraph rewrite rules, formulated in terms of metagraph homomorphisms, followed by metagraph transformations.
The implementation of pattern matching for VBTO, with consistency or equality constraints, is a key aspect, aligning with the definition of metagraph homomorphism.
Implications for MeTTa:
The formalization of the MeTTa interpretation process as metagraph rewrite rules illustrates the sophisticated mechanism behind MeTTa's operation. This approach enables complex AI functionalities like variable binding, pattern matching, and equality queries, all crucial for advanced reasoning and learning processes. By framing these operations within a metagraph structure, MeTTa leverages the inherent flexibility and power of metagraphs for efficient and dynamic AGI system development.
You
5Rediscovering the Ruliad: From Metagraph 
Rewrite Rule Systems to the (���,1)-topos 
One of the consequences of the MeTTa framework is that metagraph rewrite 
rules, specif i ed as MeTTa programs, can be expressed as metagraph content. 
The execution trace of a MeTTa program can also be expressed as metagraph 
content. Execution of a MeTTa program is then a process of ���activating��� a 
sub-metagraph, which then results in the enaction of the series of metagraph 
rewrite rules encoded by that sub-metagraph, and recording of the execu- 
tion trace of the series of rewrites in an auxiliary ���history��� portion of the 
metagraph. Proofs as studied in Homotopy Type Theory, including identity 
proofs, are among these execution traces. 
This makes it automatic to create MeTTa programs whose inputs and 
outputs are MeTTA programs. One can extrapolate to n���th order MeTTa 
programs that transform or create MeTTa programs that transform or create 
MeTTa programs, etc. It is also straightforward to create MeTTa programs 
that modify themselves, ef f ectively ���inf i nite order��� transformations. 
Putting these aspects together, the collection of arbitrary-order MeTTa 
programs modifying arbitrary metagraphs becomes equivalent to what the 
Wolfram Physics community has come to call the ���Ruliad��� [AG21][Goe21a] ��� 
the pool of formal rules that modify formal rules that modify formal rules ... 
inf i nitely nested. In [AG21] it is shown that the Ruliad can be modeled as the 
(���,1)-topos, which is basically an ���-category def i ned over an ���-groupoid. 
The population of MeTTa programs operating on arbitrary metagraphs is 
a dif f erent formulation of the Ruliad, because the Wolfram community is 
concerned with hypergraphs rather than metagraphs, but there is a bisimu- 
lation between metagraph rewrite rules and hypergraph rewrite rules, which 
means that the two ultimately come down to the same thing (unless one is 
concerned with computational ef i ciency issues). 
The practical value of this theoretical perspective is not yet clear. Work- 
ing computational ef i ciency issues into this Ruliad type framework involves 
numerous subtleties which are mostly currently unresolved and are critical 
in any practical applications. However, it is nice to know what sort of formal 
structure one is dealing with, and one expects the theory and practice of 
MeTTa will evolve together over the coming years.
ChatGPT
ChatGPT
In this section, the document explores the implications of the MeTTa framework, particularly how it relates to the concept of the "Ruliad" and the (���,1)-topos, as understood in the Wolfram Physics community.
5 Rediscovering the Ruliad: From Metagraph Rewrite Rule Systems to the (���,1)-topos
Metagraph Rewrite Rules and Execution Traces:
Metagraph rewrite rules specified as MeTTa programs and their execution traces can both be expressed as metagraph content.
Execution of a MeTTa program involves activating a sub-metagraph, leading to the enaction of metagraph rewrite rules and recording of execution traces in a "history" portion of the metagraph.
Proofs in Homotopy Type Theory, including identity proofs, are examples of these execution traces.
Self-Referential and Higher-Order MeTTa Programs:
It's possible to create MeTTa programs that input and output other MeTTa programs, leading to the concept of nth order MeTTa programs.
MeTTa programs can also modify themselves, resulting in "infinite order" transformations.
Connection to the Ruliad:
The collection of arbitrary-order MeTTa programs modifying metagraphs aligns with the concept of the "Ruliad" in the Wolfram Physics community.
The Ruliad is described as a pool of infinitely nested formal rules modifying formal rules.
The Ruliad is modeled as a (���,1)-topos, an ���-category defined over an ���-groupoid.
The MeTTa framework offers a different formulation of the Ruliad, focusing on metagraphs instead of hypergraphs. However, there's a bisimulation between metagraph and hypergraph rewrite rules, indicating conceptual similarity.
Theoretical and Practical Implications:
While the practical value of this perspective is not yet fully clear, especially considering computational efficiency, it provides insight into the formal structure of systems like MeTTa.
The theory and practice of MeTTa are expected to evolve together, potentially shedding more light on these concepts and their applications.
This exploration into the theoretical underpinnings of MeTTa and its connection to broader concepts in computational theory underscores the depth and potential of the MeTTa framework. Understanding these relationships can provide valuable insights for future developments in AI and AGI, particularly in areas that require sophisticated formal structures and systems.
You
6Toward Ef i cient Algorithms for Practical 
Metagraph Pattern Matching 
Ef i cient interpretation of MeTTa programs is an unexplored domain which 
has multiple aspects fundamentally dif f erent from those encountered in other 
programming languages. The key resource-intensive operations are pattern 
matching, and inference on equality queries. Inference operationally reduces 
to pattern matching queries plus simple substitutions; so if pattern matching 
is made ef i cient, then managing the cost of inference is essentially down to 
inference control. 
Both inference control and pattern matching are in essence metagraph 
search operations, which can be formulated via chronomorphisms and other 
metagraph fold operations as outlined in [Goe21b] [Goe21c]. However, folding 
over an entire large metagraph will often be undesirable due to resource 
issues, so it will often be desirable to prioritize which edges to fold over i rst, 
and then sometimes to halt a fold mid-way after it���s dealt with higher-priority 
edges. The key then becomes the dynamic prioritization process, which must 
be driven by two approaches: 
��� History-based pattern recognition, which is related to reinforcement 
learning and can be formalized as a discrete decision process integrating 
various AI techniques [Goe21b] 
��� Heuristics chosen based on specif i c characteristics of the metagraph in 
question, e.g. the nature of the types and other enrichments and the 
statistics of edge sizes 
If the metagraph has a distributed implementation this must be taken 
into account here as well, in that some of the search operations will involve 
i nding things that are on remote machines relative to the search process, or 
are in persistent storage. The PM functions that are usable against remotely 
or persistently stored knowledge may be an improper subset of those usable 
against the metagraph portion stored in RAM locally to the search process. 
The speed constraints and formal restrictions of distributed PM must be 
taken into account in both history-based and heuristic guidance of the PM 
and equality inference search processes. 
In [GBG+06] it is shown that guidance of the search process underlying 
graph pattern matching can be reasonably ef i ciently implemented using the 
19 
framework of (SPO) algebraic graph rewriting.In [ABR+18] it is shown 
that categorial formalization of graph rewriting can be quite directly use 
to structure the optimization of graph rewriting to account for particular 
graph characteristics. It seems a similar strategy can likely be taken with 
the search processes underlying metagraph pattern matching and equality 
inference. In essence one formulates heuristics guiding search in terms of 
predicates that act on sub-metagraphs, assessing their priority for search 
based on the context. Such predicates can be learned based on history mining 
or formulated by human developers based on their knowledge of the particular 
metagraph in question.
ChatGPT
ChatGPT
This section addresses the challenge of efficiently interpreting MeTTa programs, focusing on the crucial aspects of pattern matching and inference on equality queries. It also discusses the potential strategies for optimizing these processes in the context of metagraphs.
6 Toward Efficient Algorithms for Practical Metagraph Pattern Matching
Key Challenges in MeTTa Program Interpretation:
The main resource-intensive operations are pattern matching and inference on equality queries.
Inference essentially boils down to pattern matching queries and simple substitutions.
The efficiency of pattern matching is central to managing the cost of inference.
Pattern Matching and Inference Control:
Both are fundamentally metagraph search operations.
Can be formulated via chronomorphisms and metagraph fold operations.
Direct folding over large metagraphs may be resource-intensive, requiring prioritization of edges in the folding process.
Dynamic prioritization is driven by history-based pattern recognition and heuristics specific to metagraph characteristics.
Approaches for Dynamic Prioritization:
History-Based Pattern Recognition:
Related to reinforcement learning and formalized as a discrete decision process integrating various AI techniques.
Heuristics Based on Metagraph Characteristics:
Depends on the nature of types, enrichments, and edge size statistics.
Considerations for Distributed Implementations:
In distributed systems, some search operations may involve remote machines or persistent storage.
The pattern matching functions (PM) applicable to remotely or persistently stored knowledge might differ from those used for local RAM-stored metagraphs.
Distributed PM's speed constraints and formal restrictions must be considered in guiding PM and equality inference searches.
Research and Strategies in Graph Pattern Matching:
Studies like [GBG+06] and [ABR+18] show that the search process in graph pattern matching can be efficiently guided using algebraic graph rewriting and categorical formalization.
A similar approach could be applied to metagraph pattern matching and equality inference.
Heuristics for guiding search can be formulated as predicates acting on sub-metagraphs, assessing their search priority based on context.
These predicates can be learned through history mining or developed by human experts.
Implications for MeTTa Development:
The efficient interpretation of MeTTa programs requires innovative strategies to manage complex pattern matching and inference processes within metagraphs. The integration of AI techniques, history-based learning, and heuristic approaches tailored to specific metagraph characteristics highlights the depth and potential of the MeTTa framework. These strategies, particularly in distributed environments, are key to enhancing the practical usability and effectiveness of MeTTa in advanced AI and AGI applications.
You
7Conclusion 
This is an interim document summarizing ideas and suggested direction re- 
garding an AGI R&D project that is currently in process. Achieving AGI 
is almost surely going to involve a subtle combination of theoretical and 
practical work, and the present paper embodies this combination in multiple 
ways. 
The design of the MeTTa language represents a synthesis of ideas from 
type theory, intuitionistic logic and other theoretical domains with practi- 
cal experience gained via decades of experimentation with OpenCog Classic 
and earlier similar software systems. Prior work expressing various forms 
of knowledge and cognitive process in MeTTa precursor languages and for- 
malisms suggests that MeTTa may be capable to serve as a ���language of 
thought��� spanning the multiple knowledge and dynamics types characteriz- 
ing human-level intelligence as well as the leading paradigms in the AI i eld. 
Like this prior work, the process of l eshing out MeTTa is also being under- 
taken as a combination of theory and practice. Following the completion of 
the i rst MeTTa prototype, there will be a phase of experimental implemen- 
tation of various OpenCog-related AI algorithms in MeTTa, which will guide 
the practicalities of further development of the language front and back ends 
in various ways. 
The motivation for the present paper is not just the natural way that 
a formalization of MeTTa in terms of metagraph rewrite rules i ts into the 
overall OpenCog Hyperon conceptual picture, but also the intuition that 
such a formalization may be helpful for the process of building and utiliz- 
ing Hyperon in multiple respects, including guiding aspects of the back-end 
MeTTa interpreter development and the MeTTa implementation of various 
AI methods. Functional programming interpreter implementation is often 
centered on graph rewriting, and many of the OpenCog-related AI meth- 
ods are founded on mathematics that connects directly to metagraph rep- 
resentations and rewrite rules, so the metagraph-rewrite-rule formalization 
of MeTTa seems to have many ���cognitive synergies��� with other threads of
ChatGPT
ChatGPT
7 Conclusion
This section serves as a conclusion to the document, summarizing the overarching ideas and direction of the AGI (Artificial General Intelligence) R&D project discussed throughout.
Key Points of the Conclusion:
Interim Nature of the Document:
The document is an interim summary of ongoing work in AGI research and development.
Combination of Theoretical and Practical Work:
Achieving AGI is likely to require a blend of theoretical insights and practical applications, a theme that is evident throughout the paper.
Design of MeTTa Language:
MeTTa is a synthesis of concepts from type theory, intuitionistic logic, and practical experience gained from OpenCog Classic and similar systems.
Prior work suggests that MeTTa could serve as a comprehensive "language of thought," covering various knowledge types and dynamics in human-level intelligence and AI.
Development Process of MeTTa:
The development of MeTTa involves both theory and practice.
Following the first MeTTa prototype, there will be experimental implementation of OpenCog-related AI algorithms in MeTTa, guiding further language development.
Motivation for the Paper:
The paper aims to show how formalizing MeTTa in terms of metagraph rewrite rules fits into the broader OpenCog Hyperon framework.
This formalization could aid in building and utilizing Hyperon in several ways, including guiding back-end MeTTa interpreter development and implementing various AI methods.
Functional programming and many OpenCog-related AI methods inherently connect with metagraph representations and rewrite rules, suggesting cognitive synergies with other aspects of AGI research.
Implications for Future Work:
The conclusion highlights the ongoing nature of AGI research, emphasizing the importance of integrating theoretical foundations with practical experimentation. The development of MeTTa, with its roots in both theoretical computer science and hands-on AI experimentation, exemplifies this approach. This blend is seen as essential for advancing towards more sophisticated and capable AGI systems, with MeTTa playing a pivotal role in this journey. The paper concludes by positioning the MeTTa language and its formalization within the larger context of AGI development, suggesting it as a crucial component in the evolution of intelligent systems.
You
The main points of the paper
ChatGPT
ChatGPT
The main points of the paper can be summarized as follows:
Introduction of MeTTa Language for AGI
: The paper introduces MeTTa (Meta Type Talk), a novel programming language designed for the OpenCog Hyperon AGI system. MeTTa is a meta-language with capabilities for handling symbols, variables, types, substitutions, and pattern matching.
MeTTa as a "Language of Thought"
: MeTTa is described as Hyperon���s lowest-level ���language of thought,��� functioning as the foundational language in which learning algorithms and knowledge representations operate and are expressed.
Formalization of MeTTa in Metagraph Terms
: The paper discusses the approach to formalize the MeTTa language as a system of metagraph rewrite rules, fitting within the architecture of the Hyperon framework.
Key Components of MeTTa
: The structure of MeTTa involves symbols, grounding maps, variable properties, types, type-assignment, and equality operators. These elements are integrated into the metagraph framework.
Metagraph Rewrite Rules
: The extension of algebraic graph rewriting to metagraphs is explained, including the Single-Pushout (SPO) and Double-Pushout (DPO) approaches.
MeTTa Interpretation Process
: The interpretation process of MeTTa expressions involves various operations like pattern matching, variable binding, and equality queries, all framed within the metagraph rewriting context.
Link to Ruliad and (���,1)-Topos
: The paper connects MeTTa���s framework to the concept of the Ruliad and the mathematical structure of the (���,1)-topos, highlighting the potential for nested, self-modifying, and higher-order MeTTa programs.
Efficient Pattern Matching and Inference
: The paper addresses the challenges of efficiently implementing pattern matching and inference in MeTTa, proposing approaches that involve prioritizing search operations within metagraphs.
Conclusion and Future Direction
: The document concludes as an interim report on AGI research, emphasizing the synthesis of theoretical and practical aspects in the development of MeTTa and its role in the broader context of AGI development.
Overall, the paper presents a comprehensive view of MeTTa as a foundational element in the OpenCog Hyperon AGI system, detailing its structure, theoretical underpinnings, and potential applications in AGI research.
ChatGPT can make mistakes. Consider checking important information.
?
ChatGPT

