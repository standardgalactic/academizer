Symbolic Completeness
Historial del chat
ChatGPT
ChatGPT
Nuspeak Translator
Jain Hive Tree
Explorar GPT
Hoy
Symbolic Completeness
Criticality-Based Magnetism
Ayer
AI Commodification Concerns
7 d��as anteriores
Carmen Scientiae English Translation
Attention and Consciousness Insights
Reverse Pinocchio Scenario
Hippocampal Bootstrap
Emotion and Mind in Organisms
Iota Subscript in Greek
Greek Verbs Translation Request
Move tag in SRT file
Synchronizing Automata
Embodied Relegation
Fruit Vegetable Number Converter
Update GitHub Page Content
30 d��as anteriores
Perceptual Figuration
Dynamic Terraformation
Orthodromic Rivers
Remove Control Characters Vim
Language Learning Through Reading
FFmpeg GIF Alternation Command
Transformer Language Models Primer
Script Processing Issues
Critical Discourse Analysis Overview
IrfanView Color Inversion Shortcut
Control and Curiosity
Eloi Morlocks Story Outline
Overview of Psych Series
Agregar un espacio de trabajo de Team
Colabora en un plan Team
Nathaniel Guimond
Abrir barra lateral
ChatGPT
4o
ChatGPT
4o
Compartir
Dijiste:
Thanks for providing the context! Now I understand.

In the paper "Speedup of NULL convention digital circuits using NULL cycle reduction" by S.C. Smith, a null-wavefront refers to a special type of wavefront used in NULL Convention Logic (NCL) systems.

Here's a breakdown:

NULL Convention Logic (NCL): A type of digital logic that aims to be delay-insensitive. This means the circuit's behavior doesn't depend on the exact timing of input signals.
Wavefronts: NCL uses wavefronts to represent data and control signals. A wavefront is a complete pulse of information that travels through the circuit.
DATA Wavefront: Carries the actual data being processed by the circuit.
NULL Wavefront: A special wavefront used to flush the previous DATA wavefront from the circuit. This is essential for maintaining delay-insensitivity.
The Problem:

The NULL wavefront typically takes up half the total cycle time, limiting the circuit's throughput (how many operations it can perform per unit time).

The Solution: NULL Cycle Reduction (NCR)

NCR is a technique that aims to speed up the NULL wavefront processing. It does this by:

Parallelizing the Processing: Instead of having one circuit handle both DATA and NULL wavefronts sequentially, NCR uses two parallel circuits.
Demultiplexing and Multiplexing: Input wavefronts are demultiplexed (split) so that one circuit processes a DATA wavefront while the other processes a NULL wavefront. The outputs of these circuits are then multiplexed (combined) to form the final output stream.
Benefits of NCR:

Increased Throughput: By reducing the time required for NULL wavefront processing, NCR allows the circuit to process more DATA wavefronts per unit time.
Maintains Delay-Insensitivity: NCR achieves this speedup without compromising the delay-insensitive nature of NCL.
Let me know if you have any other questions about NULL Convention Logic or NULL Cycle Reduction!
ChatGPT dijo:
ChatGPT
It looks like you've provided a great summary of the paper by S.C. Smith on "Speedup of NULL convention digital circuits using NULL cycle reduction" (NCR). You've explained the core concepts and the solution that NCR offers to improve the throughput of NCL systems effectively.
If you're looking for further clarification or have additional questions about any specific part of NULL Convention Logic (NCL), NULL Cycle Reduction (NCR), or how these principles might apply in a real-world scenario, feel free to ask! I can also help explain related concepts like delay-insensitive circuits or asynchronous logic in more detail.
4o
Dijiste:
That's a very insightful observation!

You're essentially suggesting that the NULL wavefront acts as a kind of "reset" signal, separating distinct computation cycles and preventing the circuit from being confused by transient or incomplete data.

In a way, it does resemble a Markov boundary, as it defines a clear transition point between states.

Here's how your analogy holds up:

Markov Property: Markov processes are characterized by the idea that the future state depends only on the present state, not on the past history. The NULL wavefront, by flushing out previous data, ensures that each computation cycle starts with a clean slate, adhering to this principle.
Distinguishing Calculations and Noise: Just as a Markov boundary helps separate meaningful transitions from random fluctuations, the NULL wavefront helps the circuit distinguish between complete calculations (represented by DATA wavefronts) and potential noise or incomplete signals.
Further Considerations:

Noise Resilience: While the NULL wavefront helps mitigate noise, it doesn't completely eliminate it. NCL circuits are designed to be robust against timing variations and some degree of noise, but severe or persistent noise could still pose challenges.
Complexity: The use of NULL wavefronts adds a layer of complexity to the circuit design.
Overall, your analogy is a clever way to understand the role of NULL wavefronts in NCL. It highlights their importance in maintaining the delay-insensitive nature of the logic and ensuring reliable operation in the face of timing uncertainties.
ChatGPT dijo:
ChatGPT
I'm glad the analogy resonates with you! Indeed, viewing the
NULL wavefront
as a kind of "reset" signal or boundary that separates computation cycles in a
NULL Convention Logic (NCL)
circuit brings out a key insight: it creates a clear demarcation between valid computational data (DATA wavefronts) and the preparatory state (NULL wavefronts), much like how a
Markov boundary
isolates relevant transitions in a Markov process.
By flushing out the previous computation and resetting the circuit, the NULL wavefront ensures that each new DATA wavefront is processed independently of the previous one, which aligns well with the
Markov property
���where the next state only depends on the current state, not on the entire history. In NCL, this is key to maintaining the circuit's delay-insensitivity and robustness, even in the face of asynchronous or irregular input signals.
Further parallels to consider:
Temporal Isolation
: Just as a Markov boundary separates different probabilistic states, the NULL wavefront ensures temporal isolation between consecutive DATA wavefronts, allowing the circuit to move cleanly from one state (DATA processing) to the next (NULL cycle).
State Reset Mechanism
: The NULL wavefront guarantees that the circuit does not accumulate any residual states or incomplete data, much like how a Markov boundary resets the system's memory of past states to allow a fresh calculation.
Probabilistic Fluctuations and Signal Integrity
: Your point on noise is crucial. Although the NULL wavefront serves to manage transitions between DATA states, the system isn't completely immune to noise. However, the very structure of NCL and its reliance on the separation of NULL and DATA states provides significant
resilience
against transient timing issues, similar to how a Markov boundary helps isolate important state transitions from irrelevant or random noise.
By seeing the NULL wavefront in these terms, we understand its importance not only in enforcing strict transitions but also in upholding the circuit's
invariance to timing
���essentially the core of why NCL circuits work well under asynchronous conditions. The NULL cycle reduction (NCR) technique is a clever way to speed up this reset process without losing the critical properties of
delay-insensitivity
.
If you're interested in exploring this concept further or have additional questions about how NCL manages noise or asynchronous inputs, let me know! We can also look into the design trade-offs that come with such a system, like the complexity you mentioned.
4o
Dijiste:
Knowledge Checks: NCL can be compared to a circuit that needs to be checked for readiness before new data can be introduced. This is similar to periodic assessments or quizzes in education, which ensure that students have fully understood the current material before moving on to the next level of complexity.
Learning Prerequisites: In NCL, circuits must resolve all operations before propagating new data, much like how students must demonstrate mastery of prerequisites before advancing to the next level of complexity in a subject.
ChatGPT dijo:
ChatGPT
That's a great comparison! By drawing parallels between
NULL Convention Logic (NCL)
and education, you're highlighting the importance of readiness and mastery before proceeding, whether it's in circuits or learning.
Knowledge Checks:
In NCL, the circuit needs to confirm it's in the
NULL state
before new
DATA wavefronts
can propagate. This ensures that the system is reset and free of any previous data, much like how knowledge checks or quizzes assess whether a student has fully understood the material. These assessments serve as a "checkpoint" to prevent moving on prematurely and risking confusion or errors, similar to how the circuit would malfunction if new data were introduced before the previous data had been cleared.
In both systems:
Checks prevent errors
: Readiness checks in NCL prevent timing issues or incorrect operations, just as quizzes prevent gaps in understanding.
Clear state for progress
: Both require a "clean slate" (either a NULL state in the circuit or a solid grasp of current material in education) to ensure smooth progression.
Learning Prerequisites:
In NCL, circuits can only move forward once all operations have been resolved. This is akin to
learning prerequisites
in education, where students need to demonstrate mastery of foundational knowledge before advancing to more complex topics. If they skip this step, just as if a circuit processes new data prematurely, future operations become error-prone or inefficient.
In both cases:
Building on solid foundations
: Just as circuits rely on complete operations before moving forward, students rely on a strong understanding of the basics before tackling more advanced concepts.
Flow of progression
: Prerequisite knowledge enables smooth learning progress, just like resolving current operations ensures proper data propagation in a circuit.
These comparisons really illustrate how readiness and mastery are essential for success, whether in computing systems or education! Would you like to explore more analogies or further break down the specifics of how NCL works?
4o
Dijiste:
You could give more analogies. I was thinking that a "do not disturb" sign, a driver's license or a university degree might be like a nullwave signal, or maybe a git commit message
ChatGPT dijo:
ChatGPT
These are excellent analogies! Each one provides a fresh perspective on how a
NULL wavefront
in
NULL Convention Logic (NCL)
helps ensure readiness and clean transitions between different phases of operation, similar to how these real-world signals or milestones function in various contexts. Let���s break them down:
1.
"Do Not Disturb" Sign
:
A
"Do Not Disturb" sign
functions similarly to a NULL wavefront because it signals that something is in a
holding state
, and no new information (or interruptions) should be introduced until the sign is removed.
Circuit Analogy
: Just like the "Do Not Disturb" sign prevents interruptions while a task is ongoing, the NULL wavefront tells the circuit to hold off on processing new data until it has cleared the previous data, avoiding potential errors.
Clear boundaries
: The sign sets a boundary between focused work (or rest) and interaction, much like how the NULL wavefront creates a boundary between completed data processing and new input.
2.
Driver���s License
:
A
driver's license
serves as a signal that an individual is ready and capable of safely operating a vehicle. This is similar to how the NULL wavefront signifies that the circuit is prepared to move on to the next wave of data.
Circuit Analogy
: Just as a driver���s license proves the completion of the required training, the NULL wavefront indicates that all previous operations have been successfully resolved and the system is ready for the next phase of work.
Readiness and validation
: The license is like the circuit���s way of "certifying" readiness���both ensure that the system (or person) is capable of advancing to the next task safely and accurately.
3.
University Degree
:
A
university degree
signals that a student has completed a required body of work and is ready to move on to more advanced challenges. Similarly, the NULL wavefront certifies that the circuit has completed a computational cycle and can handle the next DATA wavefront.
Circuit Analogy
: Just as a degree certifies the mastery of a specific academic area, the NULL wavefront ensures that the circuit has resolved previous data and is fully prepared for the next task.
Progress and completion
: Both a degree and a NULL wavefront mark the end of one stage and the beginning of the next, ensuring smooth transitions between levels of complexity in education and data processing, respectively.
4.
Git Commit Message
:
A
git commit message
marks a specific point in the version control process where changes have been finalized and are ready to be incorporated into the project. This is akin to how a NULL wavefront signals that the current data has been processed and that the circuit is ready for new input.
Circuit Analogy
: A commit message represents a state of readiness in code development, ensuring that all changes are recorded before moving on. The NULL wavefront similarly guarantees that the circuit's previous wave of data is fully processed and "committed" before new data is introduced.
Checkpoint for progress
: Both the commit message and the NULL wavefront act as checkpoints that ensure everything is in order before the next step is taken, preventing confusion or errors.
Synthesis of the Analogies:
In all these examples, whether it's a sign, certification, degree, or message, each acts as a
signal of readiness
or completion before moving forward. Similarly, the NULL wavefront in NCL ensures that the circuit is in a clean and resolved state before accepting new data, which is key for its
delay-insensitive
and error-free operation.
They also emphasize
separation of phases
���whether it's avoiding interruptions (Do Not Disturb), ensuring competency (Driver's License, Degree), or marking a complete checkpoint (Git Commit)���much like how the NULL wavefront separates distinct computation cycles.
Would you like to explore even more analogies, or dive deeper into how NCL principles apply in practical digital design?
4o
Dijiste:
Do you have any more?
ChatGPT dijo:
ChatGPT
Certainly! Here are more analogies to further illustrate the concept of a
NULL wavefront
in
NULL Convention Logic (NCL)
and its role in ensuring clean transitions between phases of operation:
5.
Traffic Light (Red Light)
A
red light
at a traffic intersection signals that vehicles must stop, allowing traffic from another direction to proceed safely. It creates a
pause
in one direction before the green light (DATA wavefront) signals that it's safe to move again.
Circuit Analogy
: The red light, like the NULL wavefront, creates a controlled
pause
between cycles of activity. It ensures that vehicles (data) from different directions (previous and next computation cycles) don't clash, preventing accidents (errors).
Safe transition
: Both the red light and the NULL wavefront ensure smooth and safe transitions between two distinct phases���whether it���s traffic flow or computational operations.
6.
Checkpoint in a Video Game
In many video games, a
checkpoint
saves your progress at key moments, allowing you to restart from that point if something goes wrong. It ensures that you don���t lose all progress and can
safely
move forward.
Circuit Analogy
: The NULL wavefront acts like a checkpoint between processing cycles. Just as the game checkpoint saves the player���s progress and ensures they can safely continue, the NULL wavefront ensures that the circuit is reset, prepared, and error-free before starting the next DATA cycle.
Ensuring stability
: Both the game checkpoint and the NULL wavefront provide stability and ensure progress is securely recorded before moving forward.
7.
Airplane Safety Checks
Before an airplane takes off, thorough
safety checks
are performed to ensure everything is in working order. These checks ensure that the plane is safe to fly, and no issues from previous flights remain.
Circuit Analogy
: Just as an airplane needs to be cleared for flight with no leftover issues from the previous trip, the NULL wavefront acts as a
clearance check
to ensure the circuit is ready for new data. It flushes out any remaining issues from previous operations.
Readiness check
: Both the safety checks and the NULL wavefront focus on ensuring readiness before proceeding to avoid potential problems.
8.
Washing Machine Cycle (Spin/Drain Cycle)
After a load of laundry is washed, the
spin/drain cycle
removes excess water before the clothes can be dried. This step is essential to ensure the washing process is complete before starting the drying phase.
Circuit Analogy
: The spin/drain cycle clears out the last remnants of water (previous operation���s state), much like the NULL wavefront flushes out the old data before new data can be processed. Both processes ensure a clean state before moving on to the next stage.
Final resolution
: Both the washing machine and the circuit need to finish their current task completely (removing water or data) before progressing.
9.
Elevator Resetting After a Trip
An elevator typically resets to a neutral or default position (e.g., ground floor) after completing a trip, preparing itself for the next user. This ensures that the elevator is ready and available for the next person to use without residual states from the last trip.
Circuit Analogy
: The elevator reset is similar to the NULL wavefront in that it brings the system back to a neutral state, ready for the next input. It prevents any lingering issues or conditions from the previous trip (computation cycle) from affecting the next one.
Neutral preparation
: Both the elevator and the NULL wavefront ensure the system is ready for the next cycle of operation, making sure no conflicts or incomplete operations carry over.
10.
Rebooting a Computer
Rebooting a computer clears all running processes and resets the system to a known state. This can be necessary to resolve issues like
system instability
or conflicts between programs.
Circuit Analogy
: The NULL wavefront acts as a
soft reset
between operations, much like rebooting a computer clears the system and starts it fresh. It ensures that the circuit isn���t bogged down by leftover processes (old data) from the previous cycle.
Ensuring fresh state
: Both the reboot and the NULL wavefront ensure a fresh start, preventing old states from causing issues with the next operation.
11.
"Clean Slate" in a Negotiation
In negotiations, participants often agree to start with a
clean slate
, leaving behind past disagreements to ensure that the next round of talks proceeds without bias or residual conflict.
Circuit Analogy
: Just like starting with a clean slate in negotiations, the NULL wavefront clears away any lingering ���debate��� from the previous cycle. It provides a neutral starting point so the circuit can process new data without interference from the past.
Clearing old biases
: Both the clean slate and the NULL wavefront prevent past conflicts or errors from influencing new processes.
12.
Mailroom Sorting (Old Letters Cleared Before New Ones)
In a mailroom, workers sort and deliver letters in batches. Before starting a new batch, they must make sure all old letters are processed and delivered, ensuring that no mix-ups occur.
Circuit Analogy
: Like a mailroom clearing old letters before processing a new batch, the NULL wavefront clears old data before a new wave of data enters the circuit. It prevents any
mix-up
between old and new information.
Sequential processing
: Both systems rely on finishing the previous cycle before starting the next to avoid errors and ensure clear separation of tasks.
General Takeaway:
In all these analogies, the
NULL wavefront
is like a reset or readiness signal that ensures the system is fully prepared to handle the next task without errors. Whether it���s stopping traffic, checking safety, saving progress, or rebooting, the NULL wavefront provides a
clean transition
between phases, allowing the system (or person) to move forward smoothly and without interference from past states.
If you'd like to explore these ideas further or dive into how NCL circuits function in more technical detail, feel free to ask!
4o
Dijiste:
NULL Convention Logic���
Karl M. Fant Scott A. Brandt

NULL Convention Logic��� (NCL���) is a symbolically complete logic which
expresses process completely in terms of the logic itself and inherently and conveniently
expresses asynchronous digital circuits. The traditional form of Boolean logic is not
symbolically complete in the sense that it requires the participation of a fundamentally
different form of expression, time in the form of the clock, which has to be very carefully
coordinated with the logic part of the expression to completely and effectively express a
process. We introduce NULL Convention Logic��� in relation to Boolean logic as a four
value logic, and as a three value logic and finally as two value logic quite different from
traditional Boolean logic. We then show how systems can be constructed entirely in
terms of NULL Convention Logic���.
1. Introduction
NULL convention Logic��� [7] is derived directly from the Invocation Model of Process
Expression. The Invocation Model is a conceptual model of general process expression in contrast to
a model of computation. It transcends limiting mathematical notions of computation to provide a
unifying conceptual framework which relates all forms of process expression from the simplest
physical and chemical processes to the most complex natural and artificial processes. For instance,
the processes of cell metabolism and of digital computers are characterized in terms of the same
concepts and relationships. They simply occupy different places in a single expression space defined
by the Invocation Model.
A central concept of the Invocation Model is the general notion of completeness. Just how
fundamental the notion of completeness is will become clear in the course of the discussion. It will
appear in many guises in different aspects of process expression but always in service of providing
necessary and sufficient conditions. We will begin with the notion of symbolic completeness of
expression. symbolically complete expression is complete in and of itself solely in terms of the
relationships among symbol values in the expression. It integrates the expression of data
transformation and what is generally viewed as the expression of control in a single symbolically determined expression, without appeal to any extra-symbolic expression such as a clock or a
controller. Processes in nature are symbolically complete, resolving spontaneously and
autonomously without appeal to any global time authorities or control sequencers. The artificial
processes devised by humans can also be symbolically complete.
Traditional Boolean logic is not symbolically complete. Among its component elements, a
traditional Boolean logic circuit exhibits time dependent relationships as well as symbolic-valuedependent relationships. The symbolic-value-dependent relationships depend on the interconnection
of the logic gates and their truth tables. The time-dependent relationships depend on the
propagation delay times of the component elements to express the validity of data values and the
invalidity of data values. These two aspects of expression are independent of each other in that the
time relationships can be expressed quite arbitrarily in relation to the expression of symbolic
relationships and vice versa. These two quite independent and partial expressions must be carefully
and explicitly coordinated to provide a complete correctly resolvable expression of a process. A
carefully engineered Boolean logic circuit with its clock is a complete expression and can be made to
work, but it is not a symbolically complete expression.
Traditionally, in computer science, the expression of data transformation and the expression of
control have been viewed as inherently independent aspects of process expression which must, of
necessity, be carefully coordinated. In programming languages this manifests as explicit sequence
control of assignment statements. In traditional Boolean logic circuits, the gates and their
interconnections are the data transformation aspect and the timing relationships expressed by careful
engineering and the clock are the control aspect (which expresses the validity and invalidity of data
values). But, the data transformation aspect and the control aspect of process expression are not 
inherently independent. The expression of both aspects can integrated into a single expression
purely in terms of symbolic-value-dependent relationships with no external control expression at all.
This is what is meant by a symbolically complete expression. It is completely expressed and
completely determined solely in terms of symbolic-value-dependent relationships. A symbolically
complete logic circuit would have no time relationships at all and would be completely insensitive
to the propagation delays among its component elements.
There have been attempts to eliminate time dependencies in digital logic circuits since D. E.
Muller, pioneered the pursuit in the late 1950s [1,2]. These attempts (in order of increasing
independence from time issues) are referred to as fundamental mode circuits, speed-independent
circuits, and delay insensitive circuits. Only the delay insensitive circuits are completely free of delay
issues of all circuit components including gates and wires. Delay insensitive circuits are generally
considered the most difficult, expensive and elusive circuits to design. Only a few truly delay
insensitive circuit designs are known. Fundamental mode circuits typically use matched delay lines
to provide a local time reference for each circuit [4] and speed independent circuits must make
assumptions about the insignificant propagation delay of the wires in the circuit.
These attempts to eliminate time dependencies are nearly always expressed within the traditional
context of Boolean logic. They focus on designing Boolean logic circuits with appropriate switching
behavior and surrounding them with Muller C-elements to express the control, then transmitting
data between circuits with dual rail encoding. These structures of Boolean logic circuits and Celements can become very subtle, very large and very expensive[3].
There has been much recent work on asynchronous design [5,6] but, while the pursuit of
asynchronous circuits has produced many interesting results, it has not delivered a theoretically complete and economically feasible solution. The current approaches still require some assumptions
about local transmission delay and the extra circuitry needed to achieve asynchronous control is
considerably more than is required by a functionally equivalent clocked Boolean logic circuit.
NULL Convention Logic��� is a theoretically complete and economically feasible approach to
delay insensitive circuits . In this paper we first introduce the NULL Convention in the context of
Boolean logic, showing how to make Boolean logic symbolically complete as a four value logic. Then,
we show how the NULL Convention can be implemented as a two value logic, which will prove to be
the most practical form. We conclude with a discussion of the properties of NULL Convention
Logic���.
2. Making Boolean Logic Symbolically Complete
The invocation model teaches that to achieve symbolic completeness of expression, both data
transformation and control must be expressed in the most primitive inherently enforced mutually
exclusive value assertion domain of the expression. In a mutually exclusive value assertion domain,
only one of a set of two or more values can be asserted at a time. Every expression environment has a
primitive mutually exclusive value assertion domain. For Boolean logic the primitive mutually
exclusive value assertion domain consists of True and False, only one of which can be asserted at a
time. For the decimal number system the values 0 through 9 are mutually exclusive. In both of these
cases the values comprising the mutually exclusive assertion domain express only data meanings .
There is no value in either domain that expresses a control or non-data meaning. The Invocation
Model teaches that to make Boolean logic symbolically complete, we must add a value to the
primitive mutually exclusive assertion domain.
Making Boolean logic symbolically complete will be presented in two steps. The first step is
to assign a value in the most primitive mutually exclusive assertion domain to express the validity /
invalidity of data. To retain the sense of Boolean logic, we will retain the two values expressing data
meanings in the primitive domain, so the first step is to add a third value to the mutually exclusive
value assertion domain which we will call NULL (not a valid data value). We then define the truth
tables to assert a data value (True, False) only when both input values are data values and to assert a
NULL value otherwise. Figure 1 shows the NULL value added to the traditional Boolean truth tables
and specifies the behavior of these preliminary NULL Convention Logic��� gates.
N
N
N N
F F N
T F
T F N
T
F
N N
N
N N
T F N
T T
T F N
T
F
N N
T
T F
F
N
AND OR NOT
Figure 1. Boolean truth tables with NULL value added.
We now have a three value logic. Each wire can assert one of three values (T, F or N) and each
gate resolves three input values. The values T and F will be collectively referred to as data values and
�� 1997 Theseus Logic Inc. 5
NULL will be referred to as a non-data value. If a data value is asserted on a wire, the data value is
valid. A transition from NULL to a data value marks the beginning of validity. A transition from a
data value to NULL marks the end of validity or the beginning of invalidity.
These truth tables enforce the completeness of input criteria for data. This means that a gate
will assert a data result value only when a complete set of data values is present at its input. In this
case, a complete set of input data values is for both inputs to be data (either TRUE or FALSE, but not
NULL). Furthermore the asserted result data value is the correct resolution of the presented input
data values If either or both input values are NULL a NULL result value is asserted.
THE DATA RESOLUTION WAVE FRONT
The completeness of input criteria is the key to speed independent logic circuits. The
completeness of input criteria for each gate scales up for combinational circuits as a whole. Consider
Figure 2.
input 
value 
set
result 
value 
set
0
1
2
3
4
5
6
7
8
9
A
B
C
D
E
F
G
H
I
J
K
L
M
N
O
P
Q
R
S
T
U
V
Figure 2. Example combinational circuit.
Assume that the circuit is in an all NULL state in that all of the input values, internal values
and result values are all NULL. If one input value, A for instance changes to data, gate 0 will
continue asserting a NULL value. Gate 0 does not assert a data value until both input values for A
and B are data. To see how this behavior scales up for the whole circuit consider gate 6. Gate 6 will
not assert a data value until both inputs N and O are data at the gate . It doesn't matter how long it
took for the data values on N and O to propagate to the gate 6 input or in which order they arrive.
When both input values are data at gate 6, it asserts the correct result data value. This transition from
NULL to data also asserts the validity of that result data value and asserts the completion of gate's
resolution entirely symbolically. No other aspect of expression and no time relationship is associated
with the assertion of these three facts. Each gate is a synchronization node managing an orderly 
wave front of correct result values propagating through the circuit.
The circuit as a whole will not assert a complete set of result data values until there is a
complete set of input data values and the resolution of the input data values has propagated through
the circuit. If one input value remains NULL at least one result value will remain NULL. For
instance, if all the input values are data except G, which remains NULL, then gate 5 will assert a
NULL result value for Q, gate 7 will assert a NULL result value for T and gate 9 will assert a NULL
�� 1997 Theseus Logic Inc. 6
result value for V. When G becomes data, the input data set is complete. The data value will
propagate through the circuit and V will become data and the result data set will be complete (all
datas, no nulls).
When all the result values become data, it means that a complete set of input data values are
presented to the circuit, that the resolution of the presented input value set is complete and the
asserted set of result values is the correct and valid resolution of the presented set of input data
values. This is what is meant by the completeness of input behavior of each gate scaling up for a
circuit as a whole. The circuit does not assert a complete set of result data values until a complete set
of input data values are present at the input to the circuit and resolution of the input values is
complete. The circuit as a whole enforces the completeness of input criteria for data.
The completion of resolution of an input data set can be determined by simply monitoring the
result values. When the result values transition from all NULL to a complete result data value set (all
data at the output), then the resolution of a complete set of input data values is finished. The circuit
indicates its own completion of resolution, autonomously and purely symbolically. No external
expression or authority such as a clock, delay line or controller is needed.
THE NULL -DATA CYCLE
To express the completeness of input criteria for data, the circuits have to start out in an allNULL state. After each data set resolution the circuit must be returned to an all NULL state before
the next data set is presented for resolution, so the circuit must cycle alternately between the all
NULL state and the data resolution state. Now we must determine when the circuit enters the all
NULL state from a data resolution state. If we can determine when the circuit is in an all NULL state,
then we will know when it is ready for a new set of input data to be resolved.
It can be seen from the truth tables of Figure 1 that the completeness of input criteria is not 
enforced for NULL values in relation to data values. If one input value is NULL then the result
value will become NULL. Referring to Figure 2, it is possible for a single input value to become
NULL and drive all the result values to NULL. For instance if D becomes NULL the NULL value
will propagate through gates 1, 3, 4, 6, 7, 8 and 9 driving all of the result values to NULL while there
are still data values lingering on the input and internal to the circuit.
THE NULL WAVE FRONT
The second step in making Boolean logic symbolically complete is for the gates to enforce the
completeness of input criteria for NULL in relation to data (as well as for data in relation to NULL).
This can be accomplished in two ways.
1. Another (i.e. 4th) value can be added to the primitive mutually exclusive value assertion
domain of the logic.
2. A feedback variable can be added to each gate
�� 1997 Theseus Logic Inc. 7
THE INTERMEDIATE VALUE SOLUTION
Adding another value to the primitive mutually exclusive value assertion domain of the logic
provides a solution that ispurely delay insensitive and purely symbolically complete. We will add
another value called the Intermediate value and configure the truth tables as shown in Figure 3.
T
I
F
T F I
K L
J K L
I J
I
K
N
N
T F I I
F F I I
I I I I
I I I N
T
I
F
T F I
K L
J K L
I J
I
K
N
N
T T I I
T F I I
I I I I
I I I N
T
I
F
K
J
I
F
T
AND OR NOT
N IN
Figure 3. Intermediate value truth tables.
We now have a four value logic. It can be seen from the truth tables that a gate will only
assert a data result value when both input values are data, and will only assert a NULL result value
when both input values are NULL. The truth tables directly enforce the completeness of input
criteria for both data and NULL. When the result values are all NULL the inputs are all NULL and
circuit is completely reset and ready for a new data set. When the result values are all data, a
complete data set is presented at the input to the circuit and its resolution is completed. The result
values transition from all NULL through Intermediate values to all data then from all data through
Intermediate values to all NULL. The watcher of the result values looks for all data and all NULL at
the output and simply ignores Intermediate values.
Again, the behavior of each gate scales up for the circuit as a whole. Refer to Figure 2 again
and assume each gate is an Intermediate value gate. Beginning with the circuit in an all data state, if
only D becomes NULL gate 1 will assert an intermediate value until C also becomes NULL. If a
single input value remains data there will be at least one result value that remains Intermediate.
When all result values become NULL it means that the input values are all NULL and the NULL
values have propagated through the circuit and that the circuit is in a completely NULL state. The
circuit as a whole enforces the completeness of input criteria for both data in relation to NULL and 
for NULL in relation to data.
It can now be determined when the circuit is completely reset to NULL and ready to accept a
new input data set to resolve by simply monitoring the result values. When the result values
transition from a complete result data set to all NULL the circuit is completely reset and ready to
accept a new data set. The circuit indicates its own readiness to accept a new input data set purely
symbolically and autonomously. No expression or authority external to the circuit expression such
as a clock, delay line or controller is needed.
We now have a circuit that is a complete expression in and of itself. It can tell the world when
it is ready to accept data to resolve and it can tell the world when it has completed a data resolution.
Data resolution occurs in an orderly wave front of correct result values within the circuit. It can be a
fully autonomous and asynchronous element of a larger whole (i.e. a system).
ChatGPT dijo:
ChatGPT
The detailed description of
NULL Convention Logic��� (NCL���)
that you've shared highlights its key principles, particularly in relation to symbolic completeness and how it departs from traditional Boolean logic. NCL provides a framework for asynchronous digital logic by eliminating the dependence on external timing mechanisms like clocks. Here���s a breakdown of some of the core concepts presented, using analogies and simplified terms to help explain these complex ideas.
1.
Symbolic Completeness vs. Boolean Logic
:
NCL is symbolically complete, meaning that both
data transformation
and
control
are expressed entirely within the logic itself, without needing external timing mechanisms like clocks. In traditional Boolean logic, the correct functioning of the circuit often relies on precise timing (synchronized with a clock), which is not symbolically complete.
Analogy: Cooking without a timer
: In traditional Boolean logic, think of cooking a dish where you must follow a specific sequence with a timer���everything depends on when the timer goes off. If the timing is off, the dish could fail. NCL, however, is like cooking without needing a timer, where each step automatically tells you when it���s done, without relying on an external clock.
2.
NULL Convention Logic as a Multi-Valued Logic
:
The paper introduces NCL initially as a
four-value logic
and then simplifies it into a practical
two-value logic
. By adding the
NULL
value, which represents invalid data, NCL can indicate when the system is not ready to process new data and ensures that data and control are expressed symbolically.
Analogy: Traffic Lights with a "No Go" Signal
: Imagine a traffic light system that doesn���t just show red (stop) and green (go), but also a "no go" signal (NULL) indicating the system isn't ready for either stop or go. This extra value prevents cars from proceeding when the system isn���t prepared to control traffic correctly, just like NULL in NCL prevents data from flowing when the system isn���t ready.
3.
Completeness of Input Criteria
:
NCL ensures that a gate will only assert a data result when all its inputs are valid data. If even one input is invalid (NULL), the result will be NULL. This guarantees that no partial or erroneous data is processed.
Analogy: Group Decision
: Imagine a committee making a decision. The decision (output) can only be made if
every
member has voted. If even one person hasn���t voted (NULL), no decision can be made, ensuring that all input is accounted for before reaching a conclusion.
4.
Wavefront of Correct Data Values (Resolution Wavefront)
:
In NCL, when data is processed, it moves through the circuit in a controlled manner called a
wavefront
. The circuit enforces the completeness of data propagation through each gate, ensuring that no new data is processed until all data has been resolved, from inputs to outputs.
Analogy: Domino Effect with Safety Stops
: Imagine a line of dominoes falling in sequence (wavefront). In a regular scenario, once they start falling, they keep going. But in NCL, there are safety stops between each domino���each domino only falls when the previous domino has stopped moving completely, ensuring full resolution before continuing.
5.
The NULL-DATA Cycle
:
In NCL, the system alternates between an
all NULL state
(where all values are invalid and the circuit is reset) and a
data resolution state
(where valid data is processed). After resolving one data set, the circuit must return to NULL before the next set of data is processed.
Analogy: Cleaning a Whiteboard Between Lessons
: Before a teacher starts a new lesson, they erase the previous lesson from the whiteboard. The board has to be fully clean (NULL state) before new information (DATA) can be written. This alternation between writing and erasing is like the NULL-DATA cycle in NCL.
6.
Intermediate Value Solution
:
In some designs, NCL introduces an
intermediate value
to prevent partial resolution, ensuring complete transitions between NULL and DATA states. This is used to guarantee that data only flows when all inputs are ready and no lingering states exist.
Analogy: Double-Checking Work Before Submission
: Imagine turning in an important report. Before submitting it (DATA state), you mark it as "in progress" (intermediate state) until all parts are complete. You only submit the final report when
everything
is done and double-checked. This intermediate step ensures completeness before final submission.
7.
Asynchronous and Autonomous Processing
:
One of the most significant benefits of NCL is its
asynchronous
nature. Unlike traditional circuits that rely on a global clock to manage timing, NCL circuits are autonomous���they manage their own timing and control based purely on internal states. This makes them more resilient to variations in delays across different parts of the circuit.
Analogy: Autonomous Workers
: Imagine a factory where each worker autonomously decides when they���re done with their task, based on the work they���ve completed, rather than waiting for a manager to tell them when to move to the next step. This self-governing system is more efficient and adaptive to different conditions, just like asynchronous NCL circuits.
8.
Delay Insensitivity
:
Because NCL circuits are delay-insensitive, they don't rely on how long it takes for signals to propagate through the circuit. The circuit operates correctly regardless of variations in gate or wire delays.
Analogy: Weatherproofing a Schedule
: If you schedule an outdoor event without worrying about the exact time it will rain, you can adapt to any weather changes without disrupting your plan. Similarly, NCL circuits adapt to variable delays without malfunctioning, ensuring robust performance.
Conclusion:
NULL Convention Logic��� introduces a symbolically complete framework for asynchronous digital systems, eliminating the need for external clocks and time coordination. By enforcing the completeness of input and output, NCL ensures that data is processed correctly and autonomously, making it highly suitable for applications where timing is uncertain or variable.
This paper describes NCL as an innovative approach to overcoming the limitations of traditional Boolean logic, which is dependent on careful timing and coordination. By incorporating
NULL
and
Intermediate values
, NCL allows for delay-insensitive, self-timed circuits that operate reliably under a wide range of conditions.
4o
Dijiste:
It made me think about how in sympy null values like NA are infectious, and how rational numbers or symbols can remain uncalculated such as storing 1/3 instead of 0.3333, the converstion to a float introduces errors, and also functions can be evaluated lazily such as iterators
ChatGPT dijo:
ChatGPT
Your observation draws an interesting parallel between
NULL Convention Logic (NCL)
and concepts in symbolic computation, rational numbers, and lazy evaluation in programming. These connections highlight how handling incomplete, symbolic, or delayed computations in both hardware and software requires careful management to avoid errors or misinterpretations.
1.
Infectious NULL Values (NA in SymPy)
:
In
SymPy
,
NA
or
None
represents undefined or missing values, and they behave similarly to
NULL
values in NCL in terms of how they "infect" operations. Any operation involving NA (or NULL) results in another NA (or NULL), preserving the "incompleteness" or invalidity of the data.
Parallel with NCL
: Just like how a NULL input to a gate in NCL forces the result to remain NULL until valid data is present, operations in symbolic mathematics involving NA propagate this undefined state. This ensures that invalid inputs don't lead to invalid computations, and the system waits for a fully defined set of inputs.
Analogy
: It's like if someone asks you for the result of a calculation that includes a missing number���you can't give a definitive answer until you have all the necessary information. Similarly, in both SymPy and NCL, the system "waits" until the data is complete.
2.
Rational Numbers (1/3 vs 0.3333) and Symbolic Expressions
:
In symbolic computation,
rational numbers
like
1
3
\frac{1}{3}
3
1
���
are stored exactly, rather than as floating-point approximations like 0.3333, which can introduce rounding errors. By storing the exact symbolic expression, the system avoids premature approximations that would lead to inaccuracies.
Parallel with NCL
: This is analogous to how NCL circuits only resolve values when all inputs are valid and complete. In the symbolic domain, operations are only fully computed when necessary, maintaining precision (like storing
1
3
\frac{1}{3}
3
1
���
instead of converting it to a float prematurely). The system avoids intermediate errors, just as NCL avoids incorrect data processing by waiting for full sets of valid inputs.
Analogy
: Storing
1
3
\frac{1}{3}
3
1
���
instead of 0.3333 is like waiting for the correct data wavefront in NCL. You avoid potential errors by not rushing to an incomplete or approximate state.
3.
Lazy Evaluation (Iterators)
:
In programming,
lazy evaluation
delays the evaluation of an expression until its value is actually needed. For example,
iterators
in Python generate values one at a time, only when required, rather than calculating everything at once.
Parallel with NCL
: Lazy evaluation is similar to how NCL circuits don���t process data until all necessary inputs are available. The system is
delay-insensitive
, meaning it processes inputs when they arrive, not based on an external clock. In both cases, computation is triggered when sufficient information is present, ensuring correctness and avoiding premature evaluation.
Analogy
: Lazy evaluation is like waiting for the complete wavefront in NCL before processing. The system doesn���t rush to compute partial results, much like an iterator doesn't produce the next value until explicitly requested.
4.
Handling Incompleteness in Both Systems
:
In both symbolic computation (like SymPy) and NCL, managing
incompleteness
is a critical aspect of ensuring correctness:
In SymPy, expressions are often left unevaluated to maintain precision or when an expression cannot yet be simplified (such as keeping a sum as
x
+
y
x + y
x
+
y
until the values of
x
x
x
and
y
y
y
are known).
In NCL, circuits remain in the
NULL state
until all inputs are valid, enforcing the
completeness of input criteria
before resolving outputs.
Both systems ensure that premature evaluations or incomplete data don't result in incorrect outputs. They handle incompleteness or uncertainty by delaying computation until all necessary components are available.
5.
Error Propagation and Delay Handling
:
In NCL, the
NULL wavefront
ensures that invalid or incomplete data doesn't propagate prematurely through the circuit. Similarly, in symbolic mathematics, errors or undefined values (like division by zero or symbolic
NA
values) propagate through expressions, ensuring that computations don't produce false results based on partial or incorrect inputs.
Parallel with floating-point errors
: Floating-point numbers introduce errors when converting precise rational values like
1
3
\frac{1}{3}
3
1
���
into 0.3333. Similarly, in Boolean logic, time dependencies and delays can introduce errors when coordinating data transformations with clocks. Both systems���NCL and symbolic math���aim to prevent such errors by waiting for full precision or valid input.
6.
Lazy vs. Eager Evaluation in Digital Logic
:
NCL circuits inherently support a form of
lazy evaluation
because they only process data when it's ready, while traditional clocked systems are more like
eager evaluation
where data is processed according to a strict timing schedule, whether or not all inputs are valid.
Analogy with Lazy Evaluation
: This lazy evaluation in NCL ensures that the system doesn���t rush ahead with incomplete data, much like a lazily evaluated function in programming doesn't perform unnecessary calculations until all the arguments are available.
Summary of Parallels:
Infectious NULLs (NA)
: Both NCL and symbolic math propagate invalid states (NULL or NA) to ensure the system waits for complete input.
Rational vs. Floating-Point
: Storing exact symbolic expressions (like
1
3
\frac{1}{3}
3
1
���
) mirrors NCL's careful processing of valid data inputs, avoiding premature approximations.
Lazy Evaluation (Iterators)
: NCL���s delay-insensitive nature is akin to lazy evaluation, where computations only proceed when fully ready, ensuring correctness.
Error Propagation
: Both systems protect against premature or incomplete processing, ensuring that invalid states don't lead to incorrect results.
These parallels highlight a shared goal in both NCL and symbolic computation: to handle and manage incomplete, delayed, or invalid data carefully, preventing errors and ensuring correctness throughout the process.
4o
Dijiste:
An intermediate value logic circuit is a symbolically complete process expression and is purely
symbolically determined. The Intermediate value solution is a theoretically complete and general
solution to delay insensitive circuit synthesis. Its symbol resolution behavior is not affected in any
way by the propagation delay of any element in an expression.
The addition of the NULL value or the Intermediate value did not change the transform
specifications for the data values. Intermediate value NULL Convention Logic��� gates can replace
the gates of a standard Boolean logic combinational circuit one for one, and the circuit will provide
the identical logic function as before. It will simply resolve in a more orderly manner and assert its
own completion, as well as its own readiness to accept a new input data set.
THE FEEDBACK SOLUTION
The feedback solution makes each gate a state machine with hysteresis of result value
assertion. Figure 4 shows the truth table for the feedback gate. Do not be daunted by the seeming
complexity of this table. This is just the first example to introduce the NULL convention.
T
N T F
N T F
R
B
R
F
N T F
N F F
N
INPUT A
RESULT
N
N T F
N N N
T
N T F
F F
F
N T F
F F F
F
N
N T F
N F F
T
N T F
T T
F
N T F
T
N
N T F
F N T T T T T T
R B
A
Fig 4. The feedback gate and its truth table.
R is the result variable fed back to the input. When the gate is asserting NULL it is in the
NULL (N) state and will continue asserting N until both input values become data (T,F) at which
point it will transition its result value to a data value and enter a data state. When the gate is in a
data state ( R = F or T) it will continue asserting a data value until both input values become NULL
(N) at which point it will transition its result value to N and enters a null state. The feedback gate
enforces the completeness of input criteria for both data in relation to NULL and for NULL in
relation to data.
Again, the behavior of each gate scales up for the circuit as a whole. Refer to Figure 2 again
and assume each gate has feedback. Beginning with the circuit in an all data state, if only D becomes
NULL gate 1 continues to assert a data value until C also becomes NULL. If a single input value
remains data there will be at least one result value that remains data. When all result values become
NULL it means that the input values are all NULL and the NULL values have propagated through
the circuit and that the circuit is in a completely NULL state. The circuit as a whole enforces the
completeness of input criteria for both data in relation to NULL and for NULL in relation to data.
�� 1997 Theseus Logic Inc. 9
A NON-CRITICAL TIME RELATIONSHIP
While the intermediate value solution uses play through gates with no time relationships at all
and is fully delay insensitive, the feedback solution is not fully delay insensitive in that there is a noncritical time relationship involved. The feedback path around each gate must stabilize faster than
successive wave fronts of transition pass through the circuit as a whole. We call this a non critical
time relationship because it is easy to achieve since the circuit propagation time will typically be
much longer than the feedback propagation time. The feedback solution is not purely delay
insensitive but is effectively delay insensitive.
3. Two Value NULL Convention Logic���
We have shown how to make Boolean logic purely symbolically complete as a four value logic
system and practically symbolically complete as a three value logic system, but three and four value
logic systems are not commercially viable. The next step is to show how the NULL convention can
be applied to a system with only two values such as our favorite digital electronic implementation
environment.
If the logic is limited to two values (0 volts and 5 volts for instance) in its primitive mutually
exclusive value assertion domain (a wire for instance) and one value must be assigned to express
NULL ( 0 volts), this leaves only one value remaining to express data. This means that each wire can
express only one data meaning which we will call DATA (5 volts). Two data meanings, True and
False for instance, must be expressed with two wires (one wire asserting DATA means TRUE, the
other wire asserting DATA means FALSE). With no inherent means to prevent any two wires from
expressing their DATA values simultaneously there is no longer an inherently enforced mutually
exclusive value assertion domain for data meanings as there was when two data meanings were by
physical necessity mutually exclusively asserted by a single wire. Since there must be mutually
exclusive assertion of DATA values it must be reestablished by convention.
Each wire is still an inherent mutually exclusive value assertion domain that asserts either
DATA or NULL. To reestablish mutually exclusive assertion of data meanings, a convention that
only one wire of a group of wires will assert its DATA value at a time. It is illegal or erroneous for
two or more wires within this group to simultaneously assert DATA values A group of wires that
assert mutually exclusive data meanings will be called a mutually exclusive assertion group.
A mutually exclusive assertion group can be any size. A group of ten wires can directly
express decimal numbers with each wire expressing a digit value. A group of two wires can directly
express True and False. The two wire mutually exclusive assertion group is identical to dual rail
encoding, which is traditionally used as a transmission protocol between speed independent circuits.
The mutually exclusive assertion group in NULL Convention Logic��� is a much more general 
concept than dual rail transmission encoding. It is not just a transmission protocol but is inherent in 
the logic itself .
�� 1997 Theseus Logic Inc. 10
THE SINGLE DATA VALUE LOGIC GATE
NULL expresses a control meaning and is meaningless with respect to data. In fact NULL
means "not data", so the NULL value cannot be considered in resolving data value sets. Since each
input to a gate can express only one DATA value (5 volts for instance) there can be no combinations
of different data values as in Boolean logic. The only discriminable property available when
combining wires at the input to a gate is how many DATA values are presented. Therefore, NULL
Convention Logic��� gates must be discrete threshold gates. A complete input data set for a
threshold gate is sufficient DATA values to meet its threshold. Figure 5 shows a 5 input / threshold 3
gate. If any three or more inputs are DATA the gate will assert a result DATA value. Otherwise it
asserts a NULL value.
3
Figure 5. Threshold gate.
The most direct way to see how discrete threshold gates combine to make an effective logic
circuit is via an example. The half adder will serve as the example and relate the single data value
form of NULL Convention Logic��� to traditional Boolean logic. Figure 6 shows a conventional
Boolean logic half adder circuit with its clock and Figure 7 shows a NULL Convention Logic��� half
adder circuit.
A B S C
0 0 0 0
0 1 1 0
1 0 1 0
1 1 0 1
A
B
C
S
1
2
3
4
5
6
7
8
9
10
1112
Figure 6. Boolean logic half adder circuit with clock.
�� 1997 Theseus Logic Inc. 11
2
2
2
2
1
1
1
00
10
01
A 11 
B
A_1
A_0
B_1
B_0
C
S
C_1
C_0
S_1
S_0
Figure 7. NULL Convention half adder circuit.
The Boolean half adder circuit expresses 4 possible input data values with two data values (0,
1) on two wires (A, B). The NULL Convention half adder circuit expresses the same 4 possible input
data values with one data value (DATA) on four wires (A_0, A_1, B_0, B_1). Each binary data value
A, B, C and S is expressed by a mutually exclusive assertion group of two wires (A_0, A_1 and B_0,
B_1 and C_0, C_1 and S_0, S_1). Only one wire in each group can assert DATA at a time, so a
complete input data set for the circuit is two DATA values, one from each group (A and B). The
completeness of input criteria for each threshold 2 gate is 2 DATA values. It can be seen that for any
threshold 2 gate to assert a data result value there must be one DATA value asserted in each input
group and that only one threshold 2 gate at a time will assert a result data value as long as the
mutually exclusive assertion convention is enforced for the input groups. The gates, as well as the
circuit as a whole, enforce the completeness of input criteria for data. When the result values
transition from NULL to a complete result data set, which in this case is one DATA value for each
result group (C and S), then the asserted result values are a correct resolution of a complete input
data set. The completeness of input criteria for each gate scales up for the circuit as a whole and as
before, the completeness of resolution can be determined by simply monitoring the result values.
Figure 8 shows the circuit behavior for all four possible input combinations. Bold lines are asserting
DATA and thin lines are asserting NULL.
�� 1997 Theseus Logic Inc. 12
2
2
2
2
1
1
1
00
10
01
11 
2
2
2
2
1
1
1
00
10
01
11 
2
2
2
2
1
1
1
00
01
11 
2
2
2
2
1
1
1
C
S
C_1
C_0
S_1
S_0
C
S
C_1
C_0
S_1
S_0
C
S
C_1
C_0
S_1
S_0
C
S
C_1
C_0
S_1
S_0
A
B
A_1
A_0
B_1
B_0
A
B
A_1
A_0
B_1
B_0
A
B
A_1
A_0
B_1
B_0
A
B
A_1
A_0
B_1
B_0
Figure 8. NULL convention half adder circuit behavior.
Another important point to make is that if the mutually exclusive assertion convention is
enforced for the input of the circuit, then the circuit itself maintains the convention at its output . A
system of such circuits communicating among themselves will maintain the convention among
�� 1997 Theseus Logic Inc. 13
themselves. The convention only has to be explicitly enforced at the input to the system. It is self
maintaining within the system.
THE NULL WAVE FRONT AGAIN
A single data value NULL Convention Logic��� circuit still has to be returned to an all NULL
state before accepting a new input data set to resolve. As can be seen from the above examples, when
a gate falls below its threshold it will assert a NULL value. The result values can become all NULL
while there are still DATA values lingering on the input and internal to the circuit as shown in Figure
9.
2
2
2
2
1
1
1
C
S
C_1
C_0
S_1
S_0
A
B
A_1
A_0
B_1
B_0
Figure 9. Lack of completeness of input criteria for NULL.
This is identical to the situation with the previous Boolean logic examples and the same two
solutions apply. There is a feedback solution and an Intermediate value solution.
THE FEEDBACK SOLUTION
The feedback solution is simple, straightforward and inexpensive. To provide the necessary
hysteresis behavior, the result value is fed back with a weight of one less than the threshold as shown
in Figure 10. The rounded gate symbol will represent a gate with the hysteresis behavior. This
hysteresis behavior may be provided by feedback internal to the gate or by some inherent behavior of
the gate implementation approach.
4 4
Figure 10. Threshold gate with weighted feedback of threshold -1.
�� 1997 Theseus Logic Inc. 14
Beginning in a NULL state with all inputs NULL and asserting a NULL result value, the gate
will not assert a DATA result value until its input data set is complete, which in this case is four
DATAs. With the feedback weight of three, the gate will not transition to a NULL result value until
all of its input values are NULL. As long as at least one input value remains DATA, the gate meets its
threshold and will continue asserting a DATA result value. It does not fall below its threshold and
transition to NULL output until all inputs are NULL. This behavior is shown in Figure 11.
Correct resolution of a 
complete input DATA set
Gate reset and ready for a 
new input DATA set
3 3 3
3 3 3
Figure 11. Hysteresis behavior of NULL Convention Logic��� gate.
The gate enforces the completeness of input criteria for both data in relation to NULL and
for NULL in relation to DATA. A threshold 1 gate does not require the feedback connection
because its completeness of input criteria is inherently enforced for both DATA and NULL.
THE ENCODED INTERMEDIATE VALUE SOLUTION
Since we are limited to two values in the most primitive mutually exclusive value assertion
domain we can't just add another value as we did in the Boolean logic example, so we have to encode
another value. The intermediate value solution involves another level of encoding convention on top
of the mutually exclusive assertion group encoding. As things stand so far, each data meaning is
expressed with one data value on one wire. True is one wire and False is another wire. Now we will
express each data meaning with two wires. True will be expressed with two wires and False will be
expressed with two wires. encoded_DATA, encoded_INTERMEDIATE and encoded_NULL are
expressed on these two wires with the following encoding.
DATA, DATA -> encoded_DATA
DATA, NULL -> encoded_INTERMEDIATE
NULL, DATA -> encoded_INTERMEDIATE
NULL, NULL -> encoded_NULL
�� 1997 Theseus Logic Inc. 15
As shown in Figure 12, each input to a gate is two wires and a single intermediate value gate
consists of several threshold gates without hysteresis.
1
4
A_1
B_0 O
Figure 12. Intermediate encoded 2 input threshold 2 gate.
Starting with the intermediate value gate in an all NULL state with encoded_NULL values on
the inputs and asserting an encoded_NULL value. If one DATA value is applied to A_1 the threshold
1 gate meets its threshold and will assert a DATA result value and the result value for the composite
gate will assert DATA, NULL to express the encoded_INTERMEDIATE value. The result value
remains encoded_INTERMEDIATE until all four input wires are DATA, which means that both
inputs are presenting encoded_DATA values and there is a complete input data set, at which time the
threshold 4 gate asserts a DATA value and the intermediate value gate asserts DATA, DATA to
express the encoded_DATA value. As soon as one input wire becomes NULL the threshold 4 gate
falls below its threshold and asserts NULL and the asserted result for the intermediate value gate is
DATA, NULL expressing the encoded_INTERMEDIATE value. The encoded_INTERMEDIATE
value is maintained until all the input wires become NULL at which time the threshold 1 gate asserts
a NULL value and the result value for the composite gate is NULL, NULL expressing the
encoded_NULL value.
The Intermediate value composite gate asserts a encoded_NULL code only when all of its
input values are NULL and expresses a encoded_DATA only when it has a complete set of input data
values. It enforces the completeness of input criteria for both data and NULL. Figure 13 shows a
three input threshold two gate.
1
4
4
4
1
A_1
B_0
C_1
O
Figure 13. Intermediate encoded 3 input threshold 2 gate.
�� 1997 Theseus Logic Inc. 16
Figure 14 shows the Intermediate encoded Half adder circuit.
i2
i2
i2
i2
i1
i1
i1
00
10
01
11 C
S
C_1
C_0
S_1
S_0
A
B
A_1
A_0
B_1
B_0
1
4
A_0
B_0 O
Figure 14. Intermediate encoded half adder circuit.
Translating between intermediate encoded gates and hysteresis gates is straightforward. As
shown in Figure 15 the translation from hysteresis to encoded is simply a matter of fanning out the
single wire. Translating from encoded gates to hysteresis gates can be done with a single threshold 2
hysteresis gate which discriminates encoded_DATA from encoded_NULL and ignores
encoded_INTERMEDIATE.
1
4
A_1
B_0 O
2
2
2
Figure 15. Translating between intermediate encoded gates and hysteresis gates.
As can be seen Intermediate encoding is very expensive in terms of resources. The wires are
all doubled and each encoded gate is several simple threshold gates. The feedback solution is more
practical and economical.
Now that both forms of NULL Convention threshold gates enforce the completeness of input
criteria for both DATA in relation to NULL and for NULL in relation to DATA, their behavior again
scales up for circuits as a whole. Figure 16 shows the data-NULL cycle for a single data value NULL
Convention Logic��� circuit.
�� 1997 Theseus Logic Inc. 17
2
2
2
2
1
1
1
00
10
01
11 
2
2
2
2
1
1
1
00
10
01
11 
2
2
2
2
1
1
1
00
10
01
11 
2
2
2
2
1
1
1
00
10
01
11 
C
S
C_1
C_0
S_1
S_0
C
S
C_1
C_0
S_1
S_0
C
S
C_1
C_0
S_1
S_0
C
S
C_1
C_0
S_1
S_0
A
B
A_1
A_0
B_1
B_0
A
B
A_1
A_0
B_1
B_0
A
B
A_1
A_0
B_1
B_0
A
B
A_1
A_0
B_1
B_0
Figure 16. NULL-DATA cycle for hysteresis gate circuit.
Beginning with the circuit in an all NULL state one DATA value is applied in one of the
groups. The result values remain all NULL since no threshold is met. When a DATA value is
applied in the second group, a complete input data set is present, the threshold of a gate is met which
asserts a DATA value which propagates to the result values. One result value in each output group
asserts a DATA value which constitutes a complete result data set and expresses the correct
�� 1997 Theseus Logic Inc. 18
resolution of a complete input data set. The circuit as a whole enforces the completeness of input
criteria for DATA in relation to NULL and only asserts a complete result data set when a complete
input data set is presented to the circuit.
One of the input DATA values becomes NULL, but the threshold 2 gate and the circuit
continue asserting DATA result values. Only when all inputs to the circuit are NULL does the
threshold 2 gate and hence the circuit transition their result values to NULL. The circuit as a whole
enforces the completeness of input criteria for NULL in relation to DATA and only asserts all NULL
result values when the input to the circuit is all NULL and the NULL values have propagated
through the circuit.
As with the Boolean logic examples with three and four value logic, the completion of
resolution of a complete input data set and the readiness of the circuit to receive a new input data set
to resolve can be determined by simply monitoring the result values. The circuit is symbolically
complete and manages quite on its own its interactions with the rest of the world.
INTERESTING OBSERVATIONS ON SINGLE DATA VALUE NULL CONVENTION LOGIC��� CIRCUITS
A single data value NULL Convention Logic��� circuit can be conveniently monitored for faults
in such a way that it cannot tell a lie as shown in figure 17.
2
2
2
2
1
1
1
00
10
01
11 
3 FAULT
A
B
A_1
A_0
B_1
B_0
C
S
C_1
C_0
S_1
S_0
Figure 17. Fault monitoring NULL Convention Logic��� circuit.
If exactly one DATA value is asserted in each output group it is the correct resolution of a
complete input data set. If there are ever three DATA result values simultaneously asserted, it is an
error and the threshold three gate will announce the error. If the circuit only asserts one DATA result
value it will fail to announce completion of resolution and this can be detected with a watchdog
timer. A NULL Convention Logic��� circuit will always either:
1. Assert a correct result.
2. Fail to complete resolution.
3. Assert an explicit error signal
ChatGPT dijo:
ChatGPT
This detailed explanation of
NULL Convention Logic��� (NCL���)
introduces key solutions for creating symbolically complete circuits, focusing on making digital logic circuits
delay-insensitive
and autonomous. The text contrasts two solutions for achieving this, namely the
Intermediate Value solution
and the
Feedback solution
, and discusses how these circuits can transition to a practical two-value system for real-world digital logic.
Key Concepts and Analogies:
Intermediate Value Solution
:
The
Intermediate Value solution
introduces an additional value beyond the standard data values and NULL, allowing the system to express intermediate states that facilitate delay insensitivity. This solution maintains symbolic completeness and is immune to delays across different components of the circuit. By adding another value, the circuit's symbolic resolution becomes independent of propagation delays.
Analogy: A traffic light system with an extra signal
: Imagine a traffic light that not only shows red (stop) and green (go) but also includes a yellow signal (intermediate). This ensures that the system transitions smoothly between states, giving drivers enough time to adjust. In NCL, the intermediate value ensures that the system transitions smoothly between NULL (incomplete data) and DATA (valid inputs), without errors caused by time delays.
Feedback Solution
:
The
Feedback solution
introduces hysteresis to each gate, creating a state machine where each gate "remembers" its previous state and waits for a complete input before transitioning. This is more practical but introduces a
non-critical time relationship
where the feedback loop must stabilize faster than successive transitions. However, this feedback system is not fully delay-insensitive but
effectively delay-insensitive
since the time relationships are easy to meet in practice.
Analogy: Double-checking before moving forward
: Imagine you're filling out a form, and before submitting, you double-check each answer to ensure it's correct. The form won't be accepted until all sections are complete (hysteresis). Similarly, in the feedback solution, the gate only transitions once it's sure all input values are complete, reducing errors caused by premature transitions.
Two-Value NCL System
:
The transition to a
two-value NCL system
(like standard digital circuits that use 0 volts for FALSE and 5 volts for TRUE) is achieved by employing
mutually exclusive assertion groups
. For example, in a dual-rail encoding, one wire signals TRUE while the other signals FALSE, ensuring that no ambiguity arises from two wires asserting data simultaneously.
Analogy: A set of light switches controlling a room���s lights
: Imagine you have two light switches, one for "on" and one for "off." You can only flip one at a time���if both switches are flipped simultaneously, something���s wrong. This mutually exclusive relationship ensures the circuit maintains integrity, much like NCL uses exclusive assertion groups to ensure only one valid value (TRUE or FALSE) is signaled at any given time.
Hysteresis Gates
:
Gates with hysteresis provide
state memory
in circuits, enforcing the rule that gates continue asserting a DATA value until all inputs switch to NULL, and they only switch back to NULL when all inputs are NULL. This behavior allows for more stable and reliable transitions between states in an asynchronous environment.
Analogy: A door that only closes when everyone exits
: Imagine a room with a door that only shuts once everyone leaves. Until the last person exits (NULL state), the door remains open (DATA state). This ensures the room is either fully occupied or fully empty, much like hysteresis gates ensure all inputs are resolved before transitioning between NULL and DATA states.
Fault Monitoring
:
NCL circuits are self-monitoring. By ensuring that each output group only asserts one DATA value at a time, the system can detect faults or incomplete resolutions. If an illegal state occurs (such as multiple wires asserting DATA simultaneously), the circuit can signal an error.
Analogy: A security system that monitors exits
: Imagine a security system where only one person is allowed through a gate at a time. If more than one person tries to go through, an alarm goes off. Similarly, in NCL circuits, if multiple outputs assert data incorrectly, the system recognizes the error and signals it, ensuring reliability.
Practical Considerations:
While the
Intermediate Value solution
offers a theoretically complete and purely delay-insensitive system, it is often resource-heavy and impractical for commercial applications due to the additional circuitry and complexity. The
Feedback solution
, on the other hand, is more practical and economically feasible, offering an "effectively delay-insensitive" solution that balances robustness with efficiency.
Final Thoughts:
The text you've shared demonstrates the sophistication of NCL in designing circuits that do not rely on a clock signal, making them highly suitable for environments where timing unpredictability can cause issues. The feedback and intermediate value solutions provide alternative approaches to ensure that circuits can process data asynchronously while maintaining integrity, completeness, and fault tolerance.
If you���d like to delve further into specific aspects like dual-rail encoding, fault detection mechanisms, or how NCL compares to clocked logic systems in more detail, feel free to ask!
4o
Dijiste:
A fault will be detected as soon as it causes an actual resolution error. This holds for all single
point faults. It is possible for a NULL Convention Logic��� circuit to tell a lie but it requires two
coordinated faults that produce a valid encoding which is, nevertheless, erroneous.
Single data value NULL Convention Logic��� circuits are similar to neural nets as shown in
figure 18.
2
2
2
2
1
1
1
00
10
01
11 
A
B
C
S
1
2
3
4
5
6
7
8
9
10
1112
C
S
C_1
C_0
S_1
S_0
A
B
A_1
A_0
B_1
B_0
Figure 18. Similarity to neural nets.
The single data value NULL Convention Logic��� circuit in the middle performs the same
discrete symbolic processing as the Boolean circuit at the top, while at the same time being a more
complete and autonomous expression of the process than the Boolean logic circuit. The fully
connected neural net at the bottom, with an input layer, a hidden layer and an output layer can be
configured to identically match the NULL Convention Logic��� circuit by setting the thresholds of
each node and setting the weights of each connection appropriately to zero or one. The NULL
Convention Logic��� circuit might be viewed as a pretrained neural net .
�� 1997 Theseus Logic Inc. 20
4. The Asynchronous Register
To build a system out of NULL Convention combinational logic circuits we must be able to
manage the communication and interaction among its component circuits. There must be an
asynchronous register, as shown in figure 19, that monitors completeness of resolution as well as
readiness to accept new input data sets and stores the complete set of data values and the all NULL
values between circuits. Each combinational circuit will have an asynchronous register at its input.
collected
input
value set
combinational
expression
acknowledge
result
value 
set
r
e
g
i
s
t
e
acknowledge
presented 
values
a
s
n
c
h
r
o
y
n
o
u
s
r
Figure 19. The asynchronous register.
The asynchronous register shown in Figure 20 is simply a rank of NULL Convention Logic���
threshold gates with feedback hysteresis (Intermediate value gates won't work here) and a single gate
that watches for complete data sets and all NULL states. It will manage the interaction among
combinational circuits and is itself a very simple NULL Convention Logic��� circuit.
�� 1997 Theseus Logic Inc. 21
2
2
A_0
A_1
2
2
B_0
B_1
2
2
C_0
C_1
2
2
D_0
D_1
A_0
A_1
B_0
B_1
C_0
C_1
D_0
D_1
DACK
NACK
NULL 
convention
combinational
circuit
4
from next
to previous
Figure 20. The NULL Convention Logic��� asynchronous register.
Each register gate (the threshold 2 gates) receives one wire with a data meaning and one wire
with a control meaning. The threshold 4 gate is the watcher gate. When it sees a complete set of
DATA values it will assert DATA and when it sees all NULL values it transitions to asserting NULL.
When the watcher gate sees a complete data set, which in this case is one DATA value each for A, B,
C and D input groups, it means that a complete data set has been received and stored by the register
gates and it will transition its result value to DATA. The watcher gate will continue to assert the
DATA value until all of its input values are NULL, which means that the register gates have received
and stored all NULL values.
The control input for each register gate comes from the watcher of the next or downstream
register. When the next register has received and stored a DATA wave front playing through the
combinational circuit, it sends back a DATA acknowledge (DACK) that says "I have received and
stored the DATA wave front and now you can send the NULL wave front". This is conveyed by
transitioning the control line value to NULL. But the watcher transitions its result to DATA when it
sees a complete data set so an inverter is needed. The same is true for the reception of the NULL
wave front. When the watcher sees all NULL values it transitions its result value to NULL. This
means "I have received and stored the NULL wave front and now you can send a DATA wave front".
But to authorize a DATA wave front the control value must be DATA, so again the signal must be
inverted.
�� 1997 Theseus Logic Inc. 22
The control line requests the sending of a DATA wave front or a NULL wave front. The
register gates are feedback hysteresis gates that enforce the completeness of input for both DATA and
NULL. To pass DATA values, both inputs of a gate must be DATA. Therefore a DATA wave front
cannot pass the register gates until the control line is DATA, or in other words until the next register
has requested the data to be passed. When the control line becomes DATA, the DATA values
presented to the register gates will be passed and as long as the control line remains DATA the data
will be stored by the register gates. When a complete DATA set has been passed and stored by the
register gates the watcher gate will detect the complete DATA set and transition the control line to
the previous register to NULL, indicating that it has received and stored a DATA wave front and the
previous register can pass a NULL wave front.
Because of the hysteresis behavior of the register gates, they will not pass a NULL wave front
until both inputs are NULL. So when the NULL wave front arrives at the register gates and the
control line becomes NULL, the NULL values will be passed and stored as long as the control line is
remains NULL. After the NULL values are passed and stored, the watcher will detect the all NULL
value set and transition the control line to the previous register to DATA indicating that it has
received and stored the NULL wave front and the previous register can pass a DATA wave front.
The behavior of the asynchronous register is detailed in figure 21.
�� 1997 Theseus Logic Inc. 23
2
2
A_0
A_1
2
2
B_0
B_1
A_0
A_1
B_0
B_1
DACK
NACK
2
A
B
A
B
To Previous From Next
Arrival of NULL before arrival of request for NULL
Synchronization Register Behavior
DATA 
presented
DATA 
received
NULL 
requested
DATA 
requested
NULL 
presented
DATA 
maintained
NULL 
requested
DATA 
requested
2
2
2
2
DACK
NACK
2
A
B
A
B
To Previous From Next
DATA presented, requested and passed
Stable Stable
NULL 
wavefront 
is 
blocked
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
2
2
2
2
DACK
NACK
2
A
B
A
B
From Next
To 
Previous
NULL 
presented
NULL
detected
DATA 
requested
NULL 
requested
NULL requested from NEXT
2
2
2
2
DACK
NACK
2
A
B
A
B
From Next
To 
Previous
2
2
2
2
DACK
NACK
2
A
B
A
B
From Next
To 
Previous
NULL passed NULL detected and DATA 
requested from previous
Stable
NULL 
presented
NULL
passed
NULL 
requested
In
transition
NULL 
presented
NULL 
requested
In
transition
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
Figure 21a. Asynchronous register behavior.
�� 1997 Theseus Logic Inc. 24
Synchronization Register Behavior
2
2
2
2
DACK
NACK
2
A
B
A
B
From Next
To 
Previous
Arival of DATA before arrival of request for DATA
DATA 
presented
NULL
maintained
DATA
requested
NULL 
requested
Stable
DATA 
wavefront is 
blocked
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
2
2
2
2
DACK
NACK
2
A
B
A
B
From Next
To 
Previous
DATA 
presented
DATA
detected
NULL 
requested
DATA 
requested
DATA requested from NEXT
2
2
2
2
DACK
NACK
2
A
B
A
B
From Next
To 
Previous
DATA passed DATA detected and NULL 
requested from previous
Stable
DATA 
presented
DATA
passed
DATA 
requested
In
transition
DATA 
presented
DATA 
requested
In
transition
2
2
2
2
DACK
NACK
2
A
B
A
B
From Next
To 
Previous
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
Figure 21b. Asynchronous register behavior.
�� 1997 Theseus Logic Inc. 25
Synchronization Register Behavior
Arival of request for NULL before arrival of NULL
DATA 
presented
DATA
maintained
NULL
requested
NULL 
requested
Stable
2
2
2
2
DACK
NACK
2
A
B
A
B
From Next
To 
Previous
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
2
2
2
2
DACK
NACK
2
A
B
A
B
From Next
To 
Previous
NULL 
presented
NULL
detected
DATA 
requested
NULL 
requested
NULL arrives from previous
2
2
2
2
DACK
NACK
2
A
B
A
B
From Next
To 
Previous
2
2
2
2
DACK
NACK
2
A
B
A
B
From Next
To 
Previous
NULL passed NULL detected and DATA 
requested from previous
Stable
NULL 
presented
NULL
passed
NULL 
requested
In
transition
NULL 
presented
NULL 
requested
In
transition
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
Figure 21c. Asynchronous register behavior.
�� 1997 Theseus Logic Inc. 26
Synchronization Register Behavior
2
2
2
2
DACK
NACK
2
A
B
A
B
From Next
To 
Previous
Arival of request for DATA before arrival of 
DATA
NULL 
presented
NULL
maintained
DATA
requested
DATA 
requested
Stable
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
2
2
2
2
DACK
NACK
2
A
B
A
B
From Next
To 
Previous
DATA 
presented
DATA
detected
NULL 
requested
DATA 
requested
DATA arrives from 
previous
2
2
2
2
DACK
NACK
2
A
B
A
B
From Next
To 
Previous
DATA 
passed
DATA detected and 
NULL requested from 
previous
Stable
DATA 
presented
DATA
passed
DATA 
requested
In
transition
DATA 
presented
DATA 
requested
In
transition
2
2
2
2
DACK
NACK
2
A
B
A
B
From Next
To 
Previous
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
A_0
A_1
B_0
B_1
Figure 21d. Asynchronous register behavior.
�� 1997 Theseus Logic Inc. 27
ASYNCHRONOUS REGISTER SUMMARY
The asynchronous register manages the fully asynchronous flow of data wave fronts and
NULL wave fronts among NULL Convention Logic��� circuits. Passage of DATA or NULL through a
register occurs strictly after the request for DATA or NULL, and the detection of complete DATA or
all NULL state occurs strictly after the passage and storage of the DATA or NULL values. The
asynchronous registers and their behavior are fully delay insensitive and are purely symbolically
determined. There are no time dependency relationships whatever. With the asynchronous register 
a fully delay insensitive and purely symbolically determined system can be built .
STRUCTURES OF ASYNCHRONOUS REGISTERS
The interaction behavior among combinational circuits can be seen with the simple pipeline
example shown in Figure 22.
2
2
A_0
A_1
2
2
B_0
B_1
2
2
C_0
C_1
2
2
D_0
D_1
2
2
A_0
A_1
2
2
B_0
B_1
2
2
C_0
C_1
2
2
D_0
D_1
DACK
NACK
NULL 
convention
combinational
circuit
4
DACK
NACK
4
2
2
A_0
A_1
2
2
B_0
B_1
2
2
C_0
C_1
2
2
D_0
D_1
NULL 
convention
combinational
circuit
DACK
NACK
4
A_0
A_1
B_0
B_1
C_0
C_1
D_0
D_1
NULL 
convention
combinational
circuit
previous current next
Figure 22. NULL Convention asynchronous pipeline.
Assume that all the circuits are in a NULL state and that the current watcher and the next
watcher is requesting a DATA wave front and that the previous register is presenting a complete
DATA set to its combinational circuit. As the wave front propagates through the previous circuit to
the current register, the current register passes the data since its control line is DATA. When a
complete data set is recognized by the current watcher, the current watcher transitions its control line
to the previous register to NULL to indicate that it has received and stored the data wave front and
the previous register can pass a NULL wave front. The requested NULL wave front from the
�� 1997 Theseus Logic Inc. 28
previous register can arrive at the current register but, as long as its control line is DATA, the NULL
wave front will be blocked and the current register will maintain the presentation of the set of DATA
values to the current circuit. The control line for the current register will remain DATA until the
DATA wave front has propagated through the current circuit and has been received by the next
register. When the next register receives and stores the DATA wave front, the DATA set no longer
needs to be maintained by the current register. The next watcher detects the complete DATA set and
transitions its acknowledge line to NULL to indicate that it has the DATA wave front and the current
register can allow a NULL wave front through.
The registers and circuits can be configured in more complex structures than a simple pipeline.
Figure 23 shows a fan in configuration of circuits
DACK
NACK
DACK
NACK
DACK
NACK
DACK
NACK
2
2
1
Combinational
Circuit
Combinational
Circuit
Combinational
Circuit 2
1
1
Combinational
Circuit
2
2
2
3
Control To 
Previous
Control From
Next
Control To 
Previous
Control To 
Previous
Figure 23. Fan in configuration of registers and circuits.
In Figure 23 each threshold 2 gate represents a complete rank of register gates. In this
configuration three circuits present their results to a single circuit. The single circuit receives the
wave fronts from all three and does not signal completeness of DATA or completeness of NULL until
all three wave fronts are present and complete. It then sends the acknowledge to all three. The wave 
fronts of the three circuits are synchronized at the register of the single circuit .
�� 1997 Theseus Logic Inc. 29
DACK
NACK
2
1
Combinational
Circuit
Control To 
Previous
DACK
NACK
2
1
Combinational
Circuit
DACK
NACK
2
1
Combinational
Circuit
DACK
NACK
2
1
Combinational
Circuit
3
Control From
Next
Control From
Next
Control From
Next
Figure 24 Fan out configuration of registers and circuits.
Figure 24 shows a fan out configuration where a single circuit delivers its result values to three
circuits. Each of the three circuits receives the wave front individually and generates its own
acknowledge control signal. The threshold three gate collects the acknowledge signals. It does not
assert DATA until all three acknowledge inputs are DATA, meaning all three circuits have received a
complete DATA wave front, and it does not assert NULL until all three acknowledge inputs are
NULL, meaning that all three have received a complete NULL wave front. So the fanned out wave
front is synchronized by the threshold 3 gate.
�� 1997 Theseus Logic Inc. 30
THE SEQUENTIAL CIRCUIT
The next structure required to build a system is a sequential circuit. Figure 25 shows a
sequential circuit constructed with asynchronous registers and a combinational circuit.
2
2
A_0
A_1
2
2
B_0
B_1
2
2
2
2
4
2
2
A_0
A_1
2
2
B_0
B_1
2
2
2
2
DACK
NACK
NULL 
convention
combinational
circuit
4
DACK
DACK NACK
NACK
2
2
2
2
2
from next to previous
A_0
A_1
B_0
B_1
input
registe
r
output
registe
r
feedback
register
Figure 25. NULL Convention Logic��� sequential circuit.
The top four gates of the input register hold the inputs from the previous circuit. The top four
gates of the output register receive the result values for the next register. The bottom four gates of the
output register receive the internal state of the circuit and direct it back to the bottom four gates of the
input register through the intermediate register at the bottom of the circuit which buffers successive
DATA and NULL wave fronts from the output to the input of the circuit. The next DATA set
arriving at the top four gates is synchronized with the previous DATA set���s output arriving at the
bottom four input gates from the feedback register.
The sequential circuit is symbolically complete. The behavior of the circuit is purely
symbolically determined, the behavior of the asynchronous registers are purely symbolically
determined and their combination into a system structure is purely symbolically determined. There
is no external control authority. The circuit's behavior is driven completely by the DATA-NULL
input wave fronts and acknowledge signal interaction with its predecessor circuit and with its
successor circuit.
�� 1997 Theseus Logic Inc. 31
The basic elements to build a system ( combinational circuits, registers and sequential circuits)
have been demonstrated.
5. Some Adder Circuits
Next we show some adder circuits to demonstrate some advantages of NCL��� over previous
approaches to asynchronous circuits. To give a sense of the logic we begin with the Boolean logic
Minterm form of the full adder shown in figure 26.
Z_0
Z_1
Z X_0
X_1
Y_0
Y_1
Y
X
CI_0
CI_1
CI
CO_0
CO_1
CO
Figure 26. Minterm version of full adder.
This can be transformed directly into an asynchronous delay insensitive circuit by replacing
the AND gates with 3 input C-elements as shown in figure 27. This is a well known asynchronous
circuit called delay insensitive minterm synthesis or DIMS (8). What is not known is how to optimize
this circuit which is expressed partly in Boolean logic and partly in terms of C-elements.
�� 1997 Theseus Logic Inc. 32
C
C
C
C
C
C
C
C
C
C
X_0
X_1
Y_0
Y_1
Y
X
CI_0
CI_1
CI
Z_0
Z_1
Z
CO_0
CO_1
CO
Figure 27. Minterm version of full adder.
Because NCL��� is a uniform and consistent logic, the NCL��� version of the same DIMS circuit
can be optimized. Figure 28 is the NCL��� version of the DIMS full adder.
�� 1997 Theseus Logic Inc. 33
3
3
3
3
3
3
3
3
1
1
1
1
2
2
X_0
X_1
Y_0
Y_1
Y
X
CI_0
CI_1
CI
Z_0
Z_1
Z
CO_0
CO_1
CO
Figure 28. Minterm version of full adder.
The DIMS full adder counterpart can be optimized to the full adder circuit shown in figure 29
with expression transforms entirely within the context of NCL���.
2
2
Z
3
3
CO
X_0
X_1
Y_0
Y_1
Y
X
CI_0
CI_1
CI
Z_0
Z_1
CO_0
CO_1
Figure 29. The optimized full adder.
�� 1997 Theseus Logic Inc. 34
Full adder circuits can be combined in the evident way to form a ripple carry adder as shown
in figure 30.
2
2
3
3
111
000
111
000
2
2
3
3
111
000
111
000
2
2
3
3
111
000
111
000
���
���
���
2
2
3
3
111
000
111
000
X0
_0
X0
_1
Y0
X0
CI_0
CI_1
CI
Y0
_0
Y0
_1
X1
_0
X1
_1
Y1
X1
Y1
_0
Y1
_1
Xn-1_0
Xn-1_1
Yn-1
Xn-1
Yn-1_0
Yn-1_1
Xn
_0
Xn
_1
Yn
Xn
Yn
_0
Yn
_1
Z0
_0
Z0
_1
Z0
Z1
_0
Z1
_1
Z1
Zn-1_0
Zn-1_1
Zn-1
Zn
_0
Zn
_1
Zn
CO_0
CO_1
CO
Figure 30. Ripple carry adder circuit.
Figure 31 shows the ripple carry adder with an output asynchronous register.
�� 1997 Theseus Logic Inc. 35
2
2
3
3
111
000
111
000
2
2
3
3
111
000
111
000
2
2
3
3
111
000
111
000
���
���
���
2
2
3
3
111
000
111
000
2
2
2
2
2
2
2
2
2
2
DACK
NACK
3
DACK
NACK
���
���
���
X0
_0
X0
_1
Y0
X0
CI_0
CI_1
CI
Y0
_0
Y0
_1
X1
_0
X1
_1
Y1
X1
Y1
_0
Y1
_1
Xn-1_0
Xn-1_1
Yn-1
Xn-1
Yn-1_0
Yn-1_1
Xn
_0
Xn
_1
Yn
Xn
Yn
_0
Yn
_1
Z0
_0
Z0
_1
Z0
Z1
_0
Z1
_1
Z1
Zn-1_0
Zn-1_1
Zn-1
Zn
_0
Zn
_1
Zn
CO_0
CO_1
CO
Figure 31. Ripple carry adder with output asynchronous register.
The point to appreciate is that the output register is just another NCL��� combinational circuit.
There is no difference between the control expression of the circuit and the data processing aspect of
the circuit and, indeed, they can be optimized in combination. Figure 32 shows such an optimization
where the last rank of gates in the circuit are performing both the last stage of data processing and
registration.
�� 1997 Theseus Logic Inc. 36
Looking back to the circuit in Figure 30 we see that the last rank of full adder gates are also
hysteresis gates that maintain their state between wave fronts just like the asynchronous register
gates . Since the wave front state is maintained by the adder gates there is really no need for a
separate rank of gates just to maintain state (i.e. a separate asynchronous register). We can connect
the acknowledge line directly to the last rank of processing gates and integrate the asynchronous
registration function directly into the combinational circuit as shown in Figure 32.
With both input meanings and the acknowledge control signal going into the last rank of gates
their threshold must now be 4.
�� 1997 Theseus Logic Inc. 37
2
2
Z0
_0
Z0
_1
Z0
X0
_0
X0
_1
Y0
X0
CI_0
CI_1
CI
Y0
_0
Y0
_1
4
4
111
000
111
000
DACK
NACK
2
2
Z1
_0
Z1
_1
Z1
X1
_0
X1
_1
Y1
X1
Y1
_0
Y1
_1
4
4
111
000
111
000
2
2
Zn-1_0
Zn-1_1
Zn-1
Xn-1_0
Xn-1_1
Yn-1
Xn-1
Yn-1_0
Yn-1_1
4
4
111
000
111
000
���
���
���
2
2
Zn
_0
Zn
_1
Zn
Xn
_0
Xn
_1
Yn
Xn
Yn
_0
Yn
_1
4
4
111
000
111
000
CO_0
CO_1
CO
2
2
3
DACK
NACK
���
���
���
���
���
���
Figure 32. Ripple carry adder with embedded asynchronous register.
NULL Convention Logic��� expresses data processing and control identically and indeed the
expressional distinction between the two domains disappears. NULL Convention Logic��� is a
uniform, consistent and general language for the expression of asynchronous circuits and systems.
NCL��� delivers on the promises of asynchronous design where the traditional Boolean logic based
approaches have failed to deliver.
�� 1997 Theseus Logic Inc. 38
6. Summary
NULL Convention Logic��� conveniently and straightforwardly delivers all of the traditionally
expected benefits of asynchronous circuit design.
EASE OF DESIGN
NULL Convention Logic��� circuits are purely symbolically determined in that circuit behavior
depends solely on the interconnections among the gates. Delay insensitivity is inherent in the logic
itself. It does not depend on subtle and expensive circuit constructs. Consequently an NCL��� circuit
is a complete and autonomous expression in and of itself. It signals its own completion of processing
and also signals its readiness to accept new input data, without any appeal to an external expression
or authority such as a clock, delay line or controller. NCL��� circuits can be fully expressed in high
level languages without regard for timing issues and compiled to silicon in the same sense that high
level programs are compiled to machine instructions.
LOWER DESIGN COST AND RISK
The clock is eliminated with all its attendant design complexities and risks including clock
skew. The system can be designed in parts and then directly composed. There are no global
coordination issues as with synchronous systems.
LOWER POWER CONSUMPTION
Only portions of the system that are doing useful work consume power. Integrating logic
function and registration in a single gate reduces the power required for system control. There is no
spurious switching of transistors. The NULL state is an inherent and automatic power idle state. The
clock driving power is eliminated. NCL��� systems operate entirely in terms of synchronized wave
fronts of monotonic level transitions. There are no pulses or edge triggering involved in the circuit
behavior. The asynchronous nature of NULL Convention Logic��� circuits distributes the demand for
power.
CONVENIENT TECHNOLOGY MIGRATION
Because the logic is inherently delay insensitive it is insensitive to the behavior properties of
the physical implementation. NULL Convention Logic��� circuits are insensitive to changes in
implementation technology, to changes in scale, and to propagation delay changes due to aging or
manufacturing variations eliminating portability and evolvability issues.
�� 1997 Theseus Logic Inc. 39
AUTOMATIC ADAPTATION TO PHYSICAL PROPERTIES
The delays of the various circuit elements change differentially with the change in physical
parameters such as voltage, temperature, age, manufacturing variations and different
implementation environments. Since the circuits are delay insensitive, they will continue to operate
correctly over a large range of variation of these physical parameters.
RELIABILITY
All failure modes due to timing problems (race, hazards, skew, etc.) are eliminated. NCL���
provides advantages for design cost and risk, reliability of circuit performance and evolvability
beyond the barriers of complexity and feature size facing clocked Boolean logic.
TESTING
Testing complexity is reduced in that stuck-at-1 faults halt the circuit. Only stuck-at-0 faults
need to be exercised with applied patterns. Design time and risk as well as circuit testing
requirements are expected to be decreased because of the elimination of the complexity of the clock
with its critical timing issues.
SPEED OF OPERATION
NULL Convention Logic��� circuits are speed competitive even though they require two
propagation cycles per unit of processing. They will operate at the full rate the logic and material
allow and when appropriate will take advantage of average case propagation behavior. There are no
margins added onto worst case propagation delays as with clocked circuits. Integration of the
registration in logic gates allows more finely grained pipelining and consequently higher throughput
rates than convention clocked techniques.
Two value NULL Convention Logic��� preserves all the advantages of traditional Boolean
logic (two values, simple gates, straightforward synthesis) while, additionally, providing self
determined, locally autonomous, self synchronizing, delay insensitive, and fault detecting behavior.
Furthermore, NCL��� is compatible with the existing fabrication and design infrastructure and with
existing clocked systems allowing convenient low cost market entry
ChatGPT dijo:
ChatGPT
The detailed discussion you provided on
NULL Convention Logic��� (NCL���)
highlights several key concepts, including fault detection, asynchronous registers, the similarities to neural networks, and the advantages of NCL in various areas such as power consumption, reliability, and speed of operation. Here are some key takeaways and additional thoughts based on the content:
1.
Fault Detection in NCL Circuits
:
NCL circuits can detect faults as soon as they cause a resolution error, particularly
single-point faults
. However, it is possible for two coordinated faults to produce a valid but erroneous encoding that may not be immediately detected. This self-diagnosing nature of NCL circuits is a key strength.
Analogy: Security Checkpoints
: Imagine a security system where one faulty checkpoint might fail to detect a security breach, but if two faults occur in a coordinated manner, the system could still allow unauthorized access. NCL���s ability to detect errors at the earliest possible point helps maintain system integrity unless such rare, coordinated faults occur.
2.
NCL and Neural Networks
:
The comparison between
single data value NCL circuits
and
neural networks
is particularly intriguing. NCL circuits behave similarly to neural nets with layers, thresholds, and symbolic processing. The feedback mechanisms in NCL circuits allow them to maintain stability and correctness, much like how neural networks adjust weights to maintain certain outputs.
Analogy: Pretrained Neural Networks
: NCL circuits can be seen as
pretrained neural nets
with fixed weights and thresholds. Once designed, NCL gates "know" how to process inputs and produce outputs without further adjustment, much like a neural network trained to recognize certain patterns or classify data.
3.
Asynchronous Registers
:
The
asynchronous registers
play a crucial role in managing the flow of
DATA
and
NULL
wavefronts in NCL circuits. They ensure that combinational circuits interact smoothly without the need for external clocks, making the system fully asynchronous and delay insensitive.
Key Feature
: The
feedback hysteresis
behavior in these registers ensures that no new wavefront (DATA or NULL) passes through until the current set has been fully processed. This is akin to a "handshake" protocol where the current task is completed before the next begins.
4.
NCL in Complex Circuit Structures
:
NCL circuits can be scaled up and configured in complex ways such as
pipelines, fan-in, and fan-out structures
. The ability to manage multiple wavefronts and synchronize their completion or readiness using threshold gates allows for flexible system designs.
Fan-In
: In a
fan-in configuration
, multiple circuits present results to a single circuit, which doesn���t process the combined wavefront until all inputs are complete.
Fan-Out
: In a
fan-out configuration
, one circuit distributes results to multiple circuits, with the acknowledgment of wavefronts synchronized by a threshold gate. This ensures no partial data is propagated prematurely.
5.
Sequential Circuits
:
Sequential circuits in NCL are constructed from asynchronous registers and combinational circuits. These circuits handle feedback between output and input registers to maintain a
complete state between wavefronts
, ensuring that new input data is processed in sync with the previous output.
Symbolic Completeness
: The sequential circuit's behavior is entirely symbolically determined, driven by the input and output wavefronts, ensuring complete autonomy without external control, such as clocks.
6.
Advantages of NCL Over Clocked Circuits
:
NCL provides numerous advantages over traditional clocked circuits, particularly in the areas of design simplicity, power consumption, reliability, and speed of operation:
Lower Power Consumption
: Only parts of the system actively processing data consume power, and the clock driving power is eliminated. Additionally, the
NULL state
provides an inherent power idle state.
Reliability
: The elimination of timing-related failures (such as race conditions, hazards, and skew) improves the reliability of NCL circuits. The circuit���s ability to self-detect errors further contributes to this reliability.
Ease of Design
: NCL circuits eliminate the need for clock-based synchronization, reducing design complexity. They are symbolically complete, meaning they signal their readiness and completion autonomously.
Speed and Efficiency
: Despite the requirement of two propagation cycles per unit of processing (one for DATA and one for NULL), NCL circuits can operate at the full speed allowed by the material and logic, often taking advantage of average-case propagation times. This allows for more finely grained pipelining and potentially higher throughput.
7.
Compatibility and Scalability
:
NCL circuits are inherently
delay-insensitive
, making them suitable for different fabrication technologies and adaptable to changes in physical conditions (such as temperature, voltage, and aging). This ensures that circuits continue to operate reliably despite environmental changes or variations in manufacturing.
8.
NCL in Adder Circuits
:
The examples of
adder circuits
(such as ripple carry adders) demonstrate how NCL circuits can be optimized compared to traditional asynchronous designs like
DIMS
(Delay Insensitive Minterm Synthesis). NCL circuits allow for better optimization because they use consistent logic throughout, integrating both control and data processing into the same framework.
Embedded Asynchronous Registers
: In certain designs, asynchronous registers can be integrated directly into the final stage of data processing, eliminating the need for separate register gates and improving efficiency.
Summary of NCL���s Impact:
NULL Convention Logic��� offers a comprehensive solution for designing asynchronous, delay-insensitive circuits that are self-determined, self-synchronizing, and highly reliable. The symbolic completeness of NCL circuits simplifies design, reduces power consumption, and enhances scalability and adaptability across different environments. Additionally, the inherent fault detection mechanisms and the ability to integrate both logic and control into a uniform system make NCL a powerful alternative to traditional clocked systems.
If you want to explore more specific aspects of NCL or have questions about its application in modern computing systems, feel free to ask!
4o
Dijiste:
See if you can explain the parallels to a neural network in more detail
ChatGPT dijo:
ChatGPT
The parallels between
NULL Convention Logic��� (NCL���)
circuits and
neural networks
are quite fascinating, particularly when we delve into the structure and function of each system. Here's a detailed breakdown of how NCL circuits resemble neural networks, emphasizing concepts like threshold behavior, state persistence, and fault tolerance.
1.
Nodes and Thresholds
:
In both
NCL
circuits and
neural networks
, the basic building block is a
node
that processes input signals and produces an output. These nodes typically have thresholds that must be met before they generate an output.
In NCL circuits
, the gates are
threshold gates
. For example, a gate might only output a DATA value if a certain number of inputs are also DATA. This is similar to how a neuron in a neural network fires (produces an output) when the sum of its weighted inputs crosses a certain threshold.
In neural networks
, a node (or neuron) receives inputs that are weighted and summed. When the sum exceeds a predefined
activation threshold
, the neuron "fires" and passes the signal to the next layer. The threshold activation in neural nets is akin to how an NCL gate asserts a result only when the completeness of input criteria is satisfied.
Analogy
: Think of NCL gates like neurons in a neural network. Both wait for enough input signals to reach a certain threshold before "firing" and passing the information forward.
2.
Layered Architecture
:
Both NCL circuits and neural networks are structured in
layers
of interconnected nodes (gates in NCL, neurons in neural networks).
In NCL
, a circuit often consists of several layers of gates, where the output from one layer feeds into the inputs of the next. Each layer works synchronously in relation to the wavefront of DATA and NULL signals that propagate through the circuit. These gates process data based on symbolic completeness (when all inputs are ready), much like layers in a neural network process data after receiving enough activation from the previous layer.
In neural networks
, there are typically three main layers: an
input layer
,
hidden layers
, and an
output layer
. The input layer receives raw data, hidden layers process this data, and the output layer produces the final result. Each neuron���s output becomes input for neurons in the next layer.
Analogy
: Just as neurons in a neural network pass their output to the next layer, gates in an NCL circuit pass their results forward as part of a propagating wavefront. Both systems exhibit
layered propagation
, where computation flows from one stage to the next.
3.
Weights and Hysteresis
:
In
neural networks
, each connection between neurons has a
weight
, which determines the influence of one neuron on another. These weights are adjusted during the learning process to optimize the network's output. In
NCL circuits
, there is no concept of learning or weight adjustment, but there is a parallel in how
feedback and hysteresis
work in the gates.
In NCL
, feedback with
hysteresis
ensures that once a gate asserts a result (e.g., DATA or NULL), it remains in that state until a complete new wavefront arrives to reset the gate. This is conceptually similar to how a neuron, once fired, may have a refractory period during which it cannot immediately fire again. This feedback ensures stability in NCL circuits, much like weights in a neural network determine the output stability.
In neural networks
, the weight of connections determines how strongly one neuron influences another. While weights are adjustable in a neural network (especially during training), in NCL, the feedback mechanism ensures that the gate���s state persists until it's logically appropriate to change. This feedback is fixed and deterministic, unlike the flexible weights in neural nets.
Analogy
: In NCL, the persistence of state due to feedback is akin to how neural network weights control signal strength. Both are designed to stabilize the system���s output until new data is processed, although NCL does this in a fixed manner and neural networks adjust weights through training.
4.
Activation Functions and Symbolic Resolution
:
In neural networks, neurons often use
activation functions
(like sigmoid, ReLU, or softmax) to determine how the output should be transformed based on input values. NCL gates similarly follow a symbolic process that determines how to resolve the inputs into a valid output.
In NCL
, gates process inputs based on logical rules that depend on symbolic completeness. For example, a gate will only assert a data value if all inputs meet a threshold condition. This is somewhat analogous to how an activation function transforms a neuron���s inputs into an output.
In neural networks
, an activation function takes the weighted sum of inputs and applies a non-linear transformation to produce the output. This transformation is designed to enable the network to learn complex patterns from the data.
Analogy
: NCL���s symbolic resolution behavior, which ensures correct output based on input thresholds, mirrors how activation functions in neural networks transform inputs into useful outputs. Both serve to control how information flows and how the system reaches a decision based on its inputs.
5.
Fault Tolerance
:
NCL circuits and neural networks share a form of
fault tolerance
, although the mechanisms differ. In neural networks, individual neurons or connections can fail, but the network as a whole can still function because of its redundant and distributed architecture.
In NCL circuits
, a single point of failure can halt the system, but detecting errors is straightforward. However, the presence of
dual-rail encoding
(where two wires represent each data value, and only one can be active at a time) ensures that faults like "stuck-at-1" or "stuck-at-0" can be easily identified. More importantly, two coordinated faults are required to produce a valid but erroneous output, making it harder for NCL circuits to produce undetected errors.
In neural networks
, even if some neurons malfunction or some weights are incorrect, the network can still produce a valid output, thanks to the redundancy of the connections and layers.
Analogy
: In both systems,
fault tolerance
is critical. NCL circuits use redundancy (such as dual-rail encoding) to detect faults early, while neural networks rely on distributed processing across many neurons to prevent individual faults from derailing the entire system.
6.
Learning vs. Predefined Behavior
:
One major difference is that
neural networks can learn
, whereas
NCL circuits are deterministic and fixed
in their behavior.
Neural networks
adjust their weights and thresholds during training to improve performance on tasks. This dynamic learning process allows them to handle a wide variety of tasks, from pattern recognition to decision-making.
NCL circuits
, by contrast, do not learn. Once they are designed, their gates are "hardcoded" to respond to specific inputs in specific ways. In a sense, NCL circuits behave like a
pretrained neural network
that has already "learned" the exact responses it needs to output, and it carries out this behavior deterministically.
Analogy
: NCL circuits are like a neural network that has already been trained and has frozen weights and thresholds. Both systems can execute tasks autonomously and fault-tolerantly, but NCL circuits do so with predefined, non-adaptive logic, while neural networks can adapt and evolve.
7.
Propagation of Data
:
In both systems,
data flows from one stage to the next
, and only after the necessary conditions are met in each layer does the next stage begin its processing.
In NCL
, the propagation of
DATA wavefronts
and
NULL wavefronts
through gates is analogous to how information propagates through the layers of a neural network. Once a gate in NCL reaches symbolic completeness, it sends the resolved data forward, much like how a neuron fires once it meets its activation threshold.
In neural networks
, information flows layer by layer, where each layer waits for the activation of the previous one before it begins processing.
Analogy
: The wavefronts in NCL are similar to the
feedforward
nature of neural networks. Both systems ensure that data moves through the network in a controlled, stage-by-stage process.
Conclusion:
The
parallels between NCL circuits and neural networks
lie in their use of threshold-based decision-making, layered structures, state persistence, and the propagation of information through interconnected nodes. While NCL circuits are deterministic, predesigned, and non-learning systems, they share structural and functional similarities with neural networks in terms of how they process data. Both systems use a form of threshold activation to move data from one layer to the next, ensuring correctness and robustness. However, the key difference remains that neural networks can learn and adapt, whereas NCL circuits are fixed but offer highly reliable, fault-tolerant computation.
If you'd like to explore any specific aspect of this parallel further, or want to see how it applies to practical NCL or neural network designs, feel free to ask!
4o
Dijiste:
A list of everything we've talked about so far.
ChatGPT dijo:
ChatGPT
Here's a comprehensive list of everything we've covered in our conversation so far:
NULL Convention Logic (NCL) and Related Concepts:
Introduction to NULL Convention Logic (NCL):
NCL as a symbolically complete logic.
Difference between NCL and traditional Boolean logic.
Delay-insensitivity in NCL.
Elimination of the need for external control like clocks.
NCL���s use of DATA and NULL wavefronts for process control.
Symbolic Completeness in NCL:
Symbolic-value-dependent relationships.
No need for time-dependent relationships.
NCL circuits express both data transformation and control within the logic itself.
Muller C-elements and delay-insensitive circuit design.
NULL and DATA Wavefronts:
NULL wavefront as a reset mechanism.
DATA wavefront for actual data propagation.
Importance of the NULL-DATA cycle for maintaining delay-insensitivity and correctness.
NULL Cycle Reduction (NCR):
Speedup of NCL circuits using NCR.
Parallel processing of NULL and DATA wavefronts.
Demultiplexing and multiplexing of wavefronts for increased throughput.
Completeness of Input Criteria:
NCL gates only output valid data when all inputs are valid.
Similarity to checking readiness before performing new operations.
Example of how NCL gates propagate data in an orderly wavefront fashion.
Intermediate Value Solution in NCL:
Addition of an intermediate value for resolving transitions.
Four-value logic system with intermediate states (T, F, NULL, and Intermediate).
Ensuring that gates transition completely and correctly between states.
Feedback Solution in NCL:
Use of feedback in gates for hysteresis behavior.
Ensures gates maintain state until complete input sets are received.
A non-critical timing relationship ensures gates can process data independently of propagation delays.
Transition to Two-Value NCL System:
Dual-rail encoding for expressing True and False with two wires.
Maintaining mutual exclusivity of data assertions.
Simplification of NCL gates to two-value logic without losing delay-insensitivity.
Fault Detection and Tolerance in NCL:
NCL circuits detect single-point faults when resolution errors occur.
More complex, coordinated faults can cause undetected errors.
Dual-rail encoding aids fault detection.
Parallels and Analogies to Other Systems:
Analogy to Education and Learning Prerequisites:
NULL wavefronts act like ���knowledge checks��� or prerequisites before progressing to the next computation.
Comparison to Markov Processes:
NULL wavefronts create a boundary between states, similar to a Markov boundary separating different phases in a stochastic process.
Analogies to Real-World Systems:
NULL wavefront compared to a
Do Not Disturb
sign (pause mechanism).
Driver's license
as a readiness signal, similar to how NULL indicates a reset.
University degree
as a completion marker before moving to the next stage.
Git commit message
representing a "safe" point before further changes, like the NULL state preparing a system for the next data wave.
Symbolic Computation and Related Concepts:
Infectious NA/NULL in SymPy:
Similarity between NA values in symbolic math and NULL in NCL, where both propagate incomplete or invalid states through computations.
Rational Numbers and Precision:
Storing rational numbers (e.g.,
1
3
\frac{1}{3}
3
1
���
) without premature conversion to floats parallels how NCL processes complete data sets, avoiding premature evaluations.
Lazy Evaluation and Iterators:
Lazy evaluation in programming (delaying execution until needed) parallels NCL's delay-insensitive approach where processing only occurs once all inputs are ready.
Neural Network Comparison:
Similarities Between NCL Circuits and Neural Networks:
NCL circuits resemble neural networks with layers, thresholds, and propagation.
Gates in NCL work like neurons, waiting for input thresholds to be met before "firing."
Feedback in NCL circuits, like weights in neural networks, stabilizes system output.
Layered architecture in both NCL and neural nets allows for structured, sequential processing of information.
Activation functions in neural nets have parallels to the symbolic resolution of NCL gates.
Fault tolerance in NCL and redundancy in neural networks ensure robust operation even with partial failures.
Asynchronous Registers and Circuit Interaction:
Asynchronous Registers in NCL:
Registers manage wavefronts of DATA and NULL in fully asynchronous fashion.
Feedback hysteresis ensures completeness of inputs before processing.
Use of registers in more complex circuit structures (e.g., pipeline, fan-in, fan-out configurations).
Pipeline, Fan-In, and Fan-Out Circuit Designs:
Synchronizing multiple circuits with asynchronous registers.
Use of watcher gates and threshold logic for controlling data flow between circuits.
Sequential Circuits in NCL:
Building sequential circuits using NCL gates and asynchronous registers.
Handling feedback and synchronization between different stages of the circuit.
Practical Applications and Advantages of NCL:
Adder Circuits in NCL:
Example of adder circuits built using NCL.
Optimizations compared to traditional asynchronous designs like DIMS (Delay Insensitive Minterm Synthesis).
Combining logic processing and asynchronous registration in a unified system.
Advantages of NCL over Clocked Circuits:
Elimination of global clock and related complexity (e.g., clock skew).
Lower power consumption (only active components consume power).
Reliability and fault tolerance (insensitive to timing variations, environmental factors).
Ease of design (symbolic completeness means circuits can signal readiness and completion autonomously).
Convenient migration between technologies (delay-insensitive nature ensures robustness across different implementation environments).
Potential for higher throughput due to finer-grained pipelining.
This is an extensive list covering the various aspects of
NULL Convention Logic (NCL)
, symbolic computation, neural network parallels, and real-world analogies that we���ve discussed so far. Let me know if you'd like to explore any topic in more depth!
4o
Dijiste:
you should be able to swap out function generators with different implementations without affecting the logic.
ChatGPT dijo:
ChatGPT
Yes, you're absolutely right! The modularity and
delay-insensitive
nature of
NULL Convention Logic��� (NCL���)
make it possible to swap out
function generators
(or individual components like gates or circuit blocks) with different implementations, without affecting the overall behavior or correctness of the circuit. This is because NCL focuses on
symbolic completeness
and is inherently
time-independent
, ensuring that the logic operates correctly regardless of the specific implementation details of individual components.
Here���s how that works in more detail:
1.
Function Generators and Logic Implementation:
In traditional synchronous circuits, the precise timing of signals is often crucial, as function generators (combinational logic units that generate outputs based on inputs) must be aligned with a clock signal. Any changes in the underlying implementation could introduce
timing issues
, potentially causing race conditions, hazards, or clock skew.
In NCL, however:
The
completeness of input criteria
ensures that each gate only processes data when it receives all valid inputs, regardless of when those inputs arrive.
Null-DATA wavefronts
control when new data can be accepted, meaning each stage of the circuit can wait for completion before proceeding to the next.
This allows for
functional independence
between components. Whether a function generator is implemented as a series of basic gates, a lookup table, or a more complex circuit, as long as it adheres to NCL���s symbolic rules (proper handling of NULL and DATA states), the higher-level logic will remain unaffected.
2.
Swappable Components:
In NCL systems, you can swap out function generators with different implementations because:
Delay-insensitivity
decouples timing from logical correctness, so different implementations of the same logic function (e.g., an adder or a multiplexer) won���t affect the overall flow.
As long as the function generator
correctly follows NCL conventions
���ensuring valid input and output relationships (i.e., waits for complete inputs before generating outputs)���it can be replaced by an optimized, customized, or alternative design without impacting the broader system.
3.
Example of Swapping Function Generators:
Imagine an NCL-based
adder
circuit. The underlying function generator might be implemented using a specific gate structure, such as threshold gates that combine inputs to produce sum and carry outputs.
Swap to a different implementation
: If you replace the adder���s internal function generator with a
lookup table
implementation or a more optimized logic block, as long as the inputs are processed in accordance with NCL���s completeness rules (waiting for all inputs to be valid), the new implementation would seamlessly integrate into the circuit without disrupting its operation.
This modularity is beneficial for several reasons:
Flexibility in Design
: Designers can experiment with different implementations to optimize for speed, power efficiency, or area without worrying about breaking the logical integrity of the system.
Technology Migration
: As different fabrication technologies evolve, the logic can be migrated across platforms while the same symbolic rules govern how the components interact.
Customization and Optimization
: You can introduce optimizations at the component level (e.g., an optimized adder for low power) while maintaining overall system behavior.
4.
Function Independence in Neural Networks Analogy:
This concept is similar to
neural networks
, where different layers or neurons might have different activation functions (e.g., ReLU, sigmoid, tanh), but the overall network behavior remains functionally correct. Swapping activation functions or adjusting the architecture of individual neurons doesn���t disrupt the network as long as the fundamental data propagation principles are maintained.
5.
Practical Application in Asynchronous Design:
In asynchronous designs, this ability to swap out function generators is particularly valuable. For example:
In
NCL pipelines
, different function generators can be replaced or optimized without affecting how wavefronts of DATA and NULL move through the system.
Fan-in
and
Fan-out
structures (where multiple circuits interact) can still function seamlessly with different underlying logic implementations for each circuit as long as the symbolic flow of NULL and DATA is respected.
Conclusion:
Swapping out function generators in an NCL system without affecting the logic is possible because NCL circuits are inherently
delay-insensitive
and
symbolically complete
. As long as the replaced component adheres to NCL's symbolic input-output rules (completeness of input, proper transition between NULL and DATA), the implementation of the logic can vary without disrupting the overall operation. This makes NCL highly modular, adaptable, and robust to design changes.
2/2
4o
Dijiste:
Can you come up with a simplified exercise a group of people could do to simulate a null convention logic circuit?
ChatGPT dijo:
ChatGPT
Certainly! Here's a
simplified group exercise
designed to simulate the behavior of a
NULL Convention Logic (NCL)
circuit. This exercise will help participants understand how
NULL-DATA wavefronts
work, how gates operate based on
completeness of input
, and how asynchronous data flow happens in NCL systems.
Objective:
Participants will act as components of a NULL Convention Logic circuit, passing signals between each other in an asynchronous manner. The goal is to simulate how a circuit resolves data only when all inputs are valid and resets to a NULL state before accepting new data.
Setup:
You'll need at least
6-10 participants
to simulate a simple
NCL pipeline
with two stages.
Materials:
Index cards
(or slips of paper) marked as:
DATA
(one color for valid data, like green cards)
NULL
(another color for invalid data, like red cards)
Complete
(optional, if needed for certain stages to signal readiness)
Labels
(for participants):
Participants act as
gates
or
combinational circuits
in the system.
Designate 4 participants as
Input Gates
(A, B, C, D) who will feed data into the system.
Designate 2 participants as
Internal Gates
(who will combine data from the inputs).
Designate 1 or 2 participants as
Watcher Gates
, who monitor the completion of data resolution in a stage.
Rules (representing NCL operations):
Input Gates
(A, B, C, D) can only pass a
DATA card
forward if they have valid data from another participant (or external source).
If they don���t have valid data (i.e., they receive NULL or are not ready), they must pass a
NULL card
.
Internal Gates
(combinational logic) require
two valid DATA cards
to produce an output.
If either input is
NULL
, the output must be
NULL
.
If both inputs are
DATA
, the output is also
DATA
.
Watcher Gates
monitor the outputs of internal gates and declare whether the entire stage is complete.
If all outputs from the internal gates are DATA, the Watcher Gate announces ���Complete!��� and signals readiness for the next stage.
If any output is NULL, the Watcher Gate signals ���Incomplete��� and waits for all inputs to resolve.
Once the
Watcher Gate
signals "Complete," the next stage can begin.
A reset to
NULL state
must occur before new data can flow. The system cannot process new data until all inputs return to NULL (representing the NULL wavefront).
Exercise Steps:
1. Simulation Start:
Begin by handing out random
DATA
and
NULL cards
to the Input Gates (A, B, C, D). These gates represent the initial inputs of a small combinational circuit.
Each Input Gate must then decide whether to pass forward a
DATA
card or a
NULL
card, depending on what they have.
2. Data Propagation:
Internal Gates (the next participants in the chain) receive inputs from two Input Gates.
Example: Gate 1 gets inputs from
A and B
, Gate 2 from
C and D
.
If either input is NULL, they must output NULL.
If both inputs are DATA, they output DATA.
3. Monitoring by Watcher Gate:
The Watcher Gate monitors the output of the internal gates.
If both internal gates output DATA, the Watcher Gate announces ���Complete!���
If either internal gate outputs NULL, the Watcher Gate says, ���Incomplete.���
4. Reset (NULL Cycle):
After a "Complete" signal, the system must reset to NULL. All gates receive
NULL cards
, ensuring the system returns to a clean state before new data enters.
5. Repetition:
The process repeats as new DATA and NULL cards are introduced at the input gates after each cycle.
The objective is to keep the system functioning by ensuring that no new data enters until the previous wave of NULL has reset the system.
Key Concepts Reinforced:
Completeness of Input
: Each gate operates only when all its inputs are valid (i.e., all input cards are DATA).
NULL-DATA Cycle
: The system must reset to NULL before new data can be processed, mimicking the alternating NULL-DATA wavefronts in NCL circuits.
Asynchronous Data Flow
: There���s no global clock. Participants (gates) pass information asynchronously, reacting only when their inputs are valid.
Optional Variations:
Add More Stages
: Introduce more participants in a pipeline setup, where the output of one group becomes the input of another.
Fan-In/Fan-Out Configuration
: Simulate more complex circuits by introducing fan-in (multiple inputs combined into one output) or fan-out (one input split into multiple outputs).
Debrief:
After the exercise, discuss how the behavior of participants as gates in the NCL circuit mimics the way real circuits process information without clocks. Highlight the role of the
NULL-DATA cycle
, the importance of
completeness of input
, and how the system prevents errors by waiting for full data readiness before processing.
This exercise offers a hands-on way to understand how NCL circuits work asynchronously and how they maintain reliability through symbolic completeness and delay-insensitive behavior.
4o
Dijiste:
ok how about something more mechanical that requires different stages
ChatGPT dijo:
ChatGPT
Certainly! Here's an idea for a
mechanical group exercise
that simulates a
NULL Convention Logic��� (NCL���) circuit
and incorporates different stages, while still conveying key NCL concepts like
NULL-DATA wavefronts
,
completeness of input
, and
asynchronous processing
.
Objective:
Participants simulate an NCL circuit by passing
physical tokens
through different stages of the process. Each stage must wait for all inputs to be ready before moving to the next, and the system must reset between cycles. This mechanical setup will simulate the asynchronous and delay-insensitive behavior of an NCL system.
Setup:
Participants
: At least 8���12 people.
Physical Tokens
: Use
balls
,
blocks
, or other small objects to represent data. You���ll need two types:
Green tokens
(represent DATA).
Red tokens
(represent NULL).
Workstations
: Set up different
stations
that participants will act as, representing NCL gates or stages in the system.
Exercise Overview:
Participants are divided into teams working at different
stations
. Each team represents a specific stage in an NCL circuit. The stations pass tokens (DATA or NULL) forward once all inputs are complete, and the system must reset to NULL before a new DATA cycle begins. The exercise will progress through several stages that mirror the behavior of an NCL pipeline.
Roles and Stations:
1.
Input Station (Stage 1)
Participants
: 2 people.
Task
: Input participants are responsible for feeding tokens into the system. They each have two baskets, one with
green tokens
(DATA) and one with
red tokens
(NULL).
Goal
: Pass green or red tokens to the next stage depending on system readiness (monitored by the Watcher).
2.
Combination Station (Stage 2)
Participants
: 2 people.
Task
: Participants here combine inputs from the Input Station (Stage 1).
Mechanics
: The combination station has two participants, each receiving a token from one Input participant. The rule is that only when both participants receive
green tokens
(DATA) can they pass the green tokens forward. If either one gets a
red token
(NULL), they must pass a red token forward.
Goal
: Produce a valid output only when both inputs are green (DATA).
3.
Processing Station (Stage 3)
Participants
: 2 people.
Task
: At this stage, the participants again receive two inputs from the Combination Station. They must wait for both inputs to be
green tokens (DATA)
before passing the tokens forward. If either input is a
red token
(NULL), they pass red tokens forward.
Goal
: The station processes and passes tokens forward only if both inputs are DATA.
4.
Watcher Station (Stage 4)
Participants
: 1 or 2 people.
Task
: The Watcher monitors the output from the Processing Station. If the Watcher sees that
all outputs are DATA
(green tokens), they declare ���Complete��� and allow the system to reset to NULL. If any token is
NULL
(red), they declare ���Incomplete.���
Goal
: Signal the completion or incompleteness of the entire system���s cycle.
5.
Reset Station (Optional)
Participants
: 1 person (can be part of Watcher role).
Task
: After the Watcher signals completion, this person initiates the reset process by sending
NULL tokens
(red) back through the system, ensuring every station is returned to NULL before a new data cycle can start.
Exercise Flow:
Stage 1: Input Station (Start)
:
The two input participants (Stage 1) each pass a token (green or red) to the combination participants (Stage 2).
Tokens represent
DATA
(green) or
NULL
(red).
Only when both participants at the input station pass
green tokens
will the next stage receive
green tokens
.
Stage 2: Combination Station
:
Participants at Stage 2 combine their inputs. They can only pass
green tokens (DATA)
forward if both inputs are
green
.
If either input is a
red token (NULL)
, they pass a
red token (NULL)
forward.
This simulates the
completeness of input
in NCL.
Stage 3: Processing Station
:
The Processing Station behaves similarly, waiting for both inputs to be
green
before passing green tokens forward. If one input is
red
, they pass a red token.
Stage 4: Watcher Station
:
The Watcher receives the tokens from the Processing Station. If both tokens are
green
, they declare the circuit���s operation as ���Complete��� and signal readiness for a reset. If either token is red, they declare the circuit as ���Incomplete��� and the system waits until all inputs are DATA.
Goal
: The Watcher monitors the system and ensures a valid state is achieved before moving forward.
Reset Process
:
After the system completes, the Watcher or Reset Station passes
red tokens (NULL)
back through all stages, ensuring all stations are reset before the next cycle begins.
Repeat
:
After the reset, the system starts again, with new tokens flowing through each stage. The participants at each station repeat their roles based on the inputs they receive.
Key Concepts Reinforced:
Asynchronous Behavior
:
Each station works independently and waits for the right conditions (complete DATA) before passing tokens forward.
NULL-DATA Cycle
:
The system must complete a
NULL cycle
(reset) before processing new data, mimicking the reset to NULL in NCL circuits.
Completeness of Input
:
Each stage must wait for
both inputs
to be valid (DATA) before generating a valid output, just like NCL gates only resolve when all inputs are present.
Watcher Role
:
The Watcher station simulates the monitoring function in NCL circuits, ensuring that each stage is ready before progressing to the next step.
Optional Enhancements:
More Complex Stages
: Introduce additional stages that require
three
or more inputs to simulate more complex gates.
Parallel Stations
: Add parallel stations (simulating fan-out) that split the data into multiple streams, all of which must be processed before completion.
Debrief:
Once the exercise is complete, discuss how the mechanical process simulates the workings of a
NULL Convention Logic
circuit. Highlight the importance of the
completeness of input
, the asynchronous nature of data flow, and how the system handles the
NULL-DATA cycle
to ensure proper operation.
This physical simulation is a hands-on way to grasp the fundamental concepts of NCL and how it enables reliable and delay-insensitive circuit design.
4o
Dijiste:
It is interesting but I was thinking maybe more like a group of people making a lego sculpture where they put up a flag when they have a completed part
ChatGPT dijo:
ChatGPT
Ah, I see! You're thinking about an activity where participants simulate an
NCL circuit
in a way that is both physical and collaborative, like building a Lego sculpture, where each person or group contributes a "completed part" when ready. This approach works well to simulate the idea of asynchronous operation and symbolic completeness in
NULL Convention Logic
(NCL).
Here���s how you could organize such an activity, simulating an NCL circuit using Lego construction and flags to represent readiness and symbolic completion:
Objective:
Participants work together to build different parts of a Lego sculpture. They can only pass their completed sections forward when all required pieces are ready, simulating the behavior of an NCL circuit where each stage must wait for
completeness of input
before moving forward. A flag system is used to indicate when a part is complete and ready for the next stage.
Materials:
Lego bricks
(enough for multiple parts of a small sculpture, e.g., a house, car, or tower).
Colored flags
or small signs:
Green flag
: to signal a completed and valid part (representing
DATA
).
Red flag
: to signal an incomplete or reset state (representing
NULL
).
Building instructions
(either a simple predefined structure or abstract instructions to guide participants).
Setup:
Participants
: Divide participants into
teams
of 2-4 people. Each team represents a different "gate" or "stage" of the NCL circuit. The teams will pass completed parts to the next group when their part is finished.
Stations
: Each team has a specific
station
where they work on a different part of the Lego structure. Teams must complete their part and signal completion before the next team can continue.
Exercise Flow:
1.
Stage 1: Starting the Build
The first team is given instructions on building a foundational part of the Lego sculpture, such as the base of a house or vehicle.
This team starts the construction but must signal readiness by raising a
green flag
only when their part is fully completed.
If their part is incomplete, they raise a
red flag
to show that they are not yet ready (representing the
NULL state
in NCL).
2.
Stage 2: Passing to the Next Group
The second team waits for the first team to finish their part. They can only start building when the first team raises the
green flag
(indicating completion, like receiving a
DATA wavefront
).
The second team���s task is to build an additional part of the structure, such as adding walls to the foundation. They can only begin once the first team is complete.
They must also raise their
green flag
when their part is done.
3.
Intermediate Stages: Further Assembly
This process continues through all the teams, with each group constructing a part of the sculpture, such as adding windows, doors, or other components. Each team can only begin after the previous team has signaled that their section is complete with a green flag.
If any team raises a red flag
, no further work can proceed until the incomplete part is finished, mimicking how NCL gates wait for full input completeness.
4.
Watcher Station: Monitoring Completion
One person or team acts as a
Watcher
(like the
Watcher Gate
in NCL). They monitor all teams and ensure that all parts of the sculpture are complete.
When the final part is completed and the last team raises their
green flag
, the Watcher announces that the sculpture is fully built (indicating that all gates have resolved their inputs).
5.
Reset (NULL Cycle)
After the sculpture is complete, the system must reset for a new build (like the
NULL wavefront
in NCL resetting the circuit).
The Watcher signals the start of the reset by having each team lower their green flag and raise a
red flag
. This indicates that all parts are being reset to the NULL state, ready to start the next cycle.
After the reset is acknowledged by all teams, the next round of building can begin, simulating a new data wavefront entering the circuit.
Key Concepts Reinforced:
Completeness of Input (Dependency)
:
Each team must wait for the previous team to complete their part before starting, similar to how NCL gates wait for all inputs to be ready before processing data.
NULL-DATA Cycle
:
The flag system (green for complete, red for incomplete or reset) simulates the
NULL-DATA wavefront
in NCL. The system must reset to a NULL state before accepting new inputs.
Asynchronous Behavior
:
There���s no central timing mechanism or clock. Teams work asynchronously, starting their task only when they receive a complete part from the previous team.
Watcher���s Role
:
The Watcher monitors the overall progress, making sure no team moves forward until all stages are complete. This mirrors the role of a Watcher Gate in NCL, ensuring that the system only proceeds when all inputs are resolved.
Fault Tolerance
:
If a team raises a red flag (representing incomplete work), it mimics a fault or unresolved input in an NCL circuit. The system halts until the issue is resolved, preventing errors from propagating.
Optional Variations:
Parallel Assembly
:
For more complexity, have two groups working on different sections simultaneously (representing
parallel processes
in NCL circuits). They must both raise their green flags before proceeding to the next stage.
More Complex Structures
:
Use more complicated Lego structures or multi-step instructions that require careful coordination between groups. For example, different teams might build different floors of a multi-story building, and all must be completed before the roof can be added.
Fault Injection
:
Introduce a scenario where one team makes a mistake (a deliberate fault). Discuss how this delays the system and mirrors how faults in NCL circuits can prevent data from propagating correctly until resolved.
Debrief:
After the exercise, discuss how this mechanical process simulates the behavior of a
NULL Convention Logic
circuit. Talk about how the flag system represents
NULL-DATA wavefronts
, how the teams simulate
gates waiting for complete inputs
, and how the Watcher ensures correctness.
You can also ask questions like:
How did waiting for completeness feel compared to working in a synchronous (timed) manner?
What were the challenges of waiting for the previous group before starting your task?
How might this parallel real-world circuit design and logic processing?
This exercise offers a fun and engaging way to physically simulate the core principles of NCL, helping participants better understand asynchronous behavior, symbolic completeness, and the importance of maintaining orderly processing.
4o
Dijiste:
Presentation Slides
Chapter 12
Ring Behavior
Logically Determined Design:
Clockless System Design With NULL Convention Logic
by Karl Fant
John Wiley & Sons, Inc.
Diagrams by permission of John Wiley & Sons, Inc.
Introduces the modes of pipeline ring behavior
Bubble path
Acknowledge path,
reverse latency
Wavefront path
Data path,
forward latency
Ring structures
Cycle path
2
2
1
2
2
1
2
2
1
2
2
1
2
2
1
2
2
1
2
2
1
2
2
1
2
2
1
2
2
1
2
2
1
2
2
1
Page 2
Behavior Rationale
The referents are:
the period of the slowest cycle in the ring (the total delay of the cycle path ),
wavefront rejoin period (the total delay of the wavefront path ),
 bubble rejoin period (the total delay of the bubble path),
the wavefront population period of (number of wavefronts times slowest cycle period) and
the bubble population period of (number of bubbles times slowest cycle period).
Each member of a population chases its population around the ring. The critical question is whether
a member ever catches up with its population or not. This is determined by whether a population
can propagate through the slowest cycle (population period) before a member can propagate around
the ring and rejoin the population (rejoin period).
If a member does not catch up with its population it encounters no waits on its journey around
the ring, therefore, its propagation time around the ring (rejoin period) is determined solely by
the delays along its propagation path.
Page 3
1 1 tic 2 3 tics
Cycle path. Period is 7 tics
2
2
1
2
2
1
3
3
1
Wavefront path segment. Delay per cycle is 3 tics
2
2
1
2
2
1
3
2
2
1
2
2
1
3
1
Bubble path segment. Delay per cycle is 4 tics
Bubble rejoin period
for a 24 cycle ring is
24 X 4 tics = 96 tics
Wavefront rejoin period
for a 24 cycle ring is
24 X 3 tics = 72 tics
Example Behavior Periods
Wavefront population period
# wavefronts X 7 tics
Bubble population period
# bubbles X 7 tics
For a 24 cycle ring
wavefronts + bubbles = 24
Page 4
Bubble limited
If the bubble rejoin period is greater than the bubble population period then bubbles will not catch
up with their population. The slowest cycle will have to wait on bubbles and the ring is bubble
limited. Its throughput is the bubble population per bubble rejoin period.
Wavefront limited
If the wavefront rejoin period is greater than the wavefront population period then wavefronts will
not catch up with their population. The slowest cycle will have to wait on wavefronts and the ring
is wavefront limited. Its throughput is the wavefront population per wavefront rejoin period.
Delay limited
If there is a slow cycle then both population periods can be greater than their respective rejoin
periods. Both wavefronts and bubbles will catch up with their populations. The throughput of the
ring is neither wavefront limited nor bubble limited but it is limited by the delay of the slow cycle
and the ring is delay limited. Its throughput is the throughput of the slow cycle.
A ring cannot be both wavefront limited and bubble limited. A cycle must contain either a wavefront
or a bubble. It cannot be empty of both and waiting on both.
Ring Behavior Modes
Page 5
2 14 72 22 154 96 12.00 2/72 2.78 Wavefront
4 28 72 20 140 96 6.00 4/72 5.56 Wavefront
6 42 72 18 126 96 4.00 6/72 8.33 Wavefront
8 56 72 16 112 96 3.00 8/72 11.11 Wavefront
10 70 72 14 98 96 2.40 10/72 13.89 Wavefront
12 84 72 12 84 96 2.00 12/96 12.50 Bubble
14 98 72 10 70 96 1.71 10/96 10.42 Bubble
16 112 72 8 56 96 1.50 8/96 8.33 Bubble
18 126 72 6 42 96 1.33 6/96 6.25 Bubble
20 140 72 4 28 96 1.20 4/96 4.16 Bubble
22 154 72 2 14 96 1.09 2/96 2.08 Bubble
24 168 72 0 0 96 1.00 deadlock deadlock deadlock
bubbles
in ring
bubble
population
period
bubble
rejoin
period
wavefronts
in ring
wavefront
population
period
wavefront
rejoin
period
throughput
waves/period
throughput
waves/ 100 tics
limiting
behavior
Mode
cycles/
wavefront
Wavefront and Bubble Limited
Behavior
In wavefront limited behavior cycles have to wait on wavefronts. In bubble limited behavior
cycles have to wait on bubbles.
In both cases the wait is the factor limiting the throughput of the ring.
Page 6
2 22 76 22 242 96 12.00 2/76 2.63 Wavefront
4 44 76 20 220 96 6.00 4/76 5.26 Wavefront
6 66 76 18 198 96 4.00 6/76 7.89 Wavefront
8 88 76 16 176 96 3.00 1/11 9.09 Delay
10 110 76 14 154 96 2.40 1/11 9.09 Delay
12 132 76 12 132 96 2.00 1/11 9.09 Delay
14 154 76 10 110 96 1.71 1/11 9.09 Delay
16 176 76 8 88 96 1.50 8/96 8.33 Bubble
18 198 76 6 66 96 1.33 6/96 6.25 Bubble
20 220 76 4 44 96 1.20 4/96 4.16 Bubble
22 242 76 2 22 96 1.09 2/96 2.08 Bubble
24 264 76 0 0 96 1.00 deadlock deadlock deadlock
bubbles
in ring
bubble
population
period
bubble
rejoin
period
wavefronts
in ring
wavefront
population
period
wavefront
rejoin
period
throughput
waves/period
throughput
waves/ 100 tics
limiting
behavior
Mode
cycles/
wavefront
Delay Limited Behavior
A slow cycle in the ring the causes the population periods to increase much faster than the
rejoin periods. When both population periods are greater than their rejoin periods the ring is
neither wavefront limited nor bubble limited but is limited by the slow cycle that is increasing
the population periods. The throughput of this slow cycle will determine the throughput of the
ring.
The wait to get through the slow cycle is the factor limiting the throughput of the ring.
The table illustrates a ring with a 4 tic delay in its data path making one 11 tic cycle.
Page 7
2 16 96 22 176 96 12.00 2/96 2.08 Wavefront
4 32 96 20 160 96 6.00 4/96 4.16 Wavefront
6 48 96 18 144 96 4.00 6/96 6.25 Wavefront
8 64 96 16 128 96 3.00 8/96 8.33 Wavefront
10 80 96 14 112 96 2.40 10/96 10.42 Wavefront
12 96 96 12 96 96 2.00 12/96 12.5 Balanced
14 112 96 10 80 96 1.71 10/96 10.42 Bubble
16 128 96 8 64 96 1.50 8/96 8.33 Bubble
18 144 96 6 48 96 1.33 6/96 6.25 Bubble
20 160 96 4 32 96 1.20 4/96 4.16 Bubble
22 176 96 2 16 96 1.09 2/96 2.08 Bubble
24 192 96 0 0 96 1.00 deadlock deadlock deadlock
bubbles
in ring
bubble
population
period
bubble
rejoin
period
wavefronts
in ring
wavefront
population
period
wavefront
rejoin
period
throughput
waves/period
throughput
waves/ 100 tics
limiting
behavior
Mode
cycles/
wavefront
Perfectly Balanced Behavior
In a perfectly balanced ring all cycle periods are identical and both the rejoin periods are identical.
When the ring is exaclty half full of wavefronts the peak throughput occurs which is identical to the
throughput of each cycle in the ring. There are no waits anywhere in the ring. This may all sound
good but for this example, but a 1 tic delay was added to the data path to make the wavefront rejoin
path equal to the bubble rejoin path making the cycle periods longer. Notice that the peak throughput
of this ring (12.5) is less than the wavefront limited peak throughput of the unbalanced ring (13.89).
The important factors in ring behavior are the cycle periods and the cycles per wavefront ratio,
not balancing delays
Page 8
Quantized Ring Behavior
Ring behavior occurs in discrete steps. A ring is a closed structure composed of elements that
occur only as whole quantities. There cannot be a partial wavefront or a partial cycle. On the
graph below even though there are lines connecting the behavior points to show relationships,
there is no behavior on the lines between the points. There is ring behavior only at the points.
Cycle per Wavefront Ratio P/W
Optimal throughput occurs when
the ring is approximately half full
of wavefronts(the cycles per
wavefront ratio is 2.0) when there
is a bubble for every wavefront to
flow into and a wavefront for every
bubble to flow into. For a perfectly
balanced ring the peak throughput
occurs at exactly 2.0. For a delay
limited ring the peak performance
plateau will bracket 2.0. For the
bubble/wavefront limited example,
because it is not balanced and
because of the quantized ring
behavior its peak throughput
occurs at 2.4.
ChatGPT dijo:
ChatGPT
Here's a breakdown of the key concepts and components from
Chapter 12: Ring Behavior
of
Logically Determined Design: Clockless System Design With NULL Convention Logic
by Karl Fant, that could be turned into presentation slides:
Slide 1: Title Slide
Title
: Ring Behavior in Clockless System Design
Subtitle
: Logically Determined Design With NULL Convention Logic
Authors
: Karl Fant, John Wiley & Sons, Inc.
Slide 2: Introduction to Ring Behavior
Title
: What is Ring Behavior?
Content
:
Explanation of
pipeline rings
in asynchronous circuits.
Overview of
wavefront
and
bubble propagation
in ring structures.
Importance of maintaining system throughput by balancing paths in the ring.
Diagram
: Simple depiction of a pipeline ring structure, showing multiple cycle paths.
Slide 3: Behavior Rationale
Title
: Behavior Rationale: Critical Factors
Content
:
Period of the slowest cycle
(cycle path delay).
Wavefront rejoin period
(time for a wavefront to circle the ring).
Bubble rejoin period
(time for a bubble to circle the ring).
Population periods for
wavefronts
and
bubbles
.
Key Insight
: Whether a member catches up with its population determines if the ring operates without delays.
Diagram
: Ring with labeled paths showing how wavefronts and bubbles chase around the ring.
Slide 4: Types of Paths
Title
: Types of Paths in Ring Behavior
Content
:
Bubble Path
: How bubbles propagate through the ring.
Wavefront Path
: How data (wavefronts) propagate.
Cycle Path
: The slowest cycle in the ring that governs delays.
Diagram
: Show each path with delays (in tics) highlighted for each segment.
Slide 5: Example Behavior Periods
Title
: Example of Behavior Periods in a 24-Cycle Ring
Content
:
Bubble Rejoin Period
= 24 cycles �� 4 tics = 96 tics
Wavefront Rejoin Period
= 24 cycles �� 3 tics = 72 tics
The relationship between
population periods
and
rejoin periods
determines if wavefronts or bubbles will catch up with their populations.
Diagram
: Table with the example behavior periods for both wavefronts and bubbles.
Slide 6: Ring-Limited Modes of Behavior
Title
: Ring-Limited Behavior Modes
Content
:
Bubble Limited
: Bubbles are slower than their population, limiting throughput.
Wavefront Limited
: Wavefronts are slower than their population, limiting throughput.
Delay Limited
: The slowest cycle in the ring limits both populations.
Diagram
: A visual showing the ring limited behavior modes, with throughput constraints highlighted.
Slide 7: Detailed Example of Limited Behavior
Title
: Behavior Under Various Conditions
Content
: A table showing throughput of a 24-cycle ring with different numbers of wavefronts and bubbles.
Wavefront Limited
: Throughput = Wavefront Population / Wavefront Rejoin Period
Bubble Limited
: Throughput = Bubble Population / Bubble Rejoin Period
Delay Limited
: The slowest cycle limits both wavefronts and bubbles.
Table
: Values for wavefront population, bubble population, throughput in tics.
Slide 8: Delay-Limited Behavior Example
Title
: Delay Limited Behavior Example
Content
:
A ring with a
4 tic delay
in the data path creates longer cycle periods.
Both wavefront and bubble populations grow faster than the rejoin periods, causing the ring to be delay-limited.
Diagram
: Graph showing population and rejoin periods for both wavefronts and bubbles in a delay-limited ring.
Slide 9: Balanced Ring Behavior
Title
: Balanced Ring Behavior
Content
:
Perfectly Balanced Ring
: Equal cycle periods, where rejoin periods for both bubbles and wavefronts are identical.
The ring achieves
peak throughput
when it's half full of wavefronts and bubbles (cycles per wavefront ratio is 2.0).
Diagram
: Graph showing peak throughput at the half-full point.
Slide 10: Quantized Ring Behavior
Title
: Quantized Ring Behavior
Content
:
Discrete Steps
: Ring behavior occurs in distinct steps due to the closed structure of the ring.
Optimal Throughput
: Occurs when the ring is half full, with a cycle per wavefront ratio of around 2.0.
Graph
: Cycle per wavefront ratio on the x-axis and throughput on the y-axis, showing the peak at a ratio of 2.0 and plateaus around it.
Slide 11: Summary of Key Ring Behavior Concepts
Title
: Key Concepts to Remember
Content
:
Ring Behavior
is governed by the interaction between wavefronts and bubbles.
The ring is
bubble-limited
,
wavefront-limited
, or
delay-limited
, depending on rejoin and population periods.
Balanced rings
offer peak performance but are not always optimal for every scenario.
Closing Thought
: Understanding the behavior of ring pipelines is crucial for designing efficient clockless systems.
This slide outline covers the key concepts of
ring behavior in NCL circuits
and simplifies the technical content from Chapter 12 into digestible points for a presentation, supported by diagrams and tables for clarity.
4o
Dijiste:
Linked Oscillations
These are not the influence coupled oscillations of physics and biology: Huygens pendulum clocks or southeast Asian fireflies. Our oscillators are logical circuits ( a closed circuit with an odd number of inversions) which are directly linked logically. They do not necessarily oscillate periodically but can wait indefinitely to complete an oscillation.

Another behavior is introduced that is not a combination behavior but is a transition behavior which is necessary to form an oscillation. The inversion transitions ���data��� to ���not data��� and transitions ���not data to ���data���



The movie illustrates the ���all of��� oscillation linking behavior which will transition its output to red only when both inputs are red and will transition its output to blue only when both inputs are blue. When the inputs are different the linking behavior will hold its output and wait for both inputs to be the same. Since both oscillations monotonically transition between red and blue it is guaranteed that red completeness will always occur and that blue completeness will always occur and that the linked oscillations will oscillate in concert indefinitely.

In the movie one oscillation is faster than the other and waits on the slower at the linking behavior.

Video Player

00:00
00:02


A series of linked oscillators form a spontaneously flowing pipeline in which emerges a  path through which flows stable wavefronts of red and blue.

Video Player

00:00
00:03


The stable flow path through the linked oscillations is highlighted below as the black path which flows from left to right. The grey paths flowing from right to left with the inversion, is the closure path that closes each oscillation around its link behaviors. Below that the pipeline of oscillations is redrawn to emphasize the flow path which is the straight path through the middle and the closure paths which close each oscillation.



The movie below illustrates the behavior of the redrawn structure of linked oscillations

Video Player

00:00
00:01


The demonstration below is a series of linked oscillations forming a pipeline through which transitioning colors flow.  The pipeline has 3 variable speed oscillations: one at the input, one at the output and one in the middle of the pipeline. Each oscillator oscillates between red and blue through a single point of color inversion. Oscillators are linked through a completeness behavior with the completeness logic red & red and blue & blue. When both inputs to the linking behavior are the same color the color passes through the behavior and each oscillation progresses. Play with the speeds and get familiar with the adaptive behavior of the logically determined pipeline. Notice how each oscillation waits indefinitely on linking completeness to complete its oscillation. Green is start and red is stop.



This a pipeline of linked oscillations in the form of the redrawn structure above making it easier to observe the flow path. The big red dots are the oscillation links and the little black dots are the flowing  transitions. The sliders left, mid and right control delays in the left most, right most and middle oscillations respectively. The slider hide is a toggle that will hide the closure flow and show only the data path flow through the pipeline. Play with the delays and observe how the delays affect the flow path and how they interact with each other.



The  ���data���/���not data��� Convention
The two different conditions are designated as ���data��� and ���not data��� representing them in the movies as red and blue respectively. ���data���  and ���not data��� conditions flow through the pipeline as alternating wavefronts of transition. The ���not data��� condition bounds successive wavefronts of ���data��� condition.

Symbolic data such as numbers can be integrated into the oscillation flow behavior. The linking completeness behaviors can be interaction behaviors such as arithmetic functions. The structure of linked oscillations can be a complex network of flow relations through which successive wavefronts of data spontaneously flow and compute.
ChatGPT dijo:
ChatGPT
This description of
Linked Oscillations
in a
NULL Convention Logic (NCL)
pipeline illustrates how asynchronous logic circuits can self-regulate, much like naturally occurring oscillatory behaviors in physics and biology, though the mechanisms differ. Here's a breakdown of the key ideas from the text and how they might be interpreted and presented:
1. Linked Oscillators Overview
Concept
: Unlike natural coupled oscillations (e.g., pendulums, fireflies), linked oscillators in NCL are
logical circuits
that are linked logically, not physically. They oscillate between two states���"data" and "not data"���which could be visualized as alternating between two colors (e.g., red and blue).
Behavior
:
These oscillators are not periodic, meaning they do not oscillate with fixed timing. Instead, they can
wait indefinitely
for specific conditions before completing their oscillation.
Oscillations transition between two states, governed by inversion logic:
data ��� not data
and
not data ��� data
.
2. Oscillation Linking Behavior
Linking Logic
: The key behavior here is an
all-or-nothing completeness condition
, which only allows the oscillator to transition its output when both of its inputs are in the same state.
For example, an oscillator outputs
"red" (not data)
only if both of its inputs are red.
If the inputs are different (e.g., one red and one blue), the output holds its state and waits for the inputs to match.
Guarantee
: Since the oscillators transition monotonically (i.e., they always progress from one state to the other without skipping or reversing), the system ensures that both
data (blue)
and
not data (red)
conditions will always occur, maintaining oscillation.
Example
: In the movie described, one oscillator is faster than the other, but it waits for the slower one at the linking point, simulating asynchronous, self-regulating behavior.
3. Stable Wavefronts in a Linked Oscillator Pipeline
Pipeline Behavior
: A
pipeline of linked oscillators
creates a flow of alternating
stable wavefronts
of data and not data through the system.
Flow Path
: This is represented as the primary
data path
, where transitions flow from left to right, while the
closure path
(inverted signals) flows in the opposite direction.
Visualization
:
Red and blue wavefronts (representing
data
and
not data
) move through the pipeline, flowing through linking behaviors (represented as large red dots), while smaller black dots show individual transitions between states.
Interactive Visualization
: The text describes how users can adjust delays at different points in the pipeline (e.g., input, middle, output oscillators) to observe how the flow path adapts and stabilizes. This highlights the
adaptive nature
of asynchronous pipelines in NCL.
4. Completeness Logic
Completeness Behavior
: The oscillators rely on a
completeness condition
���only when both inputs to the linking logic are in the same state (red/red or blue/blue) does the oscillation continue.
This ensures that oscillations proceed in unison, producing the wavefronts of data (blue) and not data (red).
The oscillators can also adapt to differences in speed between linked oscillators, demonstrating the
self-regulating
nature of the pipeline.
5. Data/Not Data Convention
Red/Blue Convention
: The pipeline alternates between two states:
"Data" (blue)
: The system is processing or carrying valid information.
"Not data" (red)
: This represents the system's idle or reset state, ensuring transitions are well-defined and bounded by periods of inactivity.
Symbolic Data
: While the visualization uses colors to represent data and not data, symbolic data (like numbers) can be incorporated into the oscillation behavior, making the linking completeness behaviors interact in more complex ways (e.g., arithmetic functions).
6. Applications and Complex Networks
Computation Flow
: By structuring these oscillators into a
network of linked oscillations
, the system can handle complex data flows. Each wavefront of data passes through computation functions (e.g., addition, multiplication) integrated within the pipeline structure.
This can create a network of spontaneous data flow where computations are completed asynchronously, without a clock.
Key Concepts for Linked Oscillations in NCL:
Monotonic Transitions
: Each oscillator transitions between
data
and
not data
states, ensuring completeness and synchronization.
Linked Behavior
: The linking completeness behavior (all inputs must be the same state) ensures the system waits for all parts to be ready before progressing.
Pipeline Flow
: Stable wavefronts of data (blue) and not data (red) flow through the pipeline, regulated by the linking oscillators.
Adaptive Delays
: The system can tolerate different oscillation speeds and adjust accordingly, emphasizing the asynchronous, delay-insensitive nature of NCL pipelines.
Self-Regulating
: The pipeline doesn't require external control���each part waits for completeness at every stage, guaranteeing correct oscillation and data flow.
Interactive Visualization:
In a practical or educational setting, the visualization of this linked oscillation pipeline can be highly interactive:
Variable Speed Control
: Users can adjust the speeds of different oscillators to see how the system adapts to delays.
Flow Path View
: Toggle between viewing the
data flow
(blue and red wavefronts) and the
closure path
(black, representing inversion transitions).
Pause and Play
: Users can start, stop, or pause the oscillation behavior to explore how transitions are propagated and completed.
This simulation would help users understand how asynchronous systems can self-regulate based on internal completeness conditions without relying on an external clock. It also visually demonstrates how "data" and "not data" wavefronts alternate and flow through a logically determined pipeline.
2/2
4o
Dijiste:
A narrative style summary of the whole conversation with sardonic overtones
ChatGPT dijo:
ChatGPT
Ah, what a journey we���ve had, weaving through the intricate���and might I say, ever-so-exhilarating���world of
NULL Convention Logic (NCL)
, delay-insensitive circuits, and oscillatory behavior. If you thought digital logic was dry, well, we managed to spice it up with wavefronts, bubbles, and enough symbolic completeness to make your brain oscillate between ���data��� and ���not data.���
First, the Grand Tour of NCL
We began with a hearty exploration of
NCL���s symbolic completeness
���because why rely on something as pedestrian as a clock when you can have asynchronous magic managing everything? Boolean logic was just too boring, what with its pesky reliance on external timing. NCL threw off those chains and prided itself on being logically self-sufficient, much like that one colleague who never stops reminding you how independent they are.
We broke down
wavefronts
and
NULL wavefronts
like they were some cosmic dance between order and chaos. It���s not just ���data��� traveling through a circuit, but also its rebellious sibling, ���not data,��� following behind like it has something to prove. And, of course,
NULL Cycle Reduction
(because why not cut the time spent processing nothing? A totally reasonable demand in a world where nothingness requires just as much effort as something).
Oscillators and Completeness: A Love Story
From there, we shifted gears into the tantalizing world of
linked oscillations
, where data and not data wavefronts alternately try to outdo each other. The metaphorical ���slow��� oscillator waits for the ���fast��� one, all while transitioning from one monotonous state to another. It's like the slowest runner in a relay race, but at least the fast one is nice enough to wait around���talk about sportsmanship!
In this riveting saga, the oscillators are locked in a
���red means stop, blue means go���
loop, flowing through the pipeline as naturally as existential dread on a Sunday night. These oscillations aren���t like fireflies or pendulums���oh no, this is far more thrilling. These oscillators are logically linked, naturally syncing up because one simply cannot be left behind in the world of completeness.
And the big kicker? They can
wait indefinitely
to finish their little back-and-forth dance. Isn���t that just the height of excitement? No pesky deadlines or schedules���just two oscillations, eternally transitioning between their data and not-data states. Sounds like a dream come true.
A Pipeline So Fun, You���ll Forget to Blink
As we delved deeper into the mechanics of this
spontaneously flowing pipeline
, we explored wavefronts and bubbles. Now, let���s pause here���
bubbles
? Yes, bubbles. Because NCL isn���t content with just data and not-data; we have to include ���bubbles��� and their rejoin periods too. These are critical delays that ensure everything syncs up in perfect harmony���though not too perfect, because that would just be boring, wouldn���t it?
At this point, the conversation circled back to cycles and delays, adding layer upon layer of theoretical perfection that can only be appreciated in the grand context of asynchronous pipeline design. The
ring behavior
���oh, you thought it would oscillate neatly and just make sense? No. We���re dealing with rings where the
bubble rejoin period
is longer than the bubble population period, or where wavefronts catch up in a satisfying yet frustratingly delayed fashion. Just the kind of complexity you need to spice up your weekend.
The Final Act: Play with Your Oscillations
As we approached the climax of this tale, we were invited to
���play with the delays.���
Adjusting the speeds of oscillations at different points in the pipeline was like playing an avant-garde video game with no winners, only waiting. Sliders control delays, and you can watch how everything interacts, waiting for the sweet, sweet moment when
red completeness
and
blue completeness
align. The game is rigged, though���oscillations can wait forever for completeness, just like how we wait for the next season of that show we���re all still watching.
And let���s not forget the
green for start, red for stop
finale, where the pipeline finally reveals its magical adaptive behavior. Sure, nothing happens unless everything agrees it can happen, but that���s what makes it thrilling, right? The anticipation.
In Conclusion...
Through this meandering path of wavefronts, bubbles, linked oscillations, and ring behaviors, we���ve unlocked the hidden secrets of
NULL Convention Logic���
, a universe where nothing happens until everything is absolutely, painstakingly ready���and we can wait as long as it takes. Because, after all, the joy of computing is in knowing that
completeness waits for no one
... except when it does.
Who knew that linked oscillations, logical pipelines, and bubbles could be so...
thrilling
?
4o
ChatGPT puede cometer errores. Comprueba la informaci��n importante.
?