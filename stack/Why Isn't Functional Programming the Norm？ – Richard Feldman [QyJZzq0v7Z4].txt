Welcome, everybody.
This is, why isn't functional programming the norm?
I'm Richard Feldman.
So I'm going to start with a question.
Why isn't functional programming the norm?
Has anyone else wondered this?
Like, everyone ever looked around and been like, hey, yeah,
exactly.
Like, I spent a lot of time doing object-oriented programming
in my career.
And then, eventually, I came across functional programming.
I started doing it and doing it more and more.
And now I've been doing it for several years.
And at some point, I was just like, yeah, why isn't this
the norm?
It seems so great.
Like, why isn't everybody else doing this?
So I set out to sort of answer this question.
And just sort of pretty directly say, like, why are things
the way they are?
Like, why are they this way instead of that way?
And I found out the answer.
And it turns out, the answer is, it's complicated.
There is no one very simple, nice, neat, tidy answer.
But in this sort of quest for understanding,
I ended up learning a lot of things
that sort of explain why things got to be the way that they are.
And I want to share them with you.
So because it's complicated, we're
going to break this down into three parts.
So first, we're going to talk about language, and then
paradigm, and then finally, style.
So let's start with language.
So what languages are the norm today?
If it's not functional programming ones, what is it?
So I found this study by this company called Slashdata.
And they draw up various different sources
to compile this information.
And they ended up producing this Global Developer
Population Report for 2019, which you can read on their website.
And it basically blaze out the top 10 languages,
like in terms of usage, thusly.
And this is probably no serious surprises here.
JavaScript, Python, Java, and so on and so forth.
These are probably languages we've all heard of.
And it's also not a huge surprise that, unfortunately,
the total number of functional programming languages
in this list is zero out of 10.
But that's the way things are, not necessarily the way
that I would like things to be.
And so looking at this list, I then
sort of ask the question, how did they get so popular?
How do they become some of the 10 most popular languages
in the world?
So I ended up concluding that this breaks down
into three major categories, and then two kind of exceptions.
So one is they had a killer app.
Another is they had some form of platform exclusivity.
Another is they had a really quick upgrade story.
So let's start with the killer apps.
So this is the Apple II, and it's running Vizicalc.
So Vizicalc is one of the earliest examples of a killer app.
And what I mean by that is that, basically, people
wanted to use Vizicalc so badly that they would sometimes
pay upwards of $10,000 for this $100 piece of software
to get the hardware to run it on.
Like, people wanted Vizicalc in their lives so badly
they would just go out and buy an Apple II just so that they
could run Vizicalc.
And this is sort of like an example
that sort of crops up in programming languages as well.
Byte Magazine, back in 1980, said
Vizicalc was the first program available that has been
responsible for sales of entire systems.
And that metaphor also extends to cases
where someone wants to get at a particular application
of a programming language, and then they buy into the programming
language itself along the way as sort of a cost of getting
at the application they want.
So here's an example of this.
What would you say is the killer app for the Ruby programming
language?
Rails, exactly, right.
And I think this really drove this point home
when I looked up the Google search trends for both Ruby
and for Rails.
And it turns out they have the same shape.
In 2005, when Rails comes out, Rails' Google search term
goes from 0, has a big spike, and then Ruby has exactly
the same spike, and then Rails' popularity tapers off,
and then Ruby's popularity tapers off.
So I think from this, I can kind of conclude pretty definitively
that Ruby's popularity in the top 10 is explained by Rails.
And I don't think that if Rails had not
happened that Ruby would actually be one of the top 10
most popular languages.
Killer app for PHP, I think, has changed over time.
So I think at first, it was basically the things that kind
of everybody was using it for, which is basically
making HTML dynamic.
Like, if you've got a static HTML page
and you wanted to make it a little bit dynamic,
it was really hard to do that faster or more easily than PHP.
You just tweak some stuff, insert some code
in the middle of your HTML, and then upload it, like,
filezilla it up to a server, and then, OK, it's, there you go.
You're done.
But these days, it actually seems to have narrowed down
to having two particular killer apps for PHP.
So this is a graph of PHP's popularity over time.
A little bit more dire than Ruby's.
It's been in pretty steady decline since 2004.
And in fact, if you look at the end,
and these two particular applications of PHP, WordPress
and Drupal, it looks like the total number of hits for PHP
is the sum of WordPress and Drupal.
That's about it these days, which kind of matches anecdotally
what I hear from people.
I still hear people using Drupal a good amount.
I still hear people using WordPress
for building sites for people.
But in terms of using PHP for their own site,
or for going out and starting a startup around it,
that's pretty much done, like Facebook and Slack
are kind of cautionary tales in that regard.
Killer App for C was actually systems programming.
So back in the day when this came out,
this is way before my time, but I actually
watched a talk by Brian Kernahan, one of the co-creators
of C, and he explains that actually at the time,
if you wanted to do systems-level programming,
like you wanted to write a kernel,
or you wanted to write like LS or some system utility,
your options are basically like assembly language or Pascal,
which I'm not a Pascal programmer,
but the way that he talked about it sounded like that
was a ludicrous idea.
So apparently not really done.
And so when C came out, it really
filled this need that a lot of people had.
So like, awesome, I want to do systems programming,
I'm going to reach for C. And that really kind of kicked off
C's popularity.
I think there's some potential for like some FP killer apps,
like anything can do it.
If something comes out that's sufficiently popular,
if it takes off, I believe that it would take that language
with it.
So examples that come to mind for Elm, there's ElmuI.
Basic pitch there is you don't have to write CSS anymore.
You can make front end applications,
and it's got this whole layout system that's really nice
that you don't have to think about CSS.
You just write your Elm code, and then you have a UI.
Closure, Datomic, like it's a nice database.
Like that's independent of programming language,
because if you want a really nice database,
and you say, hey, I think I would like to use Datomic,
Datomic takes off.
If a bunch of people say that, I think
it would bring closure with it.
It would bring a lot more closure programmers
into the world in the same way that Rails did for Ruby.
And finally, ReasonML has this thing called
Reverie, where the basic pitch is,
you can have a cross-platform app built with web technologies,
but it doesn't actually run everyone's favorite electron.
So all of these things have the potential
to cause these languages to take off in the same way
that they have for non-functional languages.
It's just a matter of, will they?
I don't know, we'll see.
So second way that a lot of these languages became popular
is platform exclusivity.
So I'm going to talk about a few examples.
Objective-C, Swift, JavaScript, and C-Sharp.
So let's start with Objective-C and Swift.
Does anyone think that Objective-C and Swift
are just like great general-purpose programming
languages used in all sorts of different domains,
kind of the way that Python is?
OK.
There's one.
I appreciate your bravery.
So I think probably the rest of the people
who are thinking is like, no, those are things
that you use to build for Apple.
But it turns out, even if that's kind of their deal,
like Apple has this platform exclusivity thing,
where these are the blessed ways to develop for Apple.
And everything else is maybe technically supported,
but really, really difficult in comparison.
Turns out, Apple makes a ton of devices.
So even if both of these languages, Objective-C
and Swift, are pretty much just being used to build
for Apple devices, that's such a huge amount of development
that gets done that it's just like, yeah, that's
enough to get you in the top 10.
And which is kind of interesting if you think about it,
because it almost means pretty much no matter
what the design of these languages was within reason.
It could have been functional, could have been imperative,
could have been object-oriented, could have been just
about anything, and they would be in the top 10,
because Apple is such an enormous source of programming.
So interesting to think about these things.
JavaScript kind of in the same boat,
not with a proprietary thing, but just with the web.
I don't know if you know this, but studies
have shown that the web is huge and has gotten really big.
And I mean, technically, when it came out,
like at the inception of the web, there were like two,
and then very shortly, three viable options, namely JavaScript,
Java applets, remember those, and Flash, remember that.
And pretty quickly, people discovered
that the problem with Java applets
is that they're miserably slow, and no one ever
wants to use them.
And Flash kind of had a heyday, it had a good run,
and by good, I mean, was full of security problems
and crashing, but eventually, it kind of died off.
No one really knows why.
And then eventually, it was pretty much just JavaScript.
So JavaScript had platform exclusivity
over the most popular application delivery platform
in the history of anything.
So somehow, that made it to get all the way to number one,
really surprising, exclusivity over the web,
as far as like UIs go.
So this is another example of platform exclusivity,
not because of a closed proprietary thing,
but because of an open standard, where they just all
converged on one language.
It'd be interesting to see if WebAssembly changes this.
I mean, it's really got an uphill battle,
but at least has the potential.
And finally, we come to C-Sharp.
And this is an interesting case, because it's about platform
exclusivity from two different angles.
So first, we have Microsoft Windows.
So this is mid-90s, Windows 95 is in the works,
and out comes Java from some microsystems.
And Java has this tagline of write once, run anywhere.
And Microsoft is not like this, because if you can run it
on any operating system trivially,
that means you don't have to run it on Windows,
and you could run it on somebody else's OS,
like Mac or Linux or something like that.
And Microsoft at the time made pretty much all their money
from Windows and Windows-related things.
So they really didn't want people to be writing a ton of Java.
They wanted people to be writing something
that they controlled.
So they came up with this language called C-Sharp,
and that was the language that they controlled
that had an almost identical feature set to Java
by some very strange coincidence.
So what Microsoft actually wanted out of this
was they wanted lock-in.
Like they wanted people to be like,
okay, let's just use our thing instead of that thing.
But the way that they achieved this
was by using platform exclusivity on their vast
and very genuinely good network of tools and ecosystems
around like MSDN, documentation and stuff like that.
So if you wanted to get in on like the Microsoft IDEs,
like Visual Studio, like before Visual Studio Code,
and you wanted to get a Java-like experience,
the only way to do that was C-Sharp,
because Microsoft was not gonna build those tools for Java.
They were just gonna build it for C-Sharp.
It was successful.
So C-Sharp became a very popular language,
and to its credit, it had a number of design features
that were considered by many people, improvements over Java,
and this got it up into the top 10.
And then finally, we have the quick upgrade path.
So this is basically sort of working at people's,
like the considerations that they do
when they're deciding to adopt a programming language.
So of course, everybody's thinking about the benefits,
you know, the things that I think will be good
if I use this language.
Familiarity's always a big thing.
We're humans, we get a first impression of something,
we're like, oh, that looks nice, I know what that is.
Or you say like, oh no, that's a lot of parentheses,
hypothetically.
This is the thing that people do,
like we make snap reactions to things,
and it impacts whether or not things get popular.
Learning curve is another one, right?
Like you look at this thing, you say,
whoa, I don't know what the word monad is,
like I don't think I'm gonna have time
to learn all these textbooks about category theory,
whatever.
Ecosystem access, am I gonna be able to like,
leverage this huge ecosystem of code
that's already written for whatever language is,
and how much effort is it gonna be to migrate?
Like how different is this from the current code
that I have, or the way that I'm used to writing code?
All of these things are considerations,
and so the quick upgrade path is basically saying,
don't worry about it, don't worry about it.
This is all benefits, and like the drawbacks,
like it's super familiar, learning curves,
almost zero, fully access to the ecosystem,
code migrations to the snap.
CoffeeScript is one of the early languages
that succeeded on this, their tagline was,
it's just JavaScript, and they basically were like,
yeah, you can learn this in about half an hour
if you're a JavaScript programmer,
we'll migrate all your code for you,
you can just run a script
that will convert your JavaScript to CoffeeScript,
and then it'll have all these benefits,
and this was enough to rocket CoffeeScript up to,
at one point, like at its peak,
it was the 11th most popular language on GitHub,
and this tagline was maybe not 100% accurate,
I mean, it's literally not just JavaScript,
it is a different programming language,
but it's so close to JavaScript that it's like,
okay, it's approximately equal to JavaScript.
The language that I think has a more reasonable claim
to that is TypeScript.
I mean, TypeScript is actually a strict superset of JS,
so it's like, okay, yeah, I guess fair enough,
that actually is just JavaScript,
so they actually have the thing where you can rename your
file name from .js to .ts,
and it's supposed to just work right out the box,
and then you can just start adding features from there.
Pretty impressive, and certainly,
if you're looking at that and saying,
oh, so you have these benefits,
and the costs are, I have to rename the file?
Okay, that sounds good, where do I sign up?
And a lot of people have signed up,
TypeScript's doing really well in terms of popularity.
C++ is arguably the first example of sort of doing this
and being really successful at it.
C++ was a near superset of C,
it wasn't like literally TypeScript style a strict superset,
but often enough, you could just take your .c file,
rename it to .cpp, and just go,
and just get the additional benefits of C++.
Worked out really well.
Kotlin is maybe the most modern example of this.
It's going more with the coffee script flavor,
like Kotlin is a substantially different programming language
from Java, it's not just claiming to be a drop-in upgrade,
but it is like they really emphasize this on the website.
100% interoperable, existing code bases,
I've no trouble migrating, we've got a script
that'll convert your Java to Kotlin.
And again, also language that's been doing really well.
Okay, so that's most of the languages in the top 10,
but there are two that we haven't talked about.
So one of them, Java, has a strategy for getting popular
that as far as I know has never before or since
been attempted to get popular, which is epic marketing.
I mean, seriously.
So in the 90s, there was a lot of coverage,
and in fact, the early 2000s, of basically all the money
and power that Microsystems was putting behind Java.
In 2003, they introduced a new $500 million marketing campaign
just for Java, like nothing else other than this programming
language.
And keep in mind, this is in 2003,
when Sun was having financial difficulty.
So this was after untold amounts of marketing dollars
that they had done back when they were flush with cash.
And at this point, they already had millions of Java users
and they were like, it's not enough.
We need to announce a new re-upped effort
and tell everyone how much money we're spending.
This did, however, result in some pretty hilarious stuff.
So this is from the late 90s.
This is a Sun Microsystems commercial called the SPI.
And it's basically just like a James Bond spoof.
It's like James Bond and Q, where
they just go through this briefcase full of gadgets
and Q. It's like, this was built with Java technology.
It's like, including this credit card that, for some reason,
is Java code running on it.
I don't know exactly why that's critical to James Bond's
success here.
Also, there was this funny moment in the middle
of the commercial where they just have this woman in a lab
code holding a C++ textbook.
I think that was just to be like, hey, C++ programmers,
come use Java.
It'll be great.
And that was the goal of Java, was
it was supposed to be familiar for C++ programmers.
They really wanted to attract them.
James Gosling, in one of his talks, used the term.
He's like, we wanted to hoodwink them into thinking
that Java was something that they already understood.
So they were really pushing this, even
in the middle of this commercial.
So this was so successful that it actually impacted what
has today become the number one programming language.
So the story of JavaScript's early development
was Brendan Eich was working for Mozilla.
He was tasked with making a scripting language
for the browser so you could do real-time scripts in the UI.
And his original design was actually based on scheme,
like a functional programming Lisp.
That was what he wanted to, that could have been number one.
But people at Mozilla were like, have you
seen this Java hype train that's coming?
We've got to get on that.
Put it in the name.
Just stick it in front, we're going to have J-A-V-A in our name,
and also make the syntax look like that
and make the language be object-oriented.
And Brendan Eich's like, OK.
And that's the story of why the number one programming language
in the world is object-oriented instead
of a functional Lisp.
I think it's pretty, you would have a tough time making
the case that it's like, yeah, if JavaScript had
been a Lisp and it was the only way it had
exclusivity on the browser, no, I wouldn't have gotten popular.
No, who cares about the web?
That's not a big deal.
People get scared away from parentheses.
No, no chance.
I mean, it would still be number one.
It would still be the biggest thing in the world,
because the web was still the biggest thing in the world.
But this is why it ended up the way that it did.
It was because of, ultimately, Sun Microsystem
spending millions of dollars on marketing.
Go figure.
Which brings us finally to Python, which has,
unfortunately, the least exciting story of all these.
It's basically just like slow and steady.
It just slowly and steadily grew over the years.
So you can exemplify this by looking at Python in comparison
to two very similar languages, the Python, Pearl and Ruby.
So this is back in 2005, when Rails is just taking off.
So you can see, at this point, among those three languages,
Python was the least popular.
So Python had just been kind of cruising along,
and Pearl is kind of in decline, almost PHP style.
And Ruby, at this point, has just skyrocketed up
because Rails just came out.
So at this point, Python's kind of in third place.
But hey, so slow and steady wins the race, as they say.
And as we see, as time continues, Pearl continues to decline.
Rails helps Ruby out, but then eventually,
it kind of tapers off.
Python's still just kind of cruising along,
cruising along, cruising along.
And then eventually, I don't know,
Python just kind of gets an uptake.
The slope changes a little bit,
and it just sort of slides on up.
And then by the time we get to the president,
it's like, holy cow, what happened?
Python is now the number two language in the world,
like out of nowhere, but it wasn't out of nowhere.
It was just out of slow wear.
It never had like a Rails moment
where it just jumped up to the moon.
It was just kind of slow and steady,
and then eventually, slow and steady,
slightly more increased, and then that was it.
Just multiply that by enough years,
and eventually, it just becomes a really popular language.
So good on them.
I almost feel like this is how we would like
programming languages to work out.
They just have a good design,
they're people like them,
and then over time, people use them more, and that's it.
But of course, as we're seeing,
in real life, it's more complicated than that
most of the time.
Now, of course, there are other factors
that go into popularity.
It's not like these particular stories
are the only things that influence them,
but I think that they're kind of secondary to these things.
Syntax is one, we talked about,
of course, anyone who's used Lisp
is familiar with people's initial reactions.
Job market, people are always just kind of catch 22,
where they're like, oh, I don't want to learn that,
because if I invest in it,
no one will be able to hire me,
and then employers are like, I don't want to use that,
because if I do, I won't be able to hire anyone.
It's like, well, no, just, whatever.
This happens, right?
It very much favors languages that are already popular,
and sort of reinforces their popularity.
And then finally, community.
This can be either an asset,
or it can be something that makes people go away.
Ruby, I would say, this is a big asset to them,
was the Ruby community has a reputation
for being really welcoming and friendly.
I think among functional programming communities,
it's kind of a mixed bag.
Some of them are notable for being really welcoming.
Others are notable for being kind of arrogant and stuffy,
so it really kind of depends on where you go.
But again, like I said, I think these are pretty secondary
to the main ones that we just talked about.
So this led me to another question, like, okay,
so I can see that there's a variety of explanations
for how these languages got popular,
but how come they're all OO?
Like, that doesn't really seem to relate
to killer apps and things like that.
Like, how come all of these except for C in the top 10
are all object-oriented languages?
Is there more to this story?
Is there something about object orientation
that causes or is partially responsible for this popularity?
Because it seems like if that's just a coincidence,
that's a pretty big coincidence.
So I looked into this some more,
and this leads me to part two, paradigm.
So Wikipedia defines paradigm as a way
to classify programming languages based on their features.
So because features can overlap,
like you can have multiple sets of features,
you can have overlapping paradigms as well.
So some languages are, for example,
imperative and object-oriented and procedural at the same time,
or they can be hybrid, object-oriented and functional.
You know, this is the thing, they overlap.
So I was trying to sort of narrow it down
to the stuff that's uniquely OO,
like the non-cross-paradigm stuff,
and say like, okay, is it the case
that almost all these languages are OO
because of some uniquely OO features
that are really not found in other paradigms?
So this, of course, led to the question of like,
what are the uniquely OO features?
I mean, I can think of a few that get talked about
as sort of canonical OO features,
like encapsulation maybe, inheritance, objects, methods,
so I kind of started to investigate these.
So inheritance, this breaks down into two categories.
One is what people call interface inheritance.
This is basically just another term for subtyping.
Of course, subtyping is found in all sorts of languages,
so that's definitely not uniquely OO.
The other one is implementation inheritance,
which most people just call inheritance,
but I have encountered people who want it
to be more specific, so for the rest of this talk,
whenever I say inheritance, I mean implementation inheritance.
Interesting thing about implementation inheritance though,
it's not actually considered to be a best practice, really.
So there's this phrase composition over inheritance,
like favor composition over inheritance.
And I think the earliest time this was used
was in the Gang of Four Design Patterns book,
this really influential object-oriented
programming design book.
But now this has just become something that gets repeated
by every object-oriented thought leader
I've pretty much ever heard of.
This is just kind of the way you're supposed to do stuff.
It's like, yeah, inheritance is a thing,
it's found pretty much every object-oriented language,
but you know what, it's kind of disfavored
in favor of composition.
I think that's pretty interesting.
So that leads me to the conclusion that if inheritance
is one of the uniquely OO language features,
which I think it is, it's pretty hard to say
that this thing that is recommended not to use
as a best practice is somehow explains the popularity
of all these OO languages.
So I don't think it's inheritance.
And I especially don't think this when you think about
what are some modern languages that sort of self-identify
as being able to support OO paradigms,
like what do they think of inheritance?
So Go is a good example of this because this is a language
where they don't really need to have backwards compatibility
with any of the other object-oriented languages.
Like Kotlin, of course, needs to have inheritance
because they want to have really good Java interop.
Go doesn't care.
Go is basically trying to be another better C
based on using the learnings of the intervening time period,
really some of them.
And basically Go is like, you know what?
We support an object-oriented style.
This is from their FAQ, but they don't have inheritance.
They just decided it wasn't worth it, didn't want to do it.
And it's especially interesting when I look at this
in terms of what does that imply for what methods
and objects, which are kind of two of the other things
that I said might be some of the uniquely OO features.
Now it turns out that once you take inheritance
out of the picture, methods and objects
are kind of just the same thing as procedures and structs
with some syntax sugar.
So I think this is kind of true in Go.
Like quote unquote objects and methods
are really just syntax sugar.
So if you look at these two function calls,
like procedure calls, circle.grow parentheses 3
and grow parentheses circle comma 3, in both cases,
the logic that you're running is this grow logic.
And in both cases, grow has access to the circle
and the number.
So whether or not you write it in method style
or whether you write it in sort of procedure call style
is really just a matter of syntax.
Semantically, the only reason these could possibly be different
is if you have inheritance in the mix.
So to me, this kind of reduces down to,
okay, I've ruled out objects and methods
as being uniquely OO, really it's either,
it's just implementation inheritance
and or maybe encapsulation.
So what about encapsulation?
If Go supports an object-oriented style,
how do they do that?
If they don't have a first class concept of objects,
how do they do encapsulation?
So this gets into a sort of broader concept
called modular programming.
This is one of the things you'll find listed on Wikipedia
as one of the programming paradigms, modular programming.
It's like imperative programming, modular programming,
et cetera.
So modularity is essentially where you get to define
a public interface and hide private implementation details.
This is about information hiding.
And this comes from a language called modular,
which sort of pioneered this in 1975.
Now languages with modules are all of them, basically,
like every modern language, except for C and C++,
which were like too old school to have had it
back in the day.
Although modules actually are apparently coming
in C++ 20, so this is a temporary state of affairs,
but it seems to be that pretty much every language
has agreed, you know what's good?
Modules, we should have a module system,
except for the languages that are too old for it.
And Go is no exception, Go has a module system.
Now, what's interesting here is how modularity
and encapsulation relate.
So again, this is the definition of modularity,
public interface, private implementation details,
and here's the definition of encapsulation.
Public interface, private implementation details,
but specifically about an object.
So encapsulation is kind of like a weaker form of modularity.
It's like a subset of it.
It's like modularity, but only applied to objects.
And this was a feature that you could find
in another early language with a similar kind of name
called Simula.
This is a language for performing simulations.
And Simula did not have a module system,
but they did have encapsulation.
So you didn't get the full-blown module system
that every modern language seems to agree is what you want,
but they did have a more limited form,
namely encapsulation.
So you got some of the benefits,
but they were kind of limited to just objects.
So Simula inherits from the interesting choice of words.
Simula is a descendant of the Algal programming languages,
like really influential language in the 60s.
And it had some of these language features,
objects, classes, inheritance.
Those were brand new as of Simula.
Simula introduced to the world objects,
classes, and inheritance.
Garbage collection, it did not introduce
because John McCarthy did that with Lisp back in the day.
This was like the original garbage collected language,
but Simula just continued to use that.
And Simula was very influential
in another famous object-oriented language, Smalltalk.
So this was like sort of the,
maybe the most famous of the original
object-oriented languages,
considered by some to be the only true
like object-oriented language.
So Smalltalk was designed by Alan Kaye,
who drew on Simula among other sources of inspiration.
And he coined the term object-oriented.
So objects existed before Smalltalk,
but object-oriented was an Alan Kaye original.
He came up with this term and he applied it to Smalltalk.
And you can kind of see why,
because in Smalltalk everything is an object.
Like you have objects, right?
Those are objects.
And then the way that objects call methods
is by passing messages to other objects.
The messages are also objects.
And then also all of those have classes,
and classes are also objects.
So really like seriously,
every primitive in Smalltalk is an object.
So I mean, yeah, I would use the term object-oriented
to describe that, maybe even object-obsessed.
And really like, you know,
so this is a pretty natural term
and it got picked up by a lot of people
and they were like, oh cool,
object-oriented systems have like objects
and classes and inheritance.
And then like three decades later in 2003,
Alan Kaye was like just kidding,
actually like object-oriented,
I never really should have called it that
because really it's about these other things.
I really think OOP is actually about
messaging, local retention and protection
and hiding of state process,
extreme late-binding of all things,
and only Smalltalk and Lisp are object-oriented.
And the rest of the world is like, excuse me?
We've got C++ and Java and like all these other like,
these seem object-oriented to us
and you're saying like, no?
And he's like, I coined the term, this is what it means.
Here's the thing though, like language,
like spoken language evolves over time.
I mean, Alan Kaye, maybe this is what he actually
in his heart truly meant back in the 80s,
but it's like that ship has sailed.
Like we just, the word means a different thing now
than what he wanted it to mean originally.
I think it's just too late.
Like object-oriented programming is just like
what we consider to mean these days, which is not this.
So if you wanna learn more about objects
and Alan Kaye and the history of the term
objects and object-oriented,
Hillel Wayne wrote this blog post that really goes
into the history in a lot more depth
and if you wanna check out that link a little bit later,
you can.
Now I bring up Smalltalk because this is the language
that influence Objective C, which is one of our top 10.
So Objective C was created by Brad Cox.
He did an interview, which is that link right above there
if you wanna see the full interview,
where he kind of explained like the story
of how he ended up creating Objective C.
And the story goes like this.
He was working at a company called ITT.
They were working on the Unix systems
and they were programming them in C.
This is where the C influence in Objective C comes from.
And Brad's job was he was on a productivity team.
He was supposed to help everybody else
in the organization get more productive.
And what he says in this interview is he's like,
I wasn't happy with C as a productivity foundation.
I was kinda looking around for anything that could help.
And it was about the time
that the Byte Magazine issue came out.
Now if you look at that Smalltalk logo,
I've omitted something here,
which is that this was actually the cover of Byte Magazine.
Remember we were talking about Byte Magazine for Vizicalc?
So Byte Magazine was essentially like getting on the cover
of Byte Magazine was like being on the front page
of Hacker News in the 80s, right?
This was like before the web, you know,
there was no Hacker News, there was no any web.
But like, you know, this is a big deal.
So Brad's like leafing through this and he's like,
huh, this is interesting.
This seems like it's related to the problem I have.
Whole bunch of things in there that Smalltalk was offering
that I thought might help encapsulation for sure.
Encapsulation being our subset of modularity.
C is so bad at it.
Everything is public, it just turns to soup.
The pain of that is what I was trying to escape.
It's just really interesting.
Like Brad Cox was basically saying, I want modularity.
I want a module system.
And you know, with the benefit of hindsight,
we can say Brad, go look at modular.
You'll get the real thing that everybody's gonna conclude
is what you actually want later.
But he didn't have access to that.
He had Bite Magazine and Smalltalk was the one
that happened to be on the cover of Bite Magazine.
So he was like, cool, here's the thing that solves my problem.
This is what I'm gonna use.
And so he ends up making Objective-C from that.
And it's pretty interesting to think of like, you know,
this is what happened, you know, in the 80s
based on his being only aware of Smalltalk,
you know, there was no web.
But like Bite Magazine has done other covers, right?
Like here's one for Lisp.
I mean, who knows what could have been, right?
What if it had just been like modular
on the cover of Smalltalk Magazine?
And instead of Objective-C, it's just Modular-C, right?
And then now one of the top 10 languages
is maybe a dialect of standard ML instead of being
a dialect of Smalltalk or a hybrid of Smalltalk and C.
Because really, that was the one thing that he wanted.
And this was the way that he knew to get it.
And much later after the fact, we look back
and we don't think like, oh, Objective-C,
that was based on a need for modularity,
which everybody now knows is best solved by modules.
We look back and say, nope, that's an object-oriented language.
Object orientation must be great.
Not really the story when you dig into what he was actually
saying about what his goals were.
There's another language that's descended from Simula.
This time, not by way of Smalltalk.
I put up a little curtain so I can have a big reveal
as to what the language is.
So this is Bjarne Strauschrup.
Anyone know who this gentleman is?
OK.
Yes, so I have a spoiler right here on the slide.
He's the creator of C++.
But he's also the creator of another programming language,
which he created before C++.
Anyone know what that was called?
C with classes.
This language had a very specific goal.
It was to have C, but with classes.
And actually, it's not quite true.
It was C with classes, but also a stronger type system.
He wanted to make the type checker a little bit stronger.
So he gave this interview where he kind of
explains his thought process and what he was doing.
And he was like, why did I want to add classes to C?
Well, Strauschrup had actually used Simula personally
in a previous job when he was working at this company where
he's like, I want to use C and I want to use something nicer
than C for modeling my domain.
I just want to be able to get more organized.
And he was like, yeah, you know what?
I thought classes were pretty good when
I was using them in the Simula days.
I really like that.
And so I'm just going to try and bring that in.
So he does.
He makes C with classes.
And then he runs into a problem, which is that C with classes
is what he calls a medium success.
And the problem with being a medium success, as he explains,
is that it's like, OK, so this works.
I got a few people using it.
Couple of users.
It's pretty nice.
They're happy with it.
The problem is that I'm the only maintainer.
And there's too few of us to spread the maintenance burden
around.
And so I'm kind of in a pickle.
Like, on the one hand, I could just say, well,
I don't want to maintain this for the rest of my life.
I'm just going to walk away and abandon it.
But then all the people who are using it are my friends,
so I don't want to do that.
And he's like, so what do I do?
He's like, well, the only other option seems to be maybe
I'll just add more features so it'll be more useful to more
people, and then maybe it'll get popular enough
that I can find some other maintainers.
So he does that.
He adds the additional non-object-oriented features
and renames the language to C++.
And it became slightly more popular.
And it still maintained this whole drop-in C replacement
thing, that upgrade path that's really smooth.
But this is really interesting because, again, we
have actually a pretty direct experiment of, like,
does object orientation cause success?
And he was like, well, I added object orientation
and a stronger type checker as a bonus.
That was not enough to cause success.
Then I added a bunch more features and success.
So we have a very direct experiment
as to whether or not object orientation caused
the success of C++.
It's like, no, because when it just had object orientation,
it was called C with classes, which nobody in this room
had heard of.
So clearly, not a causal relationship
there between the OO stuff and the success of C++.
If you want to see this whole interview,
again, here's a link to this really interesting stuff.
This is from the 80s when Straussrup was interviewed
about C++.
OK, so to kind of sum up this family of languages,
we have a lot of people who are going to write C code for UNIX,
grade systems programming language.
They find, you know what, the ergonomics are not great,
or maybe I just need some modularity.
In the case of C++, adding OO features to it
did make his life better.
He was happier with it.
But it wasn't enough to make it be the rocket ship that
jumped into the top 10 like it ultimately did,
until he added additional non-OO features.
And then we look at Java, and we know, OK, Java really
wanted to appeal to C++ programmers.
So why is Java so object-oriented in such a way
that seems very familiar to C++ programmers?
Well, can we really say that Java's object orientation
was in there as a first-class really great thing,
or was it just that this was familiar to a large group
of users, and that was why it was object-oriented,
and that was what caused its success?
Because we've seen that familiarity and this smooth upgrade
path is a really big deal.
And then, of course, the same thing
can be said of C-Sharp.
C-Sharp was intentionally designed
to be exactly the same feature set or very close to it of Java
so that it could be presented as a really viable direct
alternative to Java.
So if you trace this lineage back,
all of it comes down to potentially the reason
that all of these languages are object-oriented
in this whole lineage right here is just
that Bjarne Strauss-Trupp created C with classes,
and then it wasn't popular enough,
so he added other features.
But then the other features don't get the credit.
It's the OO that one medium success failed experiment
is what gets all the credit in retrospect.
Similar thing with Objective C. Brad Cox just wanted modularity.
He says this multiple times in the interview.
But ultimately, what he ended up settling on for modularity
happened to be small talk, because that was what he knew
about at the time.
And then, of course, Swift needs to have backwards compatibility
with Objective C, and so it's also
an object-oriented language.
So really digging through this, at least with this group
of languages, I'm not seeing it.
I'm not seeing that object orientation caused their success.
I'm actually seeing the opposite that it actually
was legit a coincidence in all of these cases.
So what about Python?
Python is not any of these groups.
It's not a direct descendant of C,
except in a very weird argument type of way.
Did object orientation cause Python's success?
So I don't have as direct an interview to point to here,
but I do have a quote from the creator of Ruby, which is Matz.
And he said, when I made Ruby, I wanted a scripting language
that was more powerful than Perl and more object-oriented
than Python.
So Matz's view was that Python was not particularly
object-oriented, and he was like, I really
wanted something that was a lot more object-oriented.
He was pretty into these small talk ideas.
And I think that's really reflected
in the language of Ruby.
So you would think that if object orientation is really
essential for success, that the fact that Matz successfully
made Ruby more object-oriented than Python,
and in fact, Ruby did enjoy a period of time
where it was more popular than Python,
that that would have led to some sort of long-term success.
But of course, we already know from previous charts
that that's not what happened.
Ruby did briefly surpass Python's popularity,
but it was basically because of the Rails bump.
And then once that died off, Ruby's a killer app language.
Python is the language that's like people like it
because its fundamental design is pretty good.
So are OO languages the norm because of uniquely OO features?
I think the answer is just no.
They're OO because modularity is a good idea,
and they happen to originally get it from OO by chance.
All right, which brings us to the final part, style.
So functional programming style, I'm
going to just claim without any evidence,
is avoid mutation and side effects.
I'm claiming this because I've talked to a bunch of people
about it, and this seems to kind of be the consensus.
But at the end of the day, nobody's really entirely sure.
There's no authoritative source that we can go to to say
what the FP style is.
So I'm going to claim it's this, and hopefully,
it'll go along with me.
Now, obviously, no language features
are required to program in this style.
Like, you can almost do this in assembly,
not saying it would be pleasant.
But theoretically, you can just choose not to mutate
and choose not to have side effects,
and most languages, certainly any procedural ones.
Having said that, obviously, languages differ in their support
for this style.
Some languages are very conducive to programming in this style.
Others make it pretty difficult, like assembly.
So why is an FP style the norm?
Well, one argument is just that it's just a matter of time.
Like, it just hasn't had enough time in the spotlight,
and just over time, it's going to become more and more normal
until eventually it becomes kind of the norm.
Actually, this is a pretty compelling argument.
So if you look at the Kotlin FAQ,
it says, is Kotlin an object-oriented language
or a functional one?
And the answer is, hey, we got both.
We got OO, and we got functional.
Like, you can use both.
This is not what you would see in a 1990s Java dialect FAQ.
That was just not a thing back then.
But these days, the functional style,
that's considered a selling point.
That's like, oh, no, people agree
that the functional style is good now.
Like, don't worry, we support that.
We have good support for that.
In a language, remember, where its main thing is like, hey,
this is our super smooth Java upgrade process.
They're bragging about their ability
to support the functional style.
Look at Swift.
They say some additional features of Swift
include functional programming patterns, like map and filter.
And again, this is a language which
doesn't need any help to attract functional programmers.
They're just going to be like everybody's going to use it,
because if you want to build for Apple,
you kind of have to.
But Swift is also saying, like, hey, we're a modern language.
And in a modern language, you've got
to have good support for the functional style.
Again, not saying this means FP is about to take over the world,
but it is important to note that this is not something you would
see in the 1990s.
Something has changed.
And if you don't believe me about those two languages,
take a look at these collection of books.
Functional JavaScript, functional JavaScript, functional
programming JavaScript, beginning functional JavaScript,
functional light JavaScript.
I mean, just lots and lots of stuff
about how to do functional programming in languages that
are not functional languages, but which
do have some support for it.
Java even, like Java, functional programming in Java.
Like this is a real thing.
Python, sure, like that's the top three languages right there.
This huge selection of books.
C++, there are multiple C++ functional programming
and C++ books.
I mean, this is a change.
This is none of these things would have flown in the 90s.
No publisher is going to be like, oh, yeah,
like functional programming and C++.
Let me sign you up.
I'll give you a nice advance on that one.
No, this is a sign that people are coming around to the idea
that, you know what, actually like the functional programming
style, like I don't think people are at languages yet,
certainly, but the style is gaining traction.
And I think this is interesting because if we are somewhere
in the middle of like a transition from OOP
to style to FP style, like maybe this hybrid thing
is an intermediate stage on the road to FP becoming the norm.
That's a plausible thing.
Now, how much time are we talking about?
I don't really know.
I mean, this whole talk, we've been talking in time scales
of like decades.
So it might be that maybe we're in the middle,
but actually the middle is like, maybe we
have another decade or two.
I don't really know.
I mean, I can't say with any certainty.
What I can say, though, is that something has changed.
This style is not something that people
were considering a positive thing in the 90s.
And the idea that it is a positive,
that I think has become sort of mainstream now.
And I think this can translate to popularity
of functional programming languages.
Imagine somebody who's already concluded, hey,
you know, FP style is good.
I'm just like choosing to write functional programming
JavaScript, functional programming Java.
That's just how I write my code.
At some point, you look around, you're like, hey,
wouldn't it be nice if the language I were using
actually had strong support for this style
instead of just kind of being an afterthought at best?
Wouldn't that be nice?
And then at that point, maybe people start saying,
on my next project, I'm going to try and embrace a language that
is really good at this and not just like OK at it
kind of as a side effect.
No pun intended.
And at that point, who knows?
Maybe that changes these rankings.
Maybe that influences people's decision of what programming
languages they're using.
OK.
So to sum up, why isn't functional programming the norm?
Well, it's complicated, but I think
we've learned a lot about some of the factors
that go into this.
We talked about language, paradigm, and style.
Why aren't FP languages the norm?
Well, no one, there aren't any sufficiently large killer
apps for FP languages.
But I gave three examples of things
that could plausibly take off.
Killer app can come out of nowhere.
It can come from anywhere.
No exclusivity on large platforms.
But hey, maybe if there's some platform that
has FP languages as the exclusive way to write for them,
and that platform gets big, who knows?
That could happen too.
Can't really be a quick upgrade if you're substantially different.
I mean, if the whole point is the language is like really
significantly different, you also can't say,
don't worry, it's a drop in replacement.
It's just JavaScript.
If it's like, well, no, the point is it's not JavaScript.
I don't think we can ever have that.
No epic marketing budgets.
And to be honest, I don't know if we're
ever going to see an epic marketing budget on the scale
of Java, but we can dream.
And then finally, maybe FP languages
are in a slow and steady Python-esque growth state,
but those just take decades to resolve.
So it might just be a long time before we actually see them
reach that level of popularity.
Are they the norm because of uniquely OO features?
I don't think so.
I mean, information hiding, aka encapsulation in OO languages,
it's not a uniquely OO feature.
Modules can do it too, and modules
seem to be the consensus best way to do it.
Inheritance does seem to be uniquely OO,
but again, best practice in OO languages
is to encourage composition over inheritance.
And without inheritance, objects and methods
are basically not any different from structs and procedures.
So I think the answer to this is no.
It's not that OO causes languages to become popular.
It's just a coincidence.
It's just a long for the ride.
And finally, why is an FP style the norm?
Well, I think it's just a matter of time.
It's becoming the norm.
I think that's something we can all appreciate and look forward
to in the future.
Thanks very much.
Yeah, questions?
Yeah, sure.
Yeah, so how do you see a list fitting into this picture?
Is it a functional or an unfunctional programming
language in your mind?
Oh, man, you're opening a real can of worms here.
So the question was, how do you see list fitting in here?
Is it a functional or not a functional programming language?
So I actually, this talk is trimmed down to 40 minutes
from two and a half hours, because I had so much material
in this.
One of the questions that I started going around asking people
is like, and just think about this,
because it can fry your brain after a while.
It's like, how do you look at a programming language
and decide, this is a functional programming language
or not?
How do you do it?
And I would just go to people and ask this question,
and they would say, oh, well, it's this.
And then I would give them a counter example.
They'd be like, OK, well, no, it's not that.
It's this.
So I'll just rattle off a couple.
So one is like, OK, so it's a functional programming
language if it has support for first-class functions.
It's like, OK, so Java is a functional programming language.
No, no, no, not Java.
But they have to be pure.
OK, so OCaml is not a functional programming language.
Clojure is not a functional programming language.
No, no, those count.
But OK, you need immutability.
That's important.
OK, but so Rust is a functional programming language,
because it's immutable by default, even.
No, no, no, not like that, but you just
go around in circles.
One person suggested a score.
Like, if you have a certain number of things checked off,
then you cross a threshold, you're functional.
But ultimately, I ended up concluding that, to be perfectly
honest, classifying languages as functional or not
is kind of arbitrary, definitely very fuzzy,
and ultimately not as important as talking about the style
and their support for the style of being
able to avoid mutation and side effects
and still have a really good experience.
So to directly answer your question,
would I say Lisp is a good functional programming language?
I would say it really depends on the Lisp.
If there's a Lisp where every part of the standard library
requires you to mutate things and do side effects, maybe not.
Clojure definitely is.
So I think it really just depends on the language.
Yeah.
Hi, awesome talk.
Thanks very much.
Thank you.
Performance.
Performance.
Yeah, it's one of these things where
Python is a bit slow, C++ is meant to be fast.
So people often talk about this with FP
because reasons you can probably go into.
I was just wondering what you thought about performance
as a kind of aspect of this discussion.
That's a great question.
Yeah, so the question was, how does performance factor in this?
So I think performance is one of those secondary concerns
that doesn't necessarily cause a language to be popular or not.
I think it more impacts the areas in which it can be used.
So for example, some applications,
you just need the level of control over memory
that C and C++ give you.
And if you look at Rust, Rust is one of the very first new
competitors in that space that's viable to challenge
the crown of C and C++ in a long time because of that.
So I think if you need that level of control over performance,
you're probably not going to go for a functional language.
You're probably not going to go for any garbage
collected language.
You just need to be able to directly manage memory.
But as we've seen, there's a ton of domains
where that's not true.
In fact, pretty much all the other ones,
why all the other languages in that top 10,
except for C and C++ are garbage collected.
So I think as far as performance goes,
it really depends on what your performance needs are.
If you're writing a back-end server language,
in a lot of cases, you don't like it.
Python's a perfectly acceptable one.
It's not as fast as Go, but a lot of people are just like,
yeah, but it's fine.
It's good enough.
It's going to be dominated by the network and the database
anyway, so who cares?
I think that it's really domain-specific.
And so overall, to answer the question,
I would say performance, I think, is a consideration,
but it's pretty secondary to the other factors
that I talked about earlier.
Also, I don't think it's true that functional
is less performant, but that's a myth.
It's just not.
If you have mutation and you can do it all over the place,
then certain algorithms are available to you
that are not otherwise available.
But if you're not using those algorithms anyway,
it doesn't matter.
So anyway, and also there's certain performance optimizations
you can only get if you have certain functional guarantees.
Yeah, I can go on for a while.
Thank you, Richard.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
