THE WAY TO GO 

A Thorough Introduction to the Go Programming Language 
IVO BALBAERTThe Way to GoAlso by Ivo Balbaert: 

“Handboek Programmeren met Ruby en Rails.”, 2009, Van Duuren Media, ISBN: 

978-90-5940-365-9The Way to Go 

A Thorough Introduction to the Go Programming Language 
Ivo Balbaert 
iUniverse, Inc. 
BloomingtonThe Way to Go 
A Thorough Introduction to the Go Programming Language 
Copyright © 2012 by Ivo Balbaert. 
All rights reserved. No part of this book may be used or reproduced by any means, graphic, electronic, or mechanical, 
including photocopying, recording, taping or by any information storage retrieval system without the written permission of 
the publisher except in the case of brief quotations embodied in critical articles and reviews. 
iUniverse books may be ordered through booksellers or by contacting: 
iUniverse 
1663 Liberty Drive 
Bloomington, IN 47403 
www.iuniverse.com 
1-800-Authors (1-800-288-4677) 
Because of the dynamic nature of the Internet, any web addresses or links contained in this book may have changed 
since publication and may no longer be valid. The views expressed in this work are solely those of the author and do not 
necessarily reflect the views of the publisher, and the publisher hereby disclaims any responsibility for them. 
Any people depicted in stock imagery provided by Thinkstock are models, and such images are being used for illustrative 
purposes only. 
Certain stock imagery © Thinkstock. 
ISBN: 978-1-4697-6916-5 (sc) 
ISBN: 978-1-4697-6917-2 (ebk) 
Printed in the United States of America 

iUniverse rev. date: 03/05/2012Contents 
Preface................................................................................................................................ xix 
PART 1—WHY LEARN GO—GETTING STARTED 
Chapter 1—Origins, Context and Popularity of Go..............................................................1 
1.1 Origins and evolution ...............................................................................................1 
1.2 Main characteristics, context and reasons for developing a new language...................4 
1.2.1 Languages that influenced Go........................................................................4 
1.2.2 Why a new language?.....................................................................................5 
1.2.3 Targets of the language...................................................................................5 
1.2.4 Guiding design principles ..............................................................................7 
1.2.5 Characteristics of the language.......................................................................7 
1.2.6 Uses of the language.......................................................................................8 
1.2.7 Missing features?............................................................................................9 
1.2.8 Programming in Go.....................................................................................10 
1.2.9 Summary .....................................................................................................10 
Chapter 2—Installation and Runtime Environment ...........................................................11 
2.1 Platforms and architectures ....................................................................................11 
(1) The gc Go-compilers: .................................................................................11 
(2) The gccgo-compiler:...................................................................................13 
(3) File extensions and packages: ......................................................................14 
2.2 Go Environment variables.......................................................................................14 
2.3 Installing Go on a Linux system..............................................................................16 
2.4 Installing Go on an OS X system ............................................................................21 

2.5 Installing Go on a Windows system.........................................................................21 
2.6 What is installed on your machine? ........................................................................26 
2.7 The Go runtime......................................................................................................27 
2.8 A Go interpreter .....................................................................................................27Chapter 3—
Editors, IDE’s and Other tools.........................................................................28 
3.1 Basic requirements for a decent Go development environment................................28 
3.2 Editors and Integrated Development Environments................................................29 
3.2.1. Golang LiteIDE .........................................................................................32 
3.2.2. GoClipse.....................................................................................................33 
3.3 Debuggers...............................................................................................................34 
3.4 Building and running go-programs with command- and Makefiles.........................35 
3.5 Formatting code: go fmt or gofmt ...........................................................................39 
3.6 Documenting code: go doc or godoc.......................................................................40 
3.7 Other tools..............................................................................................................41 
3.8 Go’s performance ....................................................................................................41 
3.9 Interaction with other languages..............................................................................43 
3.9.1. Interacting with C ......................................................................................43 
3.9.2. Interacting with C++...................................................................................45 
PART 2—CORE CONSTRUCTS AND TECHNIQUES OF THE LANGUAGE 
Chapter 4—Basic constructs and elementary data types ......................................................49 
4.1. Filenames—Keywords—Identifiers.........................................................................49 
4.2. Basic structure and components of a Go-program ..................................................50 
4.2.1 Packages, import and visibility .....................................................................51 
4.2.3 Comments...................................................................................................56 
4.2.4 Types............................................................................................................57 
4.2.5 General structure of a Go-program ..............................................................58 
4.2.6 Conversions.................................................................................................60 
4.2.7 About naming things in Go .........................................................................60 
4.3. Constants...............................................................................................................60 
4.4. Variables.................................................................................................................63 
4.4.1 Introduction ................................................................................................63 
4.4.2 Value types and reference types ....................................................................66 
4.4.3 Printing........................................................................................................68 
4.4.4 Short form with the := assignment operator.................................................69 
4.4.5 Init-functions...............................................................................................70 
4.5. Elementary types and operators..............................................................................73 
4.5.1. Boolean type bool .......................................................................................73 
4.5.2. Numerical types..........................................................................................75 
4.5.2.1 ints and floats............................................................................................75 
4.5.2.2 Complex numbers ....................................................................................79 
4.5.2.3 Bit operators .............................................................................................79 
4.5.2.4 Logical operators.......................................................................................814.5.2.5 Arithmetic 
operators ................................................................................82 
4.5.2.6 Random numbers .....................................................................................82 
4.5.3. Operators and precedence...........................................................................84 
4.5.4. Aliasing types..............................................................................................84 
4.5.5. Character type ............................................................................................85 
4.6. Strings....................................................................................................................86 
4.7. The strings and strconv package.............................................................................88 
4.7.1—Prefixes and suffixes:..................................................................................88 
4.7.2—Testing whether a string contains a substring:............................................89 
4.7.3—Indicating at which position (index) a substring or character occurs 
in a string: ..................................................................................................89 
4.7.4—Replacing a substring: ...............................................................................90 
4.7.5—Counting occurrences of a substring:.........................................................90 
4.7.6—Repeating a string:.....................................................................................90 
4.7.7—Changing the case of a string:....................................................................91 
4.7.8—Trimming a string: ....................................................................................92 
4.7.9—Splitting a string:.......................................................................................92 
4.7.10—Joining over a slice: .................................................................................92 
4.7.11—Reading from a string:.............................................................................93 

4.8. Times and dates......................................................................................................95 
4.9. Pointers..................................................................................................................96 
Chapter 5—Control structures..........................................................................................101 
5.1—The if else construct ...........................................................................................101 
5.2—Testing for errors on functions with multiple return values.................................106 
5.3—The switch keyword ...........................................................................................110 
5.4—The for construct ...............................................................................................114 
5.4.1 Counter-controlled iteration ......................................................................114 
Character on position 2 is: ..........................................................................................116 
5.4.2 Condition-controlled iteration ..................................................................117 
5.4.3 Infinite loops ............................................................................................118 
5.4.4 The for range construct..............................................................................119 
5.5—Break / continue.................................................................................................121 
5.6—Use of labels with break and continue—goto......................................................123 
Chapter 6—Functions.......................................................................................................126 
6.1 Introduction..........................................................................................................126 
6.2 Parameters and return values .................................................................................129 
6.2.1 Call by value / Call by reference.................................................................129 
6.2.2 Named return variables..............................................................................1316.2.3 Blank 
identifier..........................................................................................133 
6.2.4 Changing an outside variable.....................................................................134 
6.3 Passing a variable number of parameters................................................................135 
6.4 Defer and tracing ..................................................................................................137 
6.5 Built-in functions..................................................................................................142 
6.6 Recursive functions ...............................................................................................143 
6.8 Closures (function literals) ....................................................................................147 
6.9 Applying closures: a function returning another function .....................................150 
6.10 Debugging with closures .....................................................................................153 
6.11 Timing a function ..............................................................................................154 
6.12 Using memoization for performance...................................................................154 
Chapter 7—Arrays and Slices............................................................................................157 
7.1 Declaration and initialization ................................................................................157 
7.1.1 Concept.....................................................................................................157 
7.1.2 Array literals...............................................................................................161 
7.1.3 Multidimensional arrays.............................................................................162 
7.1.4 Passing an array to a function.....................................................................163 
7.2 Slices.....................................................................................................................164 
7.2.1 Concept.....................................................................................................164 
7.2.2 Passing a slice to a function........................................................................168 
7.2.3 Creating a slice with make().......................................................................168 
7.2.4 Difference between new() and make()........................................................170 
7.2.5 Multidimensional slices..............................................................................171 
7.2.6 The bytes package......................................................................................171 
7.3 For range construct ...............................................................................................172 
7.4 Reslicing................................................................................................................175 
7.5 Copying and appending slices ...............................................................................176 
7.6 Applying strings, arrays and slices..........................................................................178 
7.6.1 Making a slice of bytes from a string ..........................................................178 
7.6.2 Making a substring of a string....................................................................179 
7.6.3 Memory representation of a string and a slice.............................................179 
7.6.4 Changing a character in a string.................................................................180 
7.6.5 Comparison function for byte arrays..........................................................180 
7.6.6 Searching and sorting slices and arrays ......................................................181 
7.6.7 Simulating operations with append............................................................182 
7.6.8 Slices and garbage collection ......................................................................182Chapter 8—
Maps .............................................................................................................185 
8.1 Declaration, initialization and make......................................................................185 
8.1.1 Concept.....................................................................................................185 
8.1.2 Map capacity .............................................................................................188 
8.1.3 Slices as map values....................................................................................188 
8.2 Testing if a key-value item exists in a map—Deleting an element ..........................188 

8.3 The for range construct .........................................................................................190 
8.4 A slice of maps .....................................................................................................191 
8.5 Sorting a map........................................................................................................192 
8.6 Inverting a map.....................................................................................................194 
Chapter 9—Packages ........................................................................................................196 
A The standard library.................................................................................................196 
9.1 Overview of the standard library............................................................................196 
9.2 The regexp package. ..............................................................................................199 
9.3 Locking and the sync package. ..............................................................................200 
9.4 Accurate computations and the big package. .........................................................202 
B Custom and external packages: use, build, test, document, install ............................203 
9.5 Custom packages and visibility..............................................................................203 
9.6 Using godoc for your custom packages..................................................................208 
9.7 Using go install for installing custom packages. .....................................................210 
9.8 Custom packages: map structure, go install and go test .........................................212 
9.8.1 Map-structure for custom packages............................................................212 
9.8.2 Locally installing the package.....................................................................215 
9.8.3 OS dependent code....................................................................................216 
9.9 Using git for distribution and installation..............................................................216 
9.9.1 Installing to github ....................................................................................216 
9.9.2 Installing from github ................................................................................217 
9.10 Go external packages and projects. .....................................................................218 
9.11 Using an external library in a Go program...........................................................219 
Chapter 10—Structs and Methods....................................................................................224 
10.1 Definition of a struct...........................................................................................224 
10.2 Creating a struct variable with a Factory method.................................................232 
10.2.1 A factory for structs..................................................................................232 
10.2.2 new() and make() revisited for maps and structs:......................................234 
10.3 Custom package using structs..............................................................................235 
10.4 Structs with tags..................................................................................................236 
10.5 Anonymous fields and embedded structs.............................................................237 
10.5.1 Definition................................................................................................23710.5.2 Embedded 
structs ....................................................................................238 
10.5.3 Conflicting names....................................................................................239 
10.6 Methods..............................................................................................................240 
10.6.1 What is a method? ...................................................................................240 
10.6.2 Difference between a function and a method ...........................................244 
10.6.3 Pointer or value as receiver.......................................................................245 
10.6.4 Methods and not-exported fields.............................................................247 
10.6.5 Methods on embedded types and inheritance...........................................248 
10.6.6 How to embed functionality in a type......................................................251 
10.6.7 Multiple inheritance.................................................................................253 
10.6.8 Universal methods and method naming...................................................256 
10.6.9 Comparison between Go types and methods and other 
object-oriented languages..........................................................................256 
10.7 The String()-method and format specifiers for a type...........................................258 
10.8 Garbage collection and SetFinalizer.....................................................................261 
Chapter 11—Interfaces and reflection...............................................................................263 
11.1 What is an interface? ...........................................................................................263 
11.2 Interface embedding interface(s)..........................................................................270 
11.3 How to detect and convert the type of an interface variable: type assertions ........270 
11.4 The type switch...................................................................................................273 
11.5 Testing if a value implements an interface............................................................274 
11.6 Using method sets with interfaces........................................................................275 
11.7 1st example: sorting with the Sorter interface.......................................................277 
11.8 2nd example: Reading and Writing .....................................................................282 
11.9 Empty Interface...................................................................................................284 
11.9.1 Concept...................................................................................................284 
11.9.2 Constructing an array of a general type or with variables of 
different types...........................................................................................286 
11.9.3 Copying a data-slice in a slice of interface{}..............................................287 

11.9.4 Node structures of general or different types ............................................288 
11.9.5 Interface to interface................................................................................289 
11.10 The reflect package............................................................................................290 
11.10.1 Methods and types in reflect ..................................................................290 
11.10.2 Modifying (setting) a value through reflection........................................293 
11.10.3 Reflection on structs ..............................................................................294 
11.11 Printf and reflection. .........................................................................................296 
11.12 Interfaces and dynamic typing...........................................................................298 
11.12.1 Dynamic typing in Go...........................................................................298 
11.12.2 Dynamic method invocation..................................................................30011.12.3 Extraction of an 
interface.......................................................................301 
11.12.4 Explicitly indicating that a type implements an interface........................303 
11.12.5 Empty interface and function overloading..............................................304 
11.12.6 Inheritance of interfaces.........................................................................304 
11.13 Summary: the object-orientedness of Go...........................................................306 
11.14 Structs, collections and higher order functions ..................................................306 
PART 3—ADVANCED GO 
Chapter 12—Reading and writing ....................................................................................313 
12.1 Reading input from the user................................................................................313 
12.2 Reading from and writing to a file.......................................................................317 
12.2.1 Reading from a file...................................................................................317 
12.2.2 The package compress: reading from a zipped file....................................321 
12.2.3 Writing to a file........................................................................................322 
12.3 Copying files.......................................................................................................324 
12.4 Reading arguments from the command-line........................................................325 
12.4.1 With the os-package.................................................................................325 
12.4.2 With the flag-package..............................................................................326 
12.5 Reading files with a buffer...................................................................................328 
12.6 Reading and writing files with slices....................................................................330 
12.7 Using defer to close a file....................................................................................332 
12.8 A practical example of the use of interfaces: fmt.Fprintf .....................................332 
12.9 The json dataformat ............................................................................................334 
12.10 The xml dataformat...........................................................................................340 
12.11 Datatransport through gob................................................................................342 
12.12 Cryptography with go .......................................................................................345 
Chapter 13—Error-handling and Testing..........................................................................348 
13.1 Error-handling ....................................................................................................349 
13.1.1 Defining errors.........................................................................................349 
13.1.2 Making an error-object with fmt.............................................................353 
13.2 Run-time exceptions and panic ...........................................................................353 
13.4 Error-handling and panicking in a custom package.............................................357 
13.5 An error-handling scheme with closures ..............................................................360 
13.6 Starting an external command or program ..........................................................363 
13.7 Testing and benchmarking in Go ........................................................................364 
13.8 Testing: a concrete example.................................................................................367 
13.9 Using table-driven tests. ......................................................................................369 
13.10 Investigating performance: tuning and profiling Go programs...........................37113.10.1 Time and memory 
consumption............................................................371 
13.10.2 Tuning with go test ................................................................................371 
13.10.3 Tuning with pprof..................................................................................371 
Chapter 14—Goroutines and Channels ............................................................................375 
14.1 Concurrency, parallelism and goroutines.............................................................375 
14.1.1 What are goroutines? ...............................................................................375 
14.1.2 The difference between concurrency and parallelism................................377 
14.1.3 Using GOMAXPROCS...........................................................................378 
14.1.4 How to specify the number of cores to be used on the command-line?.....379 
14.1.5 Goroutines and coroutines.......................................................................381 
14.2 Channels for communication between goroutines...............................................381 
14.2.1 Concept...................................................................................................381 
14.2.2 Communication operator <- ....................................................................383 
14.2.3 Blocking of channels................................................................................385 

14.2.4 Goroutines synchronize through the exchange of data on one (or 
more) channel(s).......................................................................................387 
14.2.5 Asynchronous channels—making a channel with a buffer........................387 
14.2.6 Goroutine using a channel for outputting result(s)...................................388 
14.2.7 Semaphore pattern...................................................................................389 
14.2.8 Implementing a parallel for-loop..............................................................391 
14.2.9 Implementing a semaphore using a buffered channel ...............................391 
14.2.10 For—range applied to channels..............................................................394 
14.2.11 Channel directionality............................................................................396 
14.3 Synchronization of goroutines: closing a channel—testing for blocked channels .400 
14.4 Switching between goroutines with select............................................................403 
14.5 Channels, Timeouts and Tickers..........................................................................408 
14.6 Using recover with goroutines .............................................................................412 
14.7 Comparing the old and the new model: Tasks and Worker processes...................413 
14.8 Implementing a lazy generator.............................................................................416 
14.9 Implementing Futures.........................................................................................420 
14.10 Multiplexing .....................................................................................................421 
14.10.1 A typical client-server pattern.................................................................421 
14.10.2 Teardown: shutdown the server by signaling a channel...........................424 
14.11 Limiting the number of requests processed concurrently ...................................427 
14.12 Chaining goroutines..........................................................................................428 
14.13 Parallelizing a computation over a number of cores ...........................................429 
14.14 Parallelizing a computation over a large amount of data ....................................430 
14.15 The leaky bucket algorithm...............................................................................43114.16 Benchmarking 
goroutines..................................................................................433 
14.17 Concurrent acces to objects by using a channel. ................................................434 
Chapter 15—Networking, templating and web-applications.............................................436 
15.1 A tcp-server ........................................................................................................436 
15.2 A simple webserver..............................................................................................445 
15.3 Polling websites and reading in a web page..........................................................448 
15.4 Writing a simple web application ........................................................................452 
15.5 Making a web application robust.........................................................................454 
15.6 Writing a web application with templates............................................................456 
15.7 Exploring the template package...........................................................................461 
15.7.1. Field substitution: {{.FieldName}}...........................................................462 
15.7.2. Validation of the templates......................................................................463 
15.7.3 If-else.......................................................................................................464 
15.7.4 Dot and with-end ....................................................................................465 
15.7.5 Template variables $.................................................................................466 
15.7.6 Range-end................................................................................................467 
15.7.7 Predefined template functions..................................................................467 
15.8 An elaborated webserver with different functions ................................................468 
(works only on Unix because calls /bin/date).......................................................474 
15.9 Remote procedure calls with rpc..........................................................................474 
15.10 Channels over a network with netchan..............................................................477 
15.11 Communication with websocket.......................................................................478 
15.12 Sending mails with smtp ...................................................................................480 
PART 4—APPLYING GO 
Chapter 16—Common Go Pitfalls or Mistakes.................................................................485 
16.1 Hiding (shadowing) a variable by misusing short declaration...............................486 
16.2 Misusing strings. .................................................................................................486 
16.3 Using defer for closing a file in the wrong scope..................................................487 
16.4 Confusing new() and make()...............................................................................488 
16.5 No need to pass a pointer to a slice to a function.................................................488 
16.6 Using pointers to interface types..........................................................................488 
16.7 Misusing pointers with value types......................................................................489 
16.8 Misusing goroutines and channels.......................................................................489 
16.9 Using closures with goroutines ............................................................................490 
16.10 Bad error handling ............................................................................................491 
16.10.1 Don’t use booleans: ................................................................................491 

16.10.2 Don’t clutter your code with error-checking:..........................................492Chapter 17—Go Language 
Patterns..................................................................................494 
17.1 The comma, ok pattern.......................................................................................494 
17.2 The defer pattern.................................................................................................495 
17.3 The visibility pattern ...........................................................................................497 
17.4 The operator pattern and interface......................................................................497 
17.4.1 Implement the operators as functions.......................................................497 
17.4.2 Implement the operators as methods........................................................498 
17.4.3 Using an interface....................................................................................499 
Chapter 18—Useful Code Snippets—Performance Advice................................................500 
18.1 Strings.................................................................................................................500 
18.2 Arrays and slices ..................................................................................................501 
18.3 Maps...................................................................................................................502 
18.4 Structs.................................................................................................................502 
18.5 Interfaces.............................................................................................................503 
18.6 Functions............................................................................................................503 
18.7 Files.....................................................................................................................504 
18.8 Goroutines and channels.....................................................................................505 
18.9 Networking and web applications........................................................................507 
18.9.1. Templating: .....................................................................................................507 
18.10 General .............................................................................................................508 
18.11 Performance best practices and advice ...............................................................508 
Chapter 19—Building a complete application...................................................................509 
19.1 Introduction........................................................................................................509 
19.2 Introducing Project UrlShortener........................................................................509 
19.3 Data structure.....................................................................................................510 
19.4 Our user interface: a web server frontend ............................................................515 
19.5 Persistent storage: gob .........................................................................................519 
19.6 Using goroutines for performance.......................................................................524 
19.7 Using json for storage..........................................................................................527 
19.8 Multiprocessing on many machines.....................................................................528 
19.9 Using a ProxyStore..............................................................................................532 
19.10 Summary and enhancements.............................................................................536 
Chapter 20—Go in Google App Engine...........................................................................538 
20.1 What is Google App Engine ?..............................................................................538 
20.2 Go in the cloud ..................................................................................................540 
20.3 Installation of the Go App Engine SDK: the development environment for Go ..54020.3.1. 
Installation..............................................................................................540 
20.3.2. Checking and testing ..............................................................................542 
20.4 Building your own Hello world app ...................................................................543 
20.4.1 Map structure—Creating a simple http-handler.......................................543 
20.4.2 Creating the configuration file app.yaml ..................................................544 
20.4.3 Iterative development...............................................................................548 
20.4.4. Integrating with the GoClipse IDE.........................................................548 
20.5 Using the Users service and exploring its API ......................................................549 
20.6 Handling forms...................................................................................................551 
20.7 Using the datastore..............................................................................................552 
20.8 Uploading to the cloud ......................................................................................556 
Chapter 21—Real World Uses of Go ................................................................................559 
21.1 Heroku—a highly available consistent data store in Go. .....................................559 
21.2 MROffice—a VOIP system for call centers in Go. ..............................................561 
21.3 Atlassian—a virtual machine cluster management system....................................562 
21.4 Camlistore—a content addressable storage system...............................................563 
21.5 Other usages of the Go language. ........................................................................563 
APPENDICES..................................................................................................................567 
(A) CODE REFERENCE ..........................................................................................567 
(B)CUTE GO QUOTES............................................................................................571 
GO QUOTES: TRUE BUT NOT SO CUTE...................................................572 
(C) LIST OF CODE EXAMPLES (Listings)..............................................................572 
(E) References in the text to Go—packages.................................................................583 
(F) References in the text to Go—tools .......................................................................586 

(G) Answers to Questions ...........................................................................................586 
(H) ANSWERS TO EXERCISES...............................................................................590 
(I) BIBLIOGRAPHY (Resources and References).......................................................593 
Index.............................................................................................................................597List of 
Illustrations 
Chapter 1—Origins, Context and Popularity of Go..............................................................1 
Fig 1.1: The designers of Go: Griesemer, Thompson and Pike.........................................1 
Fig 1.2: The logo’s of Go .................................................................................................3 
Fig 1.3: Influences on Go................................................................................................5 
Chapter 3—Editors, IDE’s and Other tools.........................................................................28 
Fig 3.1: LiteIDE and its AST-view.................................................................................33 
Fig 3.2: GoClipse and its outline code-view ..................................................................34 
Chapter 4—Basic constructs and elementary data types ......................................................49 
Fig 4.1: Value type.........................................................................................................67 
Fig 4.2: Assignment of value types.................................................................................67 
Fig 4.3: Reference types and assignment........................................................................67 
Fig 4.4: Pointers and memory usage..............................................................................98 
Fig 4.5: Pointers and memory usage, 2 ..........................................................................99 
Chapter 7—Arrays and Slices............................................................................................157 
Fig 7.1: Array in memory ............................................................................................158 
Fig 7.2: Slice in memory .............................................................................................166 
Chapter 9—Packages ........................................................................................................196 
Fig 9.1: Package documentation with godoc................................................................210 
Chapter 10—Structs and Methods....................................................................................224 
Fig 10.1: Memory layout of a struct ............................................................................227 
Fig 10.2: Memory layout of a struct of structs.............................................................229 
Fig. 10.3: Linked list as recursive struct .......................................................................230 
Fig 10.4: Binary tree as recursive struct........................................................................230 
Chapter 11—Interfaces and reflection...............................................................................263 
Fig 11.1: Interface value in memory ............................................................................264Chapter 14—
Goroutines and Channels ............................................................................375 
Fig 14.1: Channels and goroutines..............................................................................382 
Fig 14.2: The sieve prime-algorithm............................................................................397 
Chapter 15—Networking, templating and web-applications.............................................436 
Fig 15.1—Screen of exercise 15.6................................................................................454 
Chapter 19—Building a complete application...................................................................509 
Fig 19.1: Handler functions in goto ............................................................................515 
Fig 19.2: The Add handler ..........................................................................................518 
Fig 19.3: The response of the Add handler ..................................................................519 
Fig 19.4: The response of the Redirect handler............................................................519 
Fig 19.5: Distributing the work load over master- and slave computers.......................529 
Chapter 20—Go in Google App Engine...........................................................................538 
Fig 20.1: The Application Control Panel.....................................................................558Preface 
Code less, compile quicker, execute faster => have more fun! 
This text presents the most comprehensive treatment of the Go programming language you can 
find. It draws on the whole spectrum of Go sources available: online documentation and blogs, 
books, articles, audio and video, and my own experience in software engineering and teaching 
programming languages and databases, organizing the concepts and techniques in a systematic 
way. 
Several researchers and developers at Google experienced frustration with the software development 
processes within the company, particularly using C++ to write large server software. The 
binaries tended to be huge and took a long time to compile, and the language itself was quite 
old. A lot of the ideas and changes in hardware that have come about in the last couple of decades 
haven’t had a chance to influence C++. So the researchers sat down with a clean sheet of paper and 
tried to design a language that would solve the problems they had: 
1. software needs to built quickly, 
2. the language should run well on modern multi-core hardware, 
3. the language should work well in a networked environment, 
4. the language should be a pleasure to use. 

And so was born “Go”, a language that has the feel of a dynamic language like Python or Ruby, but 
has the performance and safety of languages like C or Java. 
Go seeks to reinvent programming in the most practical of ways: its not a fundamentally new 
language with strange syntax and arcane concepts; instead it builds and improves a lot on the 
existing C/Java/C#-style syntax. It proposes interfaces for object-oriented programming and 
goroutines / channels for concurrent and parallel programming. 
This book is intended for developers who want to learn this new, fascinating and promising language. 
Some basic knowledge of programming and some experience with a programming language and 
environment is assumed, but a thorough knowledge of C or Java or the like is not needed. 
xixIvo Balbaert 
For those of you who are familiar with C or the current object oriented languages, we will compare 
the concepts in Go with the corresponding concepts in these languages (throughout the book we 
will use the well known OO abrevation, to mean object-oriented). 
This text explains everything from the basic concepts onwards, but at the same time we discuss 
advanced concepts and techniques such as a number of different patterns when applying goroutines 
and channels, how to use the google api from Go, how to apply memoization, how to use testing 
in Go and how to use templating in web applications. 
In Part I we discuss the origins of the language (ch 1) and get you started with the installation of 
Go (ch 2) and a development environment (ch 3). 
Part 2 then guides you through the core concepts of Go: the simple and composite types (ch 4, 7, 
8), control structures (ch 5), functions (ch 6), structs with their methods (ch 10), and interfaces 
(ch 11). The functional and object-oriented aspects of Go are thoroughly discussed, as well as how 
Go code in larger projects is structured (ch 9). 
Part 3 learns you how to work with files in different formats (ch 12) and how to leverage the 
error-handling mechanism in Go (ch 13). It also contains a thorough treatment of Go’s crown 
jewel: goroutines and channels as basic technique for concurrent and multicore applications (ch 
14). Then we discuss the networking techniques in Go and apply this to distributed and web 
applications (ch 15). 
Part 4 shows you a number of Go language patterns and idioms (ch 16, 17), together with a 
collection of useful code snippets (ch 18). With all of the techniques which you have learned in 
the previous chapters, a complete Go project is built (ch 19) and you get an introduction in how 
to use Go in the cloud (Google App Engine) (ch 20). In the last chapter (ch 21) we discuss some 
real world uses of go in businesses and organizations all over the world. The text is concluded with 
quotes of users, listings, references to Go packages and tools, answers to questions and exercises, 
and a bibliography of all resources and references. 
Go has very much a ‘no nonsense’ approach to it: extreme care has gone into making things easy 
and automatic; it adheres to the KISS principle from Agile programming: Keep It Short and 
Simple! 
Solving or leaving out many of the ‘open’ features in C, C++ or Java makes the developer’s life 
much easier! A few examples are: default initializations of variables; memory is allocated and 
freed automatically; fewer, but more powerful control constructs. As we will see Go also aims to 
prevent unnecessary typing, often Go code is shorter and easier to read than code from the classic 
object-oriented languages. 
xxThe Way to Go 
Go is simple enough to fit in your head, which can’t be said from C++ or Java; the barrier to entry 
is low, compared to e.g. Scala (the Java concurrent language). Go is a modern day C. 
Most of the code-examples and exercises provided interact with the console, which is not a surprise 
since Go is in essence a systems language. Providing a graphical user interface (GUI) framework 
which is platform-independent is a huge task. Work is under way in the form of a number of 3rd 
party projects, so somewhere in the near future there probable will be a usable Go GUI framework. 
But in this age the web and its protocols are all pervasive, so to provide a GUI in some examples 
and exercises we will use Go’s powerful http and template packages. 
We will always use and indicate what is called idiomatic Go-code, by which we mean code which is 
accepted as being best practice. We try to make sure that examples never use concepts or techniques 
which were not covered up until that point in the text. There are a few exceptions where it seemed 
better to group it with the discussion of the basic concept: in that case the advanced concept is 
referenced and the § can be safely skipped. 
All concepts and techniques are thoroughly explained through 227 working code examples (on a 
grey background), printed out and commented in the text and available online for execution and 
experimenting. 
The book is cross-referenced as much as possible, forward as well as backward. And of course this 
is what you must do: after setting up a Go environment with a decent editor, start experimenting 
with the code examples and try the exercises: mastering a new language and new concepts can 
only be achieved through exercising and experimenting, so the text contains 130 exercises, with 

downloadable solutions. We have used the famous Fibonacci algorithm in examples and exercises 
in 13 versions to illustrate different concepts and coding techniques in Go. 
The book has an website (https://sites.google.com/site/thewaytogo2012/) from where the code 
examples can be downloaded and on which complementary material and updates are available. 
For your convenience and further paving your path to become a Go master, special chapters are 
dedicated to the best practices and language patterns in Go, and another to the pitfalls for the Go 
beginner. Handy as a desktop-reference while coding is chapter 18, which is a collection of the 
most useful code snippets, with references to the explanations in the text. 
And last but not least, a comprehensive index leads you quickly to the page you need at the 
moment. All code has been tested to work with the stable Go-release Go 1. 
Here are the words of Bruce Eckel, a well known authority on C++, Java and Python: 
xxiIvo Balbaert 
“Coming from a background in C/C++, I find Go to be a real breath of fresh air. At this point, I think 
it would be a far better choice than C++ for doing systems programming because it will be much more 
productive and it solves problems that would be notably more difficult in C++. This is not to say that 
I think C++ was a mistake -- on the contrary, I think it was inevitable. At the time, we were deeply 
mired in the C mindset, slightly above assembly language and convinced that any language construct 
that generated significant code or overhead was impractical. Things like garbage collection or language 
support for parallelism were downright ridiculous and no one took them seriously. C++ took the first 
baby steps necessary to drag us into this larger world, and Stroustrup made the right choices in making 
C++ comprehensible to the C programmer, and able to compile C. We needed that at the time. 
We’ve had many lessons since then. Things like garbage collection and exception handling and virtual 
machines, which used to be crazy talk, are now accepted without question. The complexity of C++ (even 
more complexity has been added in the new C++), and the resulting impact on productivity, is no longer 
justified. All the hoops that the C++ programmer had to jump through in order to use a C-compatible 
language make no sense anymore -- they’re just a waste of time and effort. Now, Go makes much more 
sense for the class of problems that C++ was originally intended to solve.” 
I would like to express my sincere gratitude to the Go team for creating this superb language, 
especially “Commander” Rob Pike, Russ Cox and Andrew Gerrand for their beautiful and 
illustrative examples and explanations. I also thank Miek Gieben, Frank Müller, Ryanne Dolan 
and Satish V.J. for the insights they have given me, as well as countless other members of the 
Golang-nuts mailing list. 
Welcome to the wonderful world of developing in Go! 

xxiiPART 1 
WHY LEARN GO—GETTING STARTEDChapter 1—Origins, Context and 
Popularity of Go 
1.1 Origins and evolution 
Go’s year of genesis was 2007, and the year of its public launch was 2009. The initial design on 
Go started on September 21, 2007 as a 20% part-time project at Google Inc. by three distinguished 
IT-engineers: Robert Griesemer (known for his work at the Java HotSpot Virtual Machine), Rob 
‘Commander’ Pike (member of the Unix team at Bell Labs, worked at the Plan 9 and Inferno 
operating systems and the Limbo programming language) and Ken Thompson (member of the 
Unix team at Bell Labs, one of the fathers of C, Unix and Plan 9 operating systems, co-developed 
UTF-8 with Rob Pike). By January 2008 Ken Thompson had started working on a compiler to 
explore the ideas of the design; it produced C as output. 
This is a gold team of ‘founding fathers’ and experts in the field, who have a 
deep understanding of (systems) programming languages, operating systems and 
concurrency. 
Fig 1.1: The designers of Go: Griesemer, Thompson and Pike 
By mid 2008, the design was nearly finished, and full-time work started on the implementation 
of the compiler and the runtime. Ian Lance Taylor joins the team, and in May 2008 builds a 
gcc-frontend. 
12 
Ivo Balbaert 
Russ Cox joins the team and continues the work on the development of the language and the 
libraries, called packages in Go. On October 30 2009 Rob Pike gave the first talk on Go as a 
Google Techtalk. 
On November 10 2009, the Go-project was officially announced, with a BSD-style license (so fully 
open source) released for the Linux and Mac OS X platforms. A first Windows-port by Hector 
Chu was announced on November 22. 
Being an open-source project, from then on a quickly growing community formed itself which 

greatly accelerated the development and use of the language. Since its release, more than 200 
non-Google contributors have submitted over 1000 changes to the Go core; over the past 18 
months 150 developers contributed new code. This is one of the largest open-source teams in 
the world, and is in the top 2% of all project teams on Ohloh (source: www.ohloh.net ). Around 
April 2011 10 Google employees worked on Go full-time. Open-sourcing the language certainly 
contributed to its phenomenal growth. In 2010 Andrew Gerrand joins the team as a co-developer 
and Developer Advocate. 
Go initiated a lot of stir when it was publicly released and on January 8, 2010 Go was pronounced 
‘language of the year 2009’ by Tiobe ( www.tiobe.com, well-known for its popularity ranking of 
programming languages). In this ranking it reached its maximum (for now) in Feb 2010, being at 
the 13th place, with a popularity of 1,778 %. 
Year 
Winner 
2010 
Python 
2009 
Go 
2008 
C 
2007 
Python 
2006 
Ruby 
2005 
Java 
2004 
PHP 
2003 
C++ 
Go Programming Language of the year 2009 at TiobeThe Way to Go 
3 
TIMELINE: 
Initial design 
Public release 
Language of the 
year 2009 
Used at 
Google 
Go in Google 
App Engine 
2007 Sep 21 
2009 Nov 10 
2010 Jan 8 
2010 May 
2011 May 5 
Since May 2010 Go is used in production at Google for the back-end infrastructure, e.g. writing 
programs for administering complex environments. Applying the principle: ‘Eat your own dog 
food’: this proves that Google wants to invest in it, and that the language is production-worthy. 
The principal website is http://golang.org/: this site runs in Google App Engine with godoc (a 
Go-tool) serving (as a web server) the content and a Python front-end. The home page of this site 
features beneath the title Check it out! the so called Go-playground, a sandbox which is a simple 
editor for Go-code, which can then be compiled and run, all in your browser without having 
installed Go on your computer. A few examples are also provided, starting with the canonical 
“Hello, World!”. 
Some more info can be found at http://code.google.com/p/go/, it hosts the issue-tracker for Go bugs and -wishes: 
http://code.google.com/p/go/issues/list 
Go has the following logo which symbolizes its speed: =GO, and has a gopher as its mascot. 
Fig 1.2: The logo’s of Go 
The Google discussion-group Go Nuts (http://groups.google.com/group/golang-nuts/) is very 
active, delivering tens of emails with user questions and discussions every day. 
For Go on Google App Engine a separate group exists (https://groups.google.com/forum/#!forum/ 
google-appengine-go) although the distinction is not always that clear. The community has a Go 
language resource site at http://go-lang.cat-v.org/ and #go-nuts on irc.freenode.net is the official 
Go IRC channel. 

_

_

_

@go nuts at Twitter (http://twitter.com/#!/go nuts) is the Go project’s official Twitter account, 
_
with #golang as the tag most used.Ivo Balbaert 
There is also a Linked-in group: http://www.linkedin.com/groups?gid=2524765&trk=myg  _
ugrp ovr 
_
The Wikipedia page is at http://en.wikipedia.org/wiki/Go (programming language) 
A search engine page specifically for Go language code can be found at http://go-lang.cat-v.org/ 
go-search 
Go can be interactively tried out in your browser via the App Engine application Go Tour: http:// 
go-tour.appspot.com/ (To install it on your local machine, use: go install go-tour.googlecode.com/ 
hg/gotour). 
1.2 Main characteristics, context and reasons for developing a new language 
1.2.1 Languages that influenced Go 
Go is a language designed from the ground up, as a ‘C for the 21st century’.It belongs to the C-family, 
like C++, Java and C#, and is inspired by many languages created and used by its designers. 
There was significant input from the Pascal / Modula / Oberon family (declarations, packages) 
For its concurrency mechanism it builds on experience gained with Limbo and Newsqueak, which 
themselves were inspired by Tony Hoare’s CSP theory (Communicating Sequential Processes); this 
is essentially the same mechanism as used by the Erlang language. 
It is a completely open-source language, distributed with a BSD license, so it can be used by everybody 
even for commercial purposes without a fee, and it can even be changed by others. 
The resemblance with the C-syntax was maintained so as to be immediately familiar with a 
majority of developers, however comparing with C/C++ the syntax is greatly simplified and made 
more concise and clean. It also has characteristics of a dynamic language, so Python and Ruby 
programmers feel more comfortable with it. 
The following figure shows some of the influences: 
4The Way to Go 
Fig 1.3: Influences on Go 
1.2.2 Why a new language? 
- C/C++ did not evolve with the computing landscape, no major systems language has emerged 
in over a decade: so there is a definite need for a new systems language, appropriate for needs 
of our computing era. 
- In contrast to computing power, software development is not considerably faster or more 
successful (considering the number of failed projects) and applications still grow in size, so a 
new low-level language, but equipped with higher concepts, is needed. 
- Before Go a developer had to choose between fast execution but slow and not efficient building 
(like C++), efficient compilation (but not so fast execution, like .NET or Java), or ease of 
programming (but slower execution, like the dynamic languages): Go is an attempt to combine 
all three wishes: efficient and thus fast compilation, fast execution, ease of programming. 
1.2.3 Targets of the language 
A main target was to combine the efficacy, speed and safety of a strongly and statically compiled 
language with the ease of programming of a dynamic language, so as to make programming more 
fun again. 
So the language is type-safe, and it is also memory-safe: pointers are used in Go, but pointer-arithmetic 
is not possible. 
56 
Ivo Balbaert 
Another target (and of course very important for internal use in Google) was that it should give 
excellent support for networked-communication, concurrency and parallelization, in order to get 
the most out of distributed and multicore machines. It is implemented through the concepts of 
goroutines, which are very lightweight-threads, and channels for communication between them. 
They are implemented as growing stacks (segmented stacks) and multiplexing of goroutines onto 
threads is done automatically. 
This is certainly the great stronghold of Go, given the growing importance of multicore and 
multiprocessor computers, and the lack of support for that in existing programming languages. 
Of the utmost importance was also the building speed (compilation and linking to machine code), 
which had to be excellent (in the order of 100s of ms to a few s at most). This was born out of 
frustration with the build-times of C++-projects, heavily used in the Google infrastructure. This 
alone should give an enormous boost to developer productivity and give rise to a tighter test-code 
development cycle. 
Dependency management is a big part of software development today but the “header files” of 
languages in the C tradition are causing considerable overhead leading to build times of hours for 
the great projects. A rigid and clean dependency analysis and fast compilation is needed. This is 
what Go provides with its package model: explicit dependencies to enable faster builds. The package 
model of Go provides for excellent scalability. 

_

The entire Go standard library compiles in less than 20 seconds; typical projects compile in half a 
second: this lightning fast compiling process, even faster than C or Fortran, makes compilation a 
non-issue. Until now this was regarded as one of the great benefits of dynamic languages because 
the long compile/link step of C++ could be skipped, but with Go this is no longer an issue! 
Compilation times are negligible, so with Go we have the same productivity as in the development 
cycle of a scripting or dynamic language. 
On the other hand, the execution speed of the native code should be comparable to C/C++. 
Because memory-problems (so called memory-leaks) are a long time problem of C++, Go’s designers 
decided that memory-management should not be the responsibility of the developer. So although 
Go executes native code, it runs in a kind of runtime, which takes care of an efficient and fast 
garbage collection (at this moment a simple mark- and sweep algorithm). 
Garbage collection, although difficult to implement for that kind of problems, was considered 
crucial for the development of the concurrent applications of the future. 
It also has a built-in runtime reflection capability.The Way to Go 
go install provides an easy deployment system for external packages. 
Furthermore there is support for legacy software, notably C libraries can be used (see § 3.9). 
1.2.4 Guiding design principles 
Go tries to reduce typing, clutter and complexity in coding through a minimal amount of keywords 
(25). Together with the clean, regular and concise syntax, this enhances the compilation speed, 
because the keywords can be parsed without a symbol table. 
These aspects reduce the number of code lines necessary, even compared with a language like 
Java. 
Go has a minimalist approach: there tends to be only one or two ways of getting things done, so 
reading other people’s code is generally pretty easy, and we all know readability of code is of the 
utmost importance in software engineering. 
The design concepts of the language don’t stand in each other’s way, they don’t add up complexity 
to one another: they are orthogonal. 
Go is completely defifined by an explicit specifification that can be found at http://golang.org/doc/ 
go spec.html; 
it is not defifined by an implementation, as is Ruby for example. An explicit language specifification 
was a requirement for implementing the two different compilers gc and gccgo (see § 2.1), and this 
in itself was a great help in clarifying the specification. 
The Go grammar is LALR(1) (http://en.wikipedia.org/wiki/LALR parser), this can be seen in src/ 
cmd/gc/go.y); it can be parsed without a symbol table. 
1.2.5 Characteristics of the language 
It is essentially an imperative (procedural, structural) kind of language, built with concurrency in 
mind. 
It is not object-oriented in the normal sense like Java and C++ because it doesn’t have the concept 
of classes and inheritance. However it does have a concept of interfaces, with which much of 
polymorphism can be realized. Go has a clear and expressive type-system, but it is lightweight and 
without hierarchy. So in this respect it could be called a hybrid language. 
78 
Ivo Balbaert 
Object-orientation as in the predominant OO-languages was considered to be too ‘heavy’, 
leading to often cumbersome development constructing big type-hierarchies, and so not 
compliant with the speed goal of the language. 
Functions are the basic building block in Go, and their use is very versatile. In chapter 6 we will see 
that Go also exhibits the fundamental aspects of a functional language. 
It is statically typed, thus a safe language, and compiles to native code, so it has a very efficient 
execution. 
It is strongly typed: implicit type conversions (also called castings or coercions) are not allowed; the 
principle is: keep things explicit! 
It has certain characteristics of a dynamically typed language (through the var keyword). 
So it also appeals to programmers who left Java and the .Net world for Python, Ruby, PHP and 
Javascript. 
Go has support for cross-compilation: e.g. developing on a Linux-machine for an application that 
will execute on Windows. It is the first programming language in which UTF-8 can be used, not 
only in strings, but also in program code (Go source-files are UTF-8): Go is truly international! 
1.2.6 Uses of the language 
Go was originally conceived as a systems programming language, to be used in the heavy server-centric 
(Google) world of web servers, storage architecture and the like. For certain domains like high 
performance distributed systems Go has already proved to be a more productive language than most 
others. Go shines in and makes massive concurrency easy, so it should be a good fit for game server 
development. 

_

_

_

Complex event processing (CEP, see http://en.wikipedia.org/wiki/Complex event processing), where 
one needs both mass concurrency, high level abstractions and performance, is also an excellent 
target for Go usage. As we move to an Internet of Things, CEP will come to the forefront. 
But it turned out that it is also a general programming language, useful for solving text-processing 
problems, making frontends, or even scripting-like applications. 
However Go is not suited for real-time software because of the garbage collection and automatic 
memory allocation.The Way to Go 
Go is used internally in Google for more and more heavy duty distributed applications; e.g. a part 
of Google Maps runs on Go. 
Real life examples of usage of Go in other organizations can be found at http://go-lang.cat-v.org/ 
organizations-using-go. Not all uses of Go are mentioned there, because many companies consider 
this as private information. An application has been build inside Go for a large storage area network 
(SAN).(See Chapter 21 for a discussion of a sample of current use cases). 
A Go compiler exists for Native Client (NaCl) in the Chrome-browser; it will probably be used for 
the execution of native code in web applications in the Chrome OS. 
Go also runs on Intel as well as ARM processors (see chapter 2), so it runs under the Android OS, 
for example on Nexus smartphones. 
Go on Google App Engine: on May 5 2011 a Go SDK appeared to use the language in the Cloud 
in web applications via the Google App Engine infrastructure, making it the first true compiled 
language that runs on App Engine, which until then only hosted Python and Java apps. This was 
mainly the work of David Symonds and Nigel Tao. The latest stable version is SDK 1.6.1 based on 
r60.3, released Dec 13 2011. The current release is based on Go 1 (Beta). 
1.2.7 Missing features? 
A number of features which can be found in most modern OO-languages are missing in Go, some 
of them might still be implemented in the future. 
- No function or operator overloading: this is to simplify the design. 
- No implicit conversions: this is by design, to avoid the many bugs and confusions arising from 
this in C/C++ 
- No classes and type inheritance: Go takes another approach to object-oriented design (chapter 
10-11) 
- No variant types: almost the same functionality is realized through interfaces (see chapter 11) 
- No dynamic code loading 
- No dynamic libraries 
- No generics 
- No exceptions (although recover / panic (see § 13.2-3) goes a lot in that direction) 
- No assertions 
- No immutable variables 
A discussion around this from the Go-team themselves can be found in the Go FAQ: http:// 
golang.org/doc/go faq.html 
9Ivo Balbaert 
1.2.8 Programming in Go 
When coming to Go and having a background in other contemporary (mostly class or 
inheritance-oriented languages like Java, C#, Objective C, Python, Ruby) you can fall in the trap 
of trying to program in Go like you did in your X-language. Go is built on a different model, so 
trying to move code from X to Go usually produces non-idiomatic code and overall works poorly: 
you have to start over, thinking in Go. 
If you take a higher point of view and start analyzing the problem from within the Go mindset, 
often a different approach suggests itself which leads to an elegant and idiomatic Go-solution. 
1.2.9 Summary 
Here are the killer features of Go: 
▪ Emphasis on simplicity: easy to learn 
▪ Memory managed and syntactically lightweight: easy to use 
▪ Fast compilation: enhances productivity (dev cycle of a scripting language) 
▪ Fast compiled code: comparable to C 
▪ Concurrency support: write simpler code 
▪ Static typing 
▪ Consistent standard library 
▪ Easy deployment system (go install) 
▪ Self-documenting (and well-documented) 
▪ Free and Open Source (BSD licensed) 
10Chapter 2—Installation and Runtime Environment 
2.1 Platforms and architectures 
The Go-team developed compilers for the following operating systems (OS): 

_

- Linux 
- FreeBSD 
- OS X (also named Darwin) 
There are 2 versions of compilers: the gc Go-compilers and gccgo; they both work on Unix-like 
systems. The gc compiler/runtime has been ported to Windows and is integrated in the main 
distribution. Both compilers work in a single-pass manner. 
Go 1 is available in source and binary form on these platforms: 
FreeBSD 7+: amd64, 386 
Linux 2.6+: amd64, 386, arm 
OS X (Snow Leopard + Lion): amd64, 386 
Windows (2000 + later): amd64, 386 
The portability of Go-code between OS’s is excellent (assuming you use pure Go-code, no cgo, 
inotify or very low level packages): just copy the source code to the other OS and compile, but you 
can also cross compile Go sources (see § 2.2). 
(1) The gc Go-compilers: 
They are based on Ken Thompson’s previous work on the C toolchain for the Plan 9 operating 
system. 
The Go compilers and linkers are written in C and produce native code (there is no Go 
bootstrapping or self-hosting involved), so a different compiler (instruction set) is required for 
every combination of processor-architecture (32 bit and 64 bit, no others at this point) and OS. 
1112 
Ivo Balbaert 
They compile faster than gccgo and produce good native code; they are not linkable with gcc; they 
work non-generational, non-compacting and parallel. 
Compilers exist for the following processor-architectures from Intel and AMD: 
No of bits 
Processor name 
Compiler 
Linker 
64 bit 
implementation 
amd64 (also named 
x86-64) 
6g 
6l 
32 bit 
implementation 
386 (also named 
x86 or x86-32) 
8g 
8l 
32 bit RISC 
implementation 
arm (ARM) 
5g 
5l 
The naming system is a bit strange at first sight (the names come from the Plan 9-project): 
g = compiler: makes object code from source code (program text) 
l = linker: transforms object code into executable binaries (machine code) 
( The corresponding C-compilers are: 6c, 8c and 5c; and the assemblers are: 6a, 8a and 5a . ) 
The following OS-processor combinations are released: 
OS 
ARCH 
OS version 
linux 
386 / amd64 / arm 
>= Linux 2.6 
darwin 
386 / amd64 
OS X (Snow Leopard + Lion) 
freebsd 
386 / amd64 
>= FreeBSD 7 
windows 

386 / amd64 
>= Windows 2000 
The windows implementation (both 8g and 6g) is realized by external contributors and is 95% 
complete. 
The Google-team is committed to the arm implementation, it can eventually be used in the 
Android OS in Google’s smartphones: Go runs wherever Android will run. 
Flags: these are options which are given on the command-line and that can influence the 
compilation/linking or give a special output.The Way to Go 
13 
The compiler flags are: 
C:\Users\ivo>8g 
gc: usage: 8g [flags] file.go... 
flags: 
-I DIR search for packages in DIR 
-d print declarations 
-e no limit on number of errors printed 
-f print stack frame structure 
-h panic on an error 
-o file specify output file // see § 3.4 
-S print the generated assembly code 
-V print the compiler version // see § 2.3 (7) 
-u disable package unsafe 
-w print the parse tree after typing 
-x print lex tokens 
- I can be used to indicate the map in which the Go files to compile are (it can also 
contain the variable $GOPATH) 
The linker flags are: 
C:\Users\ivo>8l 
usage: 8l [-options] [-E entry] [-H head] [-I interpreter] [-L dir] [-T text] [-R 
rnd] [-r path] [-o out] main.8 
- L can be used to indicate the map in which the Go files to link are (it can also contain 
the variable $GOPATH) 
In depth-info: The sources of the compilers and linkers can be found under $GOROOT/ 
src/cmd. Modifying the Go language itself is done in C code, not Go. The lexer/parser 
is generated with GNU bison. The grammar/parser is controlled by the yacc file go.y at 
$GOROOT/src/cmd/gc/go.y and the output is y.tab.{c,h} in the same directory. See the 
Makefile in that directory for more about the build process. An overview of the build process 
can be seen by examining $GOROOT/src/make.bash 
Most of the directories contain a file doc.go, providing more information. 
(2) The gccgo-compiler: 
This is a more traditional compiler using the GCC back-end: the popular GNU compiler, 
which targets a very wide range of processor-architectures. Compilation is slower, but the 
generated native code is a bit faster. It also offers some interoperability with C.14 
Ivo Balbaert 
From 25-3-2011 on with GCC Release 4.6.0 the Go-compiler was integrated in the family 
of supported languages (containing also Ada, C, C++, Fortran, Go and Java). 
(for more information see: http://golang.org/doc/gccgo) 
Since Go 1 both compilers (gc and gccgo) are on par: equivalent in their functionality. 
(3) File extensions and packages: 
The extension for Go source code files is not surprisingly 
.go 
C files end in .c and assembly files in .s; Source code-files are organized in packages. Compressed 
files for packages containing executable code have the extension .a (AR archive) 
The packages of the Go standard library (see § 9.1) are installed in this format. 
Linker (object- ) files can have the extension 
.o 
An executable program has by default the extension .out on Unix and .exe on Windows. 
Remark: When creating directories for working with Go or Go-tools, never use spaces in 
the directory name: replace them by   for example. 
2.2 Go Environment variables 
The Go-environment works with a small number of OS environment variables. They are 
best defined before the installation starts; on Windows you will have to create the empty Go 
root map first, like c:/go. Here are the most important: 
$GOROOT 
mostly it has the value $HOME/go, but of course you can choose this: it 
is the root of the go tree (or installation) 
$GOARCH 

_

the processor-architecture of the target machine, one of the values of the 
2nd column of fig 2.1: 386, amd64, arm. 
$GOOS 
the operating system of the target machine, one of the values of the 1st 
column of fig 2.1: darwin, freebsd, linux, windows 
$GOBIN 
the location where the binaries (compiler, linker, etc.) are installed, 
default is $GOROOT/bin 
The target machine is the machine where you are going to run the Go-application. The Way to Go 
15 
The Go-compiler architecture enables cross-compiling: you can compile on a machine( = the 
host) which has other characteristics (OS, processor) than the target machine. 
To differentiate between them you can use $GOHOSTOS and $GOHOSTARCH: these 
are the name of the host operating system and compilation architecture: set them when 
cross-compiling to another platform/architecture. ( They default to the local system and 
normally take their values from $GOOS and $GOARCH ). 
Host (H) 
developing on 
Target (T) 
running on 
Examples 
GOHOSTARCH GOHOSTOS GOARCH GOOS 
H: 64 bit Linux 
T: 32 bit Linux 
amd64 
linux 
386 
linux 
H: 32 bit Linux 
T: 64 bit Linux 
386 
linux 
amd64 
linux 
H: 32 bit Windows 
T: 64 bit Linux 
386 
windows 
amd64 
linux 
The following variables can also be of use: 
$GOPATH 
defaults to GOROOT, it specifies a list of paths that contain 
Go source code package binaries (objects), and executables 
(command binaries); they are located inside the GOPATHs’ 
src, pkg, and bin subdirectories respectively; this variable must 
be set in order to use the go tool. 
$GOROOT FINAL 
defaults equal to $GOROOT, so doesn’t need to be set explicitly. 
If after installation of Go, you want to move the installation to 
another location, this variable contains the final location. 
$GOARM 
for arm-architectures, possible values are 5, 6; default is 6 
$GOMAXPROCS 
specifies the number of cores or processors your application 
uses, see § 14.1.3 
In the following sections we discuss the installation of Go on the operating systems where it is feature 
complete, that is: Linux, OS X and Windows. For FreeBSD this is also the case, but installation is 
very similar to that on Linux. Porting Go to other OS’s like OpenBSD, DragonFlyBSD, NetBSD, 
Plan 9, Haiku and Solaris are in progress, the most recent info can be found on: http://go-lang. 
cat-v.org/os-ports16 
Ivo Balbaert 
2.3 Installing Go on a Linux system 
It is instructive to download and compile the full source-code of Go yourself. Full and up 

_

to date instructions can be found at http://golang.org/doc/install.html, but we will review 
and comment them here: 
(1) Set Go-Environment variables: 
On a Linux system, set these variables in your shell profile, which is the $HOME/.bashrc file 
or the $HOME/.profile or equivalent (use an editor like gedit or vi): 
export GOROOT=$HOME/go 
export GOBIN=$GOROOT/bin 
export GOARCH=amd64 
export GOOS=linux 
To ensure that the binaries can be found from anywhere in the filesystem, also add this 
line: 
export PATH=$GOBIN:$PATH 
The go tool also uses the variable GOPATH: 
export GOPATH=$HOME/goprograms 
or: 
export GOPATH=$GOROOT 
$HOME is /home/user1 if your are logged in as user1. 
Adding the current directory.: 
export GOPATH=$GOPATH:. 
GOPATH may be set to a colon ( : )-separated list of paths inside which Go source code, 
package objects, and executables may be found. 
After the changes restart terminal or reload .bashrc with: source .bashrc 
(test the values with env | grep ^GO or echo $GOROOT etc. in a terminal window) 
(2) Install C-tools: 
The Go tool-chain is written in C, so for the build-process you need these programs:The Way to Go 
17 
• GCC, 
• the standard C libraries Libc6-dev, 
• the parser generator Bison, 
• make, 
• gawk 
• the text editor ed. 
With the following command these tools are installed if necessary on Debian-based Linux 
systems, like Ubuntu: 
sudo apt-get install bison ed gawk gcc libc6-dev make 
On other Linux distributions RPM’s can be used. 
(3) Install Mercurial: 
The Go source-code is maintained in the Mercurial revision control application. Type hg on 
the command-line to see if this application is installed. 
If not, install it with: 
sudo apt-get install mercurial 
If this produces an error, on Ubuntu/Debian systems you might have to do first: 
apt-get install python-setuptools python-dev build-essential 
If this fails, try installing manually from the Mercurial download page: http://mercurial. 
selenic.com/wiki/Download 
Mercurial versions 1.7.x and up require the configuration of Certification 
Authorities (CAs). Error messages of the form: warning: go.googlecode.com certificate 
with fingerprint b1:af: ... bc not verified (check hostfingerprints or web.cacerts config 
setting) when using Mercurial indicate that the CAs are missing. Check your Mercurial 
version (hg --version) and configure the CAs if necessary. 
(4) Fetch the Go repository: 
Go will install to a directory named go, indicated by the value of $GOROOT. This directory 
should not exist. Then check out the repository with the command: 
hg clone -u release https://go.googlecode.com/hg/ $GOROOT18 
Ivo Balbaert 
(5) Build Go: 
cd $GOROOT/src 
./all.bash 
This building and testing takes some time (order of minutes) and then when successful the 
following text appears: 
ALL TESTS PASSED 
--- 
Installed Go for linux/amd64 in /home/you/go. 
Installed commands in /home/you/go/bin. 
*** You need to add /home/you/go/bin to your $PATH. *** 
The compiler is 6g. 
adapted to the system you have installed Go on. 
Remark 1: If you encounter an error in the make cycle, pull an update on the repository 
with 

_

_

_

_

_

hg pull –u and restart step (5) . 
Remark 2: 
the net test: 
One of the http tests (net) goes out and touches google.com. 
An often reported problem is that the installation pauses indefinitely at: 
‘make[2]: Leaving directory `/localusr/go/src/pkg/net’ 
If you develop on a machine behind a firewall, it can be necessary to temporarily disable the 
firewall while building everything. 
Another way to solve this is to use $DISABLE NET TESTS to bypass network tests: set in your 
shell profile .bashrc: export DISABLE NET TESTS=1 
If this doesn’t work you can disable the test of the net package by adding net to the NOTEST 
list in the Makefile in the map go/src/pkg . 
If you don’t want to run the tests, you can leave them out by running ./make.bash 
instead.The Way to Go 
19 
(6) Testing the installation: 
Using your favorite text-editor, make a file with the following code, and save this as test.go: 
Listing 2.1—hello world1.go: 
package main 
func main() { 
println(“Hello”, “world”) 
} 
Compile this first Go-program with: 
6g test.go 
This compiles to a file: 
test.6 
which is linked with the command: 
6l test.6 
This produces the executable named: 
6.out 
which executes with the command: 
./6.out 
and produces the output: 
Hello, world 
(This is on a 64 bit installation, use 8g / 8l for 32 bit, or 5g / 5l for arm.) 
(7) Verifying the release of the installation: 
The Go-releases are identified by their version number and a 
• release-number for stable releases, like release.r60 9481 
• release-date for weekly releases, like release.2011-01-06 release 7053 
Verify the installed release with: 
cd $GOROOT 
hg identify 
A quicker way is to use go version or the –V flag of the compiler: 6g –V or 8g –V which 
gives an output like: 8g version 7053 release.2011-01-06 release 
From within Go-code, the current release which is executing can be obtained with the 
function Version from the package runtime: 
Listing 2.2—version.go: 
package main 
import ( 
“fmt” 
“runtime”Ivo Balbaert 
) 
func main() { 
fmt.Printf(“%s”, runtime.Version()) 
} 
Output: 7053 release.2011-01-06 release 
(8) Update the installation to a newer release: 
cd $GOROOT 
hg pull 
hg update release 
cd src 
sudo ./all.bash 
The latest releases can be viewed at: http://golang.org/doc/devel/release.html 
Remark about releases: The first stable Go-release was r56 (2011.03.16) 
From 15-3-2011 onwards there are still weekly releases with the latest additions/updates, to 
be downloaded with hg update weekly. The latest release is Go 1 and this is the first stable 
release which will be maintained and supported on a timescale of years. 
Distinction is made between the following branches in the Go repository: 

- Go release: these are the stable releases, best suited for most Go-development 
- Go weekly: containing the last changes, roughly once a week 
- Go tip: the latest release 
The last 2 are normally only necessary when you urgently need the fixes or improvements; 
update through hg update weekly or hg update tip. 
The gofix—tool can be used to update Go source-code (written in an older release) to the 
latest release. 
Documentation for the different releases: 
http://golang.org/pkg shows documentation for the latest stable release; it us updated when 
the next release happens. Documentation for the latest weekly is at: http://weekly.goneat. 
org/pkg/ Documentation for tip can be found at: http://tip.goneat.org/pkg/ (at some point 
20The Way to Go 
‘goneat’ in these url’s will be replaced by ‘golang’: http://weekly.golang.org/pkg/—http://tip. 
golang.org/pkg/) 
Installation from a package: 
Information about packaged Go-installations can be found at: http://go-lang.cat-v.org/ 
packages. A package for the Ubuntu installation can be downloaded from (23/2/2011): 
https://launchpad.net/~cz.nic-labs/+archive/golang 
2.4 Installing Go on an OS X system 
Your Mac-system must contain an Intel 64 bit-processor, PowerPC processors are not yet 
supported. Follow the instructions from § 2.3 
(A port to PowerPC is in progress: https://codedr-go-ppc.googlecode.com/hg/) 
Remarks: 
Install C-tools: they are installed as part of Xcode, so this is necessary. 
Install the Xcode.mpkg from the Optional Installs on my Snow Leopard DVD to 
get gcc-4.3 installed.Do mkdir $GOBIN before the compile-step (5). 
A detailed instruction can be found at: 
http://www.kelvinwong.ca/2009/11/12/installing-google-go-on-mac-os-x-leopard/ 
2.5 Installing Go on a Windows system 
Go directly in Windows: http://code.google.com/p/go/wiki/WindowsPort 
Based on previous work by Hector Chu, Joe Poirier takes care of the Windows release. 
A zip-file with a binaries release for win32/win64 can be downloaded from: http://code. 
google.com/p/gomingw/downloads/list 
Unzipping this file creates a go directory structure, with the map go/bin containing all the 
necessary binaries to run Go. Then you have to add the Go-variables manually: 
2122 
Ivo Balbaert 
Start, Computer, RMouse: Properties, in the Menu: choose Advanced System Settings; click 
the button: Environment Variables, System Variables, New: 
Variable name 
Variable value (for example) 
GOROOT 
c:\go 
GOBIN 
c:\go\bin 
GOOS 
windows 
GOARCH 
386 
In the same dialog-window: Edit the PATH-variable: add the GOBIN map followed by ; in 
front, like this: %GOBIN%;…rest of PATH… 
There is also a GO installer executable gowin32 releasedate installer.exe which adds the 
Go-environment variables and adds GOBIN to the PATH. 
Testing the installation: 
make the file hello world1.go
Compile this first Go-program with: 
8g test.go 
This compiles to a file: 
test.8 
which is linked with the command: 
8l test.8 
This produces the executable named: 
8.out.exe 
which executes with the command: 
8.out.exe 

 (see § 2.3 (6) ) 

_

_

_

_

_

and produces the output: 
hello, world 
Possible problem: 
8g test.go 
test.go:3: fatal error: can’t find import: fmt 
The cause can be that the GO-variables are not set properly, or that the submap of pkg 
doesn’t have the right name, it should be: E:\Go\GoforWindows\gowin32 release\go\ 
pkg\windows 386 for example, where release is substituted with the exact date or release 
_
number, e.g. 2011-01-06 
You can set the GO-variables also on the command-line, like: 
set GOROOT=E:\Go\GoforWindows\gowin32 release.r60\go 
set GOBIN=$GOROOT\bin 
set PATH=%PATH%;$GOBIN 
Executing 8g then finds the import path to the packages.The Way to Go 
(2) Go in a virtual machine running Linux in Windows: 
In this option you run Go in e.g. Linux in a virtual machine in Windows. 
A good choice is VMware: http:// www.vmware.com 
Download the VMware player: http://www.vmware.com/products/player/ 
Search in Virtual Appliances for a Linux-platform, download and install it; then follow the 
instructions from § 2.3 
(3) Go in Wubi: dual booting in Windows: 
Another alternative is to install an Ubuntu-Linux side by side with Windows (using the 
Windows filesystem) through Wubi: http://www.wubi-installer.org. Then you have Linux 
without having to partition hard-drives. Install Go in this Linux by following the instructions 
from § 2.3 
Of course a real partitioning of the hard-drive system of the machine can also be done, so 
that Linux is installed as a really separate OS, side by side with Windows. 
Information on other OS-ports (FreeBSD, OpenBSD, DragonFlyBSD, NetBSD, Plan 9, 
Haiku, Solaris can be found here: http://go-lang.cat-v.org/os-ports 
(4) Express-Go: 
Express Go is a bytecode implementation of Go programming language for Windows made 
by Alexey Gokhberg and announced March 28 2011. The software is based on code of gc 
Go compiler and tools. The original code has been ported from C to C++ (Visual C++ 2008 
Express Edition has been used as a development platform). The concepts, architecture, and 
code of the original gc implementation have been reused as much as possible, however, 
Express Go generates MSIL bytecode for the .NET virtual machine instead of the native 
machine code. 
It includes an implementation of the virtual machine based on the just-in-time compilation 
(JIT) principle. The JIT virtual machine reads a bytecode executable file and compiles its 
content intothe native machine code prior to execution.The virtual machine has been designed 
from scratch. The instruction set was intentionally made low-level and language-independent. 
High-level language-specific features are to be supported by the runtime libraries built into 
the interpreter. The original Go runtime library was partially ported to C++ and integrated 
23Ivo Balbaert 
into the interpreter of the virtual machine.Memory management is implemented using the 
Boehm-Demers-Weiser conservative garbage collector. 
The binary distribution is located here: 
http://www.unicorn-enterprises.com/download/express go.zip 
For more detailed information: see 
http://www.unicorn-enterprises.com/express go.html 
(5) Building Go on Windows: To be able to do this, you first have to install the MINGW/ 
MINSYS environment. Note that in the MINGW environment you must use Unix like / 
instead of the Windows \ ! 
(A) Via MINGW zipfile: 
With this method there is no restriction on where the MinGW folder can reside. 
Download gowin-env.zip from https://bitbucket.org/akavel/gowin-env/downloads 
An then unzip it into e.g. E:\Go\GoforWindows\MinGW 
There are 2 batch files in the root of the MinGW folder: go-env.bat and run-mingw.bat 
Set the Go environment variables in go-env.bat, for example: 
set GOARCH=386 
set GOOS=windows 
set GOROOT=E:\Go\GoforWindows\gowin32 release.r59\go 
set GOBIN=%GOROOT%\bin 
set GOPATH=%GOROOT% 
run-mingw.bat will import the environment variables from go-env.bat if it exists 
Starting the MINGW-environment via command window: 
open the command window: cmd in Start, Search box 

_

_

_

go to MINGW installation map: e.g. cd E:\Go\GoforWindows\MinGW 
run-mingw.bat (or run-mingw-mintty.bat) 
this starts a new command window 
24The Way to Go 
(B) Via Windows installation: 
Download and save the latest version from: 
http://sourceforge.net/projects/mingw/files/Automated%20MinGW%20Installer/ 
mingw-get-inst/ 
Open and run the saved automated MinGW installer executable file, which is 
named mingw-get-inst-yyyymmdd.exe, where yyyymmdd is the version date stamp 
(e.g. mingw-get-inst-20110802.exe). 
The MinGW Setup Wizard window will open with the title “Setup—MinGW-Get”. Except 
for the following, accept the setup defaults, unless it’s necessary to change them. 
For Repository Catalogues: check the Download latest repository catalogues button. 
For Select Components: the MinGW Compiler Suite, the C Compiler box is automatically 
checked. Scroll down to the bottom of the list and check the MinGW Developer ToolKit 
box, which includes the MSYS Basic System. 
Before Ready to Install, review and verify the installation settings, which should look similar 
this: 
Installing: 
mingw-get 
pkginfo 
C Compiler 
MSYS Basic System 
MinGW Developer Toolkit 
Downloading latest repository catalogues 
Destination location: 
C:\MinGW 
When the installation settings are correct, install. 
The installation loads the package installation catalogues and downloads and installs the 
files. The installation may take some time, largely depending on the download speed. 
Add the Go-environment variable settings (see A)) in the beginning of msys.bat 
2526 
Ivo Balbaert 
The MSYS command window may be opened by opening and running the C:\MinGW\ 
msys\1.0\msys.bat batch file or via the Start menu by choosing: MinGW / MinGW Shell. 
How to build Go on Windows: 
To download the Go-source you will need an hg client for Windows, download and install 
the binary package from http://mercurial.selenic.com/wiki/Download 
Download the Go source by entering the following on the command line: 
$ hg clone -r release https://go.googlecode.com/hg/ $GOROOT 
Make a bin directory under $GOROOT. 
cd to the src directory: $ cd GOROOT/src and then build Go with: $ ./all.bash 
2.6 What is installed on your machine? 
The Go tree as the installation is called has the following structure under the go-root map 
($GOROOT): 
README, AUTHORS, CONTRIBUTORS, LICENSE 
\bin 
all executables, like the compilers and the go-tools 
\doc 
tutorial programs, codewalks, local documention, talks, logo’s, … 
\include 
C/C++ header files 
\lib 
templates for the documentation 
\misc 
configuration files for editors for working with Go, cgo examples, … 
\pkg\os arch 
_
with os arch e.g. linux amd64, windows 386, … 
_
_
the object files (.a) of all the packages of the standard library 
\src 
bash-scripts and make command files 
\cmd 
scripts and source files (Go, C) of the compilers and commands 
\lib9 \libbio \libmach : C-files 
\pkg 

_

Go source files of all packages in the standard library (it is open source!) 
On Windows 386 release r59 comprises 3084 files in 355 maps, amounting to 129 Mb. 
On Linux 64 bit release r60 comprises 3958 files, totaling 176 Mb.The Way to Go 
27 
2.7 The Go runtime 
Although the compiler generates native executable code, this code executes within a runtime 
(the code of this tool is contained in the package runtime). This runtime is somewhat 
comparable with the virtual machines used by the Java and .NET-languages. It is responsible 
for handling memory allocation and garbage collection (see also § 10.8), stack handling, 
goroutines, channels, slices, maps, reflection, and more. 
runtime is the “top level” package that is linked into every Go package, and it is mostly 
written in C. It can be found in $GOROOT/src/pkg/runtime/ (see the mgc0.c and other 
m* files in that Directory). 
Garbage collector: 
6g has a simple but effective mark-and-sweep collector. Work is 
underway to develop the ideas in IBM’s Recycler garbage collector to build a very efficient, 
low-latency concurrent collector. Gccgo at the moment has no collector; the new collector 
is being developed for both compilers. Having a garbage-collected language doesn’t mean 
you can ignore memory allocation issues: allocating and deallocating memory also uses 
cpu-resources. 
Go executable files are much bigger in size than the source code files: this is precisely because 
the Go runtime is embedded in every executable. This could be a drawback when having 
to distribute the executable to a large number of machines. On the other hand deployment 
is much easier than with Java or Python, because with Go everything needed sits in 1 static 
binary, no other files are needed. There are no dependencies which can be forgotten or 
incorrected versioned. 
2.8 A Go interpreter 
Because of the fast compilation and (as we will see) the resemblance with dynamic languages 
the question easily arises whether Go could be implemented in a read-eval-print loop like in 
these languages. Such a Go interpreter has been implemented by Sebastien Binet and can 
be found at: 
https://bitbucket.org/binet/igo28 
Chapter 3—Editors, IDE’s and Other tools. 
Because Go is still a young language work on (plugins for) IDE’s is still in progress, however there 
is some very decent support in certain editors. Some environments are cross-platform (indicated 
by CP) and can be used on Linux, OS X and Windows. 
Consult http://go-lang.cat-v.org/text-editors/ for the latest information. 
3.1 Basic requirements for a decent Go development environment 
What can you expect from an environment giving above what you could accomplish with a 
simple text-editor and the compiler/link tools on the command-line ? Here is an extensive 
wish-list: 
(1) Syntax highlighting: this is of course crucial, and every environment cited provides 
configuration- or settings files for this purpose; preferably different color-schemes (also 
customizable) should be available. 
(2) Automatic saving of code, at least before compiling. 
(3) Line numbering of code must be possible. 
(4) Good overview and navigation in the codebase must be possible; different source-files 
can be kept open. 
Possibility to set bookmarks in code. 
Bracket matching. 
From a function call, or type use, go to the definition of the function or type. 
(5) Excellent find and replace possibilities, the latter preferably with preview. 
(6) Being able to (un)comment lines and selections of code. 
(7) Compiler errors: double clicking the error-message should highlight the offending 
codeline. 
(8) Cross platform: working on Linux, Mac OS X and Windows so that only 1 
environment needs to be learned / installed. 
(9) Preferably free, although some developers would be willing to pay for a qualitatively 
high environment, which distinguishes itself from the rest. 
(10) Preferably open-sourceThe Way to Go 
(11) Plugin-architecture: so its relatively easy to extend or replace a functionality by a new 
plugin. 
(12) Easy to use: an IDE is a complexer environment, but still it must have a lightweight 

feel. 
(13) Code snippets (templates): quick insertion of of much used pieces of code can ease 
and accelerate coding. 
(14) The concept of a Go project, with a view of its constituent files and packages, and 
where the Makefile typically plays the role of configuration file. Closely related is the 
concept of a build system: it must be easy to compile/link (= build), clean (remove 
binaries) and/or run a program or a project. Running a program should be possible in 
console view or inside the IDE. 
(15) Debugging capabilities (breakpoints, inspection of values, stepping through executing 
code, being able to step over the standard library code). 
(16) Easy acces to recent files and projects. 
(17) Code completion (intellisense) capabilities: syntax-wise (keywords), packages, types 
and methods within packages, program types, variables, functions and methods; 
function signatures. 
(18) An AST-view (abstract syntax tree) of a project/package code. 
(19) Built-in go tools, such as: go fmt, go fix, go install, go test, … 
(20) Convenient and integrated browsing of go documentation. 
(21) Easy switching between different Go-environments (8g, 6g, different installation 
root, …) 
(22) Exporting code to different formats, such as pdf, html or even printing of the 
code. 
(23) Project templates for special kind of project (such as a web application, an App Engine 
project) to get you started quickly. 
(24) Refactoring possibilities. 
(25) Integration with version control-systems like hg or git. 
(26) Integration with Google App Engine. 
3.2 Editors and Integrated Development Environments 
Syntax highlighting and other Go-utilities exist for the following editors: Emacs, Vim, 
Xcode3, KD Kate, TextWrangler, BBEdit, McEdit, TextMate, TextPad, JEdit, SciTE, Nano, 
Notepad++, Geany, SlickEdit, SublimeText2. 
The GEdit Linux text-editor can be made into a nice Go environment (see http://gohelp. 
wordpress.com/). 
2930 
Ivo Balbaert 
SublimeText (http://www.sublimetext.com/dev) is an innovative cross platform text-editor 
(Linux, Mac OSX, Windows) with extensions for a lot of programming languages, in 
particular for Go a plugin GoSublime exists (https://github.com/DisposaBoy/GoSublime) 
which provides code completion and code snippets. 
Here are the more elaborated environments for Go-programming; some of them are plugins 
for existing (Java) environments: 
NetBeans: (commercial) Go For NetBeans plug-in, provides syntax highlighting and code 
templates http://www.winsoft.sk/go.htm ; a new free plugin is in the making: http://www. 
tunnelvisionlabs.com/downloads/go/ 
gogo: A basic environment for Linux and Mac: http://www.mikeparr.info/golinux.html 
GoIde: (CP) is a plugin for the IntelliJ IDE: http://go-ide.com/ 
Download it from https://github.com/mtoader/google-go-lang-idea-plugin 
Nice editing features and code-completion support, 
cfr: http://plugins.intellij.net/plugin/?idea&id=5047 
LiteIDE (golangide): (CP) is a nice environment for editing, compiling and running Go 
programs and -projects. Contains an abstract syntax tree (AST) viewer of the 
source code and a built-in make tool: http://code.google.com/p/golangide/ 
downloads/list 
GoClipse:(CP) is a plugin for the Eclipse IDE: http://goclipse.googlecode.com/svn/trunk/ 
goclipse-update-site/; Interesting features are automatic make file creation, and a kind of 
code completion (Content Assist via GoCode) 
If you are not familiar with the IDE’s, go for LiteIDE, else GoClipse or GoIde are good 
choices. 
Code completion is built in (e.g. in LiteIDE and GoClipse) through the GoCode plugin: 
To install gocode: 
$ git clone git://github.com/nsf/gocode.git 
$ cd gocode 
$ export GOROOT=$HOME/go 
$ export PATH=$HOME/go/bin:$PATH 
$ make installThe Way to Go 
31 

Test gocode status: 
$ gocode status 
should give as output: 
Server’s GOMAXPROCS == 2 
Package cache contains 1 entries 
Listing these entries: 
name: unsafe (default alias: unsafe) 
imports 9 declarations and 0 packages 
this package stays in cache forever (built-in package) 
In the following table we list the IDE requirements summed up in § 3.1 for the environments 
which are most advanced at this time, + means it works, ++ is better, blanc means it does not. 
Golang LiteIDE 
GoClipse 
GoIde 
Syntax highlighting 
++ 
+ 
+ 
Automatic saving 
before building 
+ 
Line numbering 
+ 
+ 
Bookmarks 
Bracket matching 
+ 
Find / Replace 
+ 
++ 
Go to definition 
(Un)Comment 
+ 
Compiler error 
double click 
++ 
+ 
Cross platform 
+ 
+ 
Free 
+ 
+ 
Open source 
+ 
+ 
Plugin-architecture 
+ 
+ 
Easy to use 
++ 
+ 
Code snippets 
Project concept 
+ 
+ 
Code Folding 
Build system 
+ 
+ 
Debugging 
+ 
+32 
Ivo Balbaert 
Recent files and 
projects 

+ 
+ 
Code completion 
+ 
++ 
AST-view of code 
++ 
+ 
Built-in go tools 
+ 
+ 
Browsing of go 
documentation 
+ 
Easy switching 
different 
Go-environments 
++ 
+ 
Exporting code to 
different formats 
++ 
+ 
Project templates 
Integration 
with version 
control-systems 
Integration with 
Google App Engine 
++ 
Here follows a more detailed discussion of LiteIDE and GoClipse. 
3.2.1. Golang LiteIDE 
The current version is X10; website: http://code.google.com/p/golangide/ ) 
LiteIDE is a nice lightweight IDE with a plugin-architecture (based on QT, Kate and SciTE), 
containing all necessary features for comfortable Go cross-platform development, with very 
good editing, code-completion and debugging support. It has the concept of a Go project, 
tied to a Makefile when this is present in its root directory. It is possible to work side by side 
with different Go-environments because you can use different environment (.env)-files with 
their own Go-variables, for example for 32 bit / 64 bit or different releases (a stable releases 
versus a weekly release for instance). 
Very nice also is the AST-view of the code, giving a nice overview of the constants, variables, 
functions and the different types, with their properties and methods.The Way to Go 
Fig 3.1: LiteIDE and its AST-view 
3.2.2. GoClipse 
( Current version: 0.2.1; website: http://code.google.com/p/goclipse/ ) 
This is a plugin for the well known Eclipse-environment, a big environment with starts 
rather slow and depends on a Java VM installed, but on the other hand it can use much of 
the built-in Eclipse functionality. A nice editor, code-completion and outline, project view 
and debugging support. 
33Ivo Balbaert 
Fig 3.2: GoClipse and its outline code-view 
3.3 Debuggers 
Application programming needs good debugging support, and in this area still a lot of work 
needs to be done. A debugger (Oogle): support for gdb (at least version 7 is needed), the GNU 
debugger is being built in Go’s gc linker (6l, 8l) by the Go-team from Google (not for Windows 
and ARM-platforms) (see also http://blog.golang.org/2010/11/debugging) 
Support for gdb version 7.1 is build in in LiteIDE and Goclipse. 
If you don’t want to use a debugger, the following is useful in a simple debugging strategy: 
1) use print-statements (with print / println and the fmt.Print functions) at well chosen 
places 
2) in fmt.Printf functions use the following specifiers to obtain complete info about 
variables: 
%+v gives us a complete output of the instance with its fields 
%#v gives us a complete output of the instance with its fields and qualified type 

_

name 
%T gives us the complete type specification 
34The Way to Go 
3) use a panic-statement (see § 13.2) to obtain a stack trace (a list of all the called functions 
up until that moment) 
4) use the defer keyword in tracing code execution (see § 6.4). 
3.4 Building and running go-programs with command- and Makefiles 
Messages from the compiler: 
When a program has been written (applying common naming- and style-rules), subject it to gofmt 
(see §3.5 to format it correctly), and then build (compile / link) it; if the build-process (which is 
also called compile-time) doesn’t give any errors, the message appears: 
---- Build file exited with code 0 . 
In most IDE’s, building also saves the latest changes to the source-file. 
If building produces (an) error(s), we get the following output: 
---- Build file exited with code 1, 
and the line number where the error occurs in the source-code is indicated, like: 
hello world.go:6: a declared and not used 
In most IDE’s, double-clicking the error line positions the editor on that code line where the error 
occurs. 
Go does not distinguish between warnings and errors. The philosophy is: when it is worth warning 
for a misuse of something, it better be signaled as an error to always be on the safe side. If you try 
to execute a program which is not yet compiled, you get the following error: 
---- Error run with code File not found, resource error 
When executing a program you are in the run-time environment. 
If the program executes correctly, after execution the following is output: 
---- Program exited with code 0 
3536 
Ivo Balbaert 
The –o flag: 
The compiler and linker also have the –o flag to give the executable a simpler name: if we have 
compiled a program test.go to test.6 and want our executable to have the name test instead of 
test.6, issue the following link-command: 
6l –o test test.6 
Command (batch) file in Windows: 
A run.cmd or run.bat file containing the following commands (put the path to your Go root map 
in the 1st line): 
set GOROOT=E:\Go\GoforWindows\gowin32 release.r60\go 
set GOBIN=$GOROOT\bin 
set PATH=%PATH%;$GOBIN 
set GOARCH=386 
set GOOS=windows 
echo off 
8g %1.go 
8l -o %1.exe %1.8 
%1 
can be used to run test.go in a command-window (cmd) like: 
run test 
Makefile in Linux and OS X: 
You can build/link without having to know which of the 5-, 6- or 8- compilers/linkers you need to 
use by using makefiles. Produce a text file called Makefile in the map with your .go-files with the 
following content: 
include $(GOROOT)/src/Make.inc 
TARG=test 
GOFILES=\ 
test1.go\ 
test2.go\ 
include $(GOROOT)/src/Make.cmd 
and make it executable with chmod 777 
./Makefile 
Fill in the variable GOFILES with all the go-files that need to be compiled and linked separated by 
a space. Leave a blank line before the include line. TARG contains the name of the executable. Then The Way to Go 
37 
run make on the command-line: this compiles/links the source-files, but only when the source-code 
has changed since the last make run; ./test executes the program. 
If needed you can make your own variables in a Makefile like VAR1, and their value is substituted 
in the expression $(VAR1) . 
From Go 1 onwards, the preferred way is to use the go tool: 
go build 
compiles and installs packages and dependencies 

_

_

_

_

go install 
install packages and dependencies 
Instead of make you can use the tool gomake, which is included in the Go-distribution. It was the 
common build tool before Go 1(see §3.4, §9.5 for packages and § 13.7 for testing): 
If $GOROOT is already set in the environment, running gomake is exactly the same as running 
make. Usage: gomake [ target ... ] 
Common targets are: 
all 
(default) build the package or command, but do not install it. 
install 
build and install the package or command 
test 
run the tests (packages only) 
bench 
run benchmarks (packages only) 
clean 
remove object files from the current directory 
nuke 
make clean and remove the installed package or command 
If it is convenient to use different Makefiles, like Makefile Proj1, Makefile Proj2, etc., you can 
invoke them separately by issuing the command with the –f flag: gomake –f Makefile Proj1 
Including code formatting: 
If you append the following lines to Makefile: 
format: 
gofmt -w $(GOFILES) 
then gomake format will invoke gofmt on your source-files.Ivo Balbaert 
Makefile in Windows: 
A Makefile and make can also be used in Windows by using MINGW (Minimalist GNU 
environment for Windows, see http://www.mingw.org/). In order to be able to run the Go toolchain 
(like gomake, gotest, etc.) the Windows-environment must be made more Unix-like. This can be 
done through MINGW, which even gives you the possibility of building Go on Windows (see 
§2.5 (5) ). 
A limited companion environment to make canonical Go-Makefiles work in a Windows 
environment including MSYS can be found at https://bitbucket.org/akavel/gowin-env . 
Download gowin env.zip and unzip it, this produces a map gowin env, with submap msys and 
some bat-files. Open console.bat in Notepad or Wordpad and edit the line set GOROOT= to the 
root of your Go-installation, for example: 
set GOROOT=E:\Go\GoforWindows\gowin32 release.r57.1\go 
Do the same for go env.bat. Then double click console.bat and change to the map where you have 
your Makefile ready, and invoke the make command to compile and link the programs indicated 
in the Makefile. 
Compiling all go-files in a directory: 
Here is the Linux-version of a useful script for the purpose of quick testing for compilation errors 
in a lot of files: 
Listing 3.1—gocomp: 
#!/bin/bash 
FILES=~/goprograms/compiletest/*.go 
for f in $FILES 
do 
echo “Processing $f file...” 
# take action on each file. $f stores current file name 
# cat $f 
6g $f >> compout 
done 
You need to replace ~/goprograms/compiletest/ with your map name; the output of the compilation 
is then appended to the file compout. 
38The Way to Go 
A Windows-version is just as easy to write, e.g. a gocomp.bat file with this line: 
FOR %%X in (*.go) DO 8g %%X >> compout 
will compile all the go-files in the current directory and write the output to compout. 
3.5 Formatting code: go fmt or gofmt 
The Go-authors didn’t want endless discussions about code-style for the Go-language, discussions 
which in the past have risen for so many programming languages and that were certainly to an 
extent a waste of precious development time. So they made a tool: go fmt (or formerly gofmt). 
It is a pretty-printer which imposes the official, standard code formatting and styling on the Go 
source-code. It is a syntax level rewriting tool, a simple form of refactoring. It is used rigorously in 
Go-development, and should be used by all Go-developers: use gofmt on your Go-program before 

_

_

_

_

compiling or checking in! 
Although not without debate, the use of gofmt and as a consequence the syntax-liberty you have 
to give up certainly have big advantages in making Go-code uniform and better readable and thus 
facilitates the cognitive task of comprehending foreign Go-code. Most editors have it built in. 
For indentation of different levels in code the rule is not strict: tabs or spaces can be used, a tab 
can be 4 or 8 spaces. In the real code-examples and exercises 1 tab takes the width of 4 spaces, in the 
printed examples in this book for clarity 1 tab equals 8 spaces. In writing code in an editor of IDE, 
use the tab, don’t insert spaces. 
On the command-line: gofmt –w program.go reformats program.go (without –w the changes are 
shown, but not saved). gofmt –w *.go works on all go-files. gofmt map1 works recursively on all .go 
files in the map1 directory and its subdirectories. 
It can also be used for simple changes (refactoring) in a codebase by specifying a rule with the –r 
flag and a rule between ‘ ; the rule has to be of the form: pattern -> replacement 
Examples: 
gofmt -r “(a) -> a” –w *.go 
this will replace all unnecessary doubled (( )) with () in all go-files in the 
current directory. 
gofmt -r “a[n:len(a)] -> a[n:]” –w *.go 
this will replace all superfluous len(a) in such slice-declarations 
3940 
Ivo Balbaert 
gofmt –r ‘A.Func1(a,b) -> A.Func2(b,a)’ –w *.go 
this will replace Func1 with Func2 and swap the function’s arguments 
For more info see: http://golang.org/cmd/gofmt/ 
3.6 Documenting code: go doc or godoc 
go doc extracts and generates documentation for Go programs and packages. 
It extracts comments that appear before top-level declarations in the source-code, with no 
intervening newlines: together with the declaration they serve as explanatory text for the item. 
It can also function as a web server delivering documentation; this is how the golang-website 
http://golang.org works. 
General format: 
go doc package 
to get the ‘package comment’ documentation for package, ex.: go doc fmt 
this comment will appear first on the output produced by godoc. 
go doc package/subpackage 
to get the documentation for subpackage in package, ex: go doc container/list 
go doc package function 
to get the documentation for function in package, ex.: go doc fmt Printf 
provides explanations for the use of fmt.Printf() 
These commands only work when the Go-source is located under the Go-root: ../go/src/pkg. 
The command godoc itself has some more options. 
Godoc can also be started as a local webserver: godoc -http=:6060 on the command-line starts 
the server, then open a browser window with the url: http://localhost:6060 and you have a local 
documentation server, without the need for an internet-connection. 
Godoc can also be used to generate documentation for self-written Go-programs: see §9.6. 
For more info see: http://golang.org/cmd/godoc/The Way to Go 
41 
3.7 Other tools 
The tools in the Go-toolset (http://golang.org/cmd/) are partly shell-scripts and also written in Go 
itself. From Go 1 onwards they are implemented as commands for the go tool: 
go install (formerly goinstall) is the go-package install tool; much like rubygems for the Ruby 
language. It is meant for installing go packages outside of the standard library, and it works with 
the source-code format of the package, which then has to be locally compiled and linked (see also 
§ 9.7). 
go fix (formerly gofix) is a tool that you can use to update Go source-code (outside of the 
standard packages) from an older to the newest release: it tries to automatically ‘fix’ changes. It is 
meant to reduce the amount of effort it takes to update existing code, automating it as much as 
possible. gofix takes care of the easy, repetitive, tedious changes; if a change in API isn’t simply a 
substitution of a new function and requires manual examination, gofix prints a warning giving the 
file name and line number of the use, so that a developer can examine and rewrite the code. The 
Go-team regularly updates the tool together with new API changes, and it is also used internally 
in Google to update Go source code. go fix works because Go has support in its standard libraries 
for parsing Go source files into (abstract) syntax trees (AST’s) and also for printing those syntax 
trees back to Go source code. 
go fix . tries to update all .go-files in the current directory when necessary; the changed filenames 

are printed on standard output. 
Examples:—show differences with the installed Go-release: 
go fix -diff . 
- update to changes: go fix -w . 
go test (formerly gotest) is a lightweight test framework for unit-testing (see chapter 13) 
3.8 Go’s performance 
According to the Go-team and measured in simple algorithmic programs, performance is typically 
within 10-20% of C. There are no official benchmarks, but regular experimental comparisons 
between languages show a very good performance track. 
A more realistic statement is that Go is 20% slower than C++ . This puts Go programs at 
conservatively twice as fast and requiring 70% less memory when compared to an equivalent Java 
or Scala application. In many cases that difference is irrelevant, but for a company like Google with 
thousands of servers the potential efficiency improvements are certainly worth the investment.Ivo Balbaert 
The current popular languages execute in a virtual machine: JVM for Java and Scala, .NET CLR 
for C#, etc..Even with the massive improvements in virtual machines, JIT-compilers and scripting 
language interpreters (Ruby, Python, Perl, Javascript) none can come close to C and C++ for 
performance. 
If Go is 20% slower than C++, that’s still 2 to 10 times faster than any language that’s not statically 
typed and compiled, and it is far more memory efficient. 
Comparing benchmarks of a program in 2 or more languages is very tricky: the programs each 
should do exactly the same things, utilizing the best possible concepts and techniques for that task 
from the language. For example when processing text, the language that processes this as raw bytes 
will almost certainly outperform the language that works with it as Unicode. The person performing 
the benchmarks often writes both programs, but often he/she is much more experienced in one 
language than in the other, and this can of course very much influence the results: each program 
should be written by a developer well versed in the language. Otherwise, like in statistics, it is not 
difficult to artificially influence the performance behavior of one language compared to another; 
it is not an exact science. The outcome can also depend upon the problem to solve: in most 
cases older languages have optimally tuned libraries for certain tasks, and it must be taken into 
account that some of the Go-libraries are still early versions. For a lot of results, see The Computer 
Language Benchmark Game—http://shootout.alioth.debian.org/ (ref 27). 
Some benchmarking results: 
(1) Comparing Go and Python on simple webserver applications, measured in transactions/s: 
The native Go http package is 7-8 x faster than web.py, web.go slightly less performant with a ratio 
of 6-7 compared to web.py. The tornado asynchronous server/framework much used in Python 
web environments performs considerably better than web.py: Go outperforms tornado only with 
a factor of 1.2 to 1.5 (see ref 26). 
(2) Go is on average 25 x faster than Python 3, uses 1/3 of the memory, with number of lines 
of code almost equal to double. (see ref 27). 
(3) The article by Robert Hundt (Jun 2011, ref 28) comparing C++, Java, Go, and Scala, and 
the reaction of the Go team (ref 29): some conclusions taking into account the tuning from 
the Go-team: 
- The Scala and Go versions are signifificantly more compact (less code lines) than the 
verbose C++ and Java 
- Go compiles quicker than alle others, 5-6x comparing to Java and C++, 10x 
compared to Scala 
- Go has the largest binary size (every executable contains the runtime) 
42The Way to Go 
43 
- Optimized Go code is as fast as C++, 2 to 3x faster than the Scala version and 5 to 
10x faster than Java. 
- Its memory consumption is also very much comparable to that of C++, nearly half 
of what Scala required, and it was nearly 4x less than Java 
3.9 Interaction with other languages. 
3.9.1. Interacting with C 
The cgo program provides the mechanism for FFI-support (foreign function interface) to allow safe 
calling of C libraries from Go code: http://golang.org/cmd/cgo is the primary cgo documentation 
(see also ref. 23). cgo replaces the normal Go-compilers, it outputs Go and C files that can be 
combined into a single Go package. It is good practice to combine the calls to C in a separate 
package. 
The following import is then necessary in your Go program: 
import “C” 
( this needs to be on a line of its own ) 
and usually also: 
import “unsafe” 

You can include C-libraries (or even valid C-code) by placing these statements as comments (with 
// or /* */) immediately above the import “C” line: 
// #include <stdio.h> 
// #include <stdlib.h> 
import “C” 
C is not a package from the standard library, it is simply a special name interpreted by cgo as a 
reference to C’s namespace. Within this namespace exist the C types denoted as C.uint, C.long, 
etc. and functions like C.random() from libc can be called. 
Variables in the Go program have to be converted to the C type when used as parameter in C 
functions, and vice-versa, examples: 
var i int 
C.uint(i) // from Go int to C unsigned int 
int(C.random()) // from C (random() gives a long) to Go int 
The following program contains 2 Go functions Random() and Seed(), which call the equivalent 
C functions C.random() and C.srandom():Ivo Balbaert 
Listing 3.2—c1.go: 
package rand 
// #include <stdlib.h> 
import “C” 
func Random() int { 
return int(C.random()) 
} 
func Seed(i int) { 
C.srandom(C.uint(i)) 
} 
Strings do not exist as explicit type in C: to convert a Go string s to its C equivalent use: C.CString(s). 
The reverse is done with the function C.GoString(cs), where cs is a C ‘string’. 
Memory allocations made by C code are not known to Go’s memory manager. 
It is up to the developer to free the memory of C variables with C.free, as follows: 
defer C.free(unsafe.Pointer(Cvariable)) 
This line best follows the line where Cvariable was created, so that the release of memory is not 
forgotten. The following code contains a Go function Print() which prints a string to the console 
by using the C function fputs from stdio, explicitly freeing the the memory used: 
Listing 3.3—c2.go: 
package print 
// #include <stdio.h> 
// #include <stdlib.h> 
import “C” 
import “unsafe” 
func Print(s string) { 
cs := C.CString(s) 
defer C.free(unsafe.Pointer(cs)) 
C.fputs(cs, (*C.FILE)(C.stdout)) 
} 
44The Way to Go 
Building cgo packages: 
A Makefile like in §9.5 (because we create a separate package) can be used here; apart from the 
GOFILES variable, a variable CGOFILES now lists the files to be compiled with cgo. For example 
Listing 3.2 could be compiled in a package rand with the following Makefile, issuing the command 
gomake or make: 
include $(GOROOT)/src/Make.inc 
TARG=rand 
CGOFILES=\ 
c1.go\ 
include $(GOROOT)/src/Make.pkg 
3.9.2. Interacting with C++ 
SWIG (Simplified Wrapper and Interface Generator) support exists for calling C++ and C code 
from Go on Linux. Using SWIG is a bit more involved: 
• Write the SWIG interface fifile for the library to be wrapped 
• SWIG will generate the C stub functions 
• These can then be called using the cgo machinery 
• the Go fifiles doing so are automatically generated as well 
This interface handles overloading, multiple inheritance and allows to provide a Go implementation 
for a C++ abstract class. 
A problem is that SWIG doesn’t understand all of C++, e.g. it can’t parse TObject.h 

45PART 2 
CORE CONSTRUCTS AND TECHNIQUES 

_

_

_

scanner test.go 
_

blank identifier. It can be used in declarations or 

OF THE LANGUAGE49 
Chapter 4—Basic constructs and elementary data 
types 
4.1. Filenames—Keywords—Identifiers 
Go source-code is stored in .go files, these filenames consist of lowercase-letters, like scanner.go 
If the name consist of multiple parts, there are separated by underscores  , like 
Filenames may not contain spaces or any other special characters. 
A source-file contains code lines, who’s length have no intrinsic limit. 
Nearly all things in Go-code have a name or an identifier. Go, like all languages in the C-family, is 
case-sensitive. Valid identifiers begin with a letter (a letter is every letter in Unicode UTF-8 or   ), _
and followed by 0 or more letters or Unicode digits, like: X56, group1,  x23, i, өԑ12 
The following are NOT valid identifiers: 
1ab (starts with digit), case (= keyword in Go), a+b (operators are not allowed) 
The   itself is a special identifier, called the 
variable assignments like any other identifier (and any type can be assigned to it), but its value is 
discarded, so it cannot be used anymore in the code that follows. 
Sometimes it is possible that variables, types or functions have no name because it is not really 
necessary at that point in the code and even enhances flexibility: these are called anonymous. 
This is the set of 25 keywords or reserved words used in Go-code: 
break 
default 
func 
interface 
select 
case 
defer 
go 
map 
struct 
chan 
else 
goto 
package 
switch 
const 
fallthrough 
if 
range 
type50 
Ivo Balbaert 
continue 
for 
import 
return 
var 
It is kept deliberately small to simplify the code-parsing, the first step in the compilation process. 
A keyword cannot be used as an identifier. 
Apart from the keywords Go has a set of 36 predeclared identifiers: these contain the names of 
elementary types and some basic built-in functions (see § 6.5); all these will be explained further 
in the next chapters: 
append bool 
byte 
cap 
close 
complex complex64 complex128 uint16 
copy 
false 
float32 float64 imag 
int 
int8 
int16 
uint32 

_

int32 
int64 
iota 
len 
make 
new 
nil 
panic 
uint64 
print 
println real 
recover string true 
uint 
uint8 
uintptr 
Programs consist out of keywords, constants, variables, operators, types and functions. 
The following delimiters are used: parentheses ( ), brackets [ ] and braces { }. 
The following punctuation characters . , ; : and … are used. 
Code is structured in statements. A statement doesn’t need to end with a ; (like it is imposed 
in the C-family of languages). The Go compiler automatically inserts semicolons at the end of 
statements. 
However if multiple statements are written on one line ( a practice which is not encouraged for 
readability reasons ), they must be separated by ; 
4.2. Basic structure and components of a Go-program 
Listing 4.1 hello world.go: 
package main 
import “fmt” 
func main() { 
fmt.Println(“hello, world”) 
}The Way to Go 
4.2.1 Packages, import and visibility 
Packages are a way to structure code: a program is constructed as a “package” (often abbreviated as 
pkg), which may use facilities from other packages. 
Every go-file belongs to one (and only one) package (like a library or namespace in other languages). 
Many different .go files can belong to one package, so the filename(s) and package name are 
generally not the same. 
The package to which the code-file belongs must be indicated on the first line, e.g.: package main. 
A standalone executable belongs to package main. Each Go application contains one package 
called main. 
An application can consist of different packages, but even if you use only package main, you don’t 
have to stuff all code in 1 big file: you can make a number of smaller files each having package main 
as 1st codeline. If you compile a source file with a package name other than main, like pack1, the 
object file is stored in pack1.a; a package name is written in lowercase letters. 
Standard library: 
The Go installation contains a number of ready-to-use packages, which form the standard library. 
On Windows the directories of the standard library can be found in the subdirectory pkg\ 
windows 386 of the Go-root map. On Linux the directories of the standard library can be found 
in the subdirectory pkg\linux amd64 of the Go-root map (or linux amd32 in case of a 32 bit 
installation). The general path (the global Go tree) where the standard library can be found is 
$GOROOT/pkg/$GOOS $GOARCH/ . 
The standard library of Go contains a lot of packages (like fmt, os), but you can also create your 
own packages (see chapter 8). 
To build a program, the packages, and the files within them, must be compiled in the correct order. 
Package dependencies determine the order in which to build packages. 
Within a package, the source files must all be compiled together. The package is compiled as a unit, 
and by convention each directory contains one package. 
If a package is changed and recompiled, all the client programs that use this package must be recompiled 
too! 
5152 
Ivo Balbaert 
The package model uses explicit dependencies to enable faster builds: the Go compiler pulls transitive 
dependency type info from the object file .o—but only what it needs. 
If A.go depends on B.go depends on C.go: 
- compile C.go, B.go, then A.go. 
- to compile A.go, compiler reads B.o not C.o. 

_

_

_

_

_

At a large scale, this can be a huge speedup. 
Every piece of code is compiled only once. 
A Go program is created by linking together a set of packages through the import keyword. 
import “fmt” tells Go that this program needs (functions, or other elements, from) the package 
fmt, which implements functionality for formatted IO. The package names are enclosed within “ 
”. Import loads the public declarations from the compiled package, it does not insert the source 
code. 
If multiple packages are needed, they can each be imported by a separate statement: 
import “fmt” 
import “os” 
or: 
import “fmt”; import “os” 
but a shorter and more elegant way (called factoring the keyword, also applicable to const, var and 
type) is available: 
import ( 
“fmt” 
“os” 
) 
(It can be even shorter: import (“fmt”; “os”) but gofmt enforces the distributed version) 
Only apply this when there is more than one entry; in that case it is also clearer to list the package 
names in alphabetical order.The Way to Go 
53 
If the name of a package does not start with . or /, like “fmt” or “container/list”, Go looks for it in 
the global Go tree. If it starts with ./ the package is searched in the actual directory; starting with / 
(even on Windows) it is searched for in the (absolute) path indicated. 
Packages contain all other code-objects. 
Apart from   , identifiers of code-objects have to be unique in a package: there can be 
conflicts. But the same identifier can be used in different packages: the package name qualifies it to 
be different. 
Packages expose their code-objects to code outside of the package according to the following rule, 
which is enforced by the compiler : 
VISIBILITY RULE: 
When the identifier ( of a constant, variable, type, function, struct field, …) starts with an 
uppercase letter, like Group1, then the ‘object’ with this identifier is visible in code outside 
the package (thus available to client-programs, ‘importers’ of the package), it is said to be 
exported (like public in OO languages). Identifiers which start with a lowercase letter are 
not visible outside the package, but they are visible and usable in the whole package (like 
private). 
(Capital letters can come from the entire Unicode-range,like Greek; not only ASCII letters are 
allowed.) 
So importing a package gives (only) access to the exported objects in that package. 
Suppose we have a thing (variable or function) called Thing (starts with T so it is exported) in a 
package pack1, then when pack1 is imported in the current package, Thing can be called with the 
usual dot-notation from OO-languages: pack1.Thing 
( The pack1. is necessary ! ) 
So packages also serve as namespaces and can help to avoid name-clashes (name-conflicts): variables 
with the same name in two packages are differentiated by their package name, like: 
pack1.Thing and pack2.Thing 
A package can, if this is useful (for shortening, name conflicts, …), also be given another name (an 
alias), like: import fm “fmt”. The alias is then used in the following code:54 
Ivo Balbaert 
Listing 4.2—alias.go: 
package main 
import fm “fmt” // alias3 
func main() { 
fm.Println(“hello, world”) 
} 
Remark:
importing a package which is not used in the rest of the code is a build-error (for 
example: imported and not used: os) . This follows the Go-motto: “no unnecessary code! ” 
Package level declarations and initializations: 
After the import statement 0 or more constants (const), variables (var), and types (type) can be 
declared; these are global (have package scope) and are known in all functions in the code ( like c and 
v in gotemplate.go below), and they are followed by one or more functions (func). 
4.2.2 Functions 

no naming 

_

_

_

_
_

The simplest function declaration has the format: 
func functionName() 
Between the mandatory parentheses ( ) no, one, or more parameters (separated by , ) can be given 
as input to the function. After the name of each parameter variable must come its type. 
A main function as starting is required (usually the first func), otherwise the build-error undefined: 
main.main occurs. main has no parameters and no return type (in contrary to the C-family), 
otherwise you get the build-error: 
func main must have no arguments and no return values results. 
When the program executes, after initializations the first function called (the entry-point 
of the application) will be main.main() (like in C). The program exits—immediately and 
successfully—when main.main returns. 
The code in functions (the body) is enclosed between braces: { } 
The first { must be on the same line as the func-declaration: this is imposed by the compiler and 
gofmt (build-error: 
syntax error: unexpected semicolon or newline before { ).The Way to Go 
55 
( This is because the compiler then produces func main() ; which is an error. ) 
The last } is positioned after the function-code in the column beneath function; for small functions 
it is allowed that everything is written on one line, like for example: func Sum(a, b int) int { 
return a + b } 
The same rule applies wherever { } are used (for example: if, etc.) 
So schematically a general function looks like: 
func functionName(parameter list) (return value list) { 
_
… 
} 
where parameter list is of the form (param1 type1, param2 type2, …) 
and return value list is of the form (ret1 type1, ret2 type2, …) 
Function names only start with a capital letter when the function has to be used outside the 
package; then they follow PascalCasing, otherwise they follow camelCasing: every new wordin the 
name starts with a capital letter. 
The line: fmt.Println(“hello, world”) calls the function Println from the package fmt, which 
prints the string-parameter to the console, followed by a newline-character \n . 
The same result can be obtained with fmt.Print(“hello, world\n”) 
These functions Print and Println can also be applied to variables, like in: fmt.Println(arr); they 
use the default output-format for the variable arr. 
Printing a string or a variable can be done even simpler with the predefined functions print and 
println: print(“ABC”) or println(“ABC”) or (with a variable i): println(i) 
These are only to be used in the debugging phase; when deploying a program replace them with 
their fmt relatives. 
The execution of a function is stopped when the closing } is reached or when a return statement 
is encountered, the execution of the program continues with the line following the call of the 
function. Ivo Balbaert 
The program exits normally with code 0 ( Program exited with code 0 ); a program that terminates 
abnormally exits with another integer code like 1; this can be used to test succesfull execution of 
he program from a script. 
4.2.3 Comments 
Listing 4.3—hello world2.go: 
package main 
import “fmt” // Package implementing formatted I/O. 
func main() { 
fmt.Printf(“
} 
This illustrates the international character by printing 
 ちは 世界, and also the characters used to indicate a comment. 
Comments of course are not compiled, but they are used by godoc (see § 3.6) 
A one-line comment starts with //, at the beginning or somewhere in a line; this is mostly used. A 
multi-line or block-comment starts with /* and ends with */, nesting is not allowed; this is used 
for making package documentation and commenting out code. 
Every package should have a package comment, a block comment immediately preceding the 
package statement, introducing the package and provide information relevant to the package and 
its functionality as a whole. A package can be spread over many files, but the comment needs to 
be in only one of them. This comment is shown when a developer demands info of the package 
with godoc. Subsequent sentences and/or paragraphs can give more details. Sentences should be 
properly punctuated. 
Example: 
// Package superman implements methods for saving the world. 

Κα ημέ α κ με

こんにちは 世界\n”) 

ρ   όσ ; or 

Κα ημέ α κ με

ρ   όσ ; or 

こんに

λ

λ

_

 
 
// 
// Experience has shown that a small number of procedures can prove 
// helpful when attempting to save the world. 
package superman 
Nearly every top-level type, const, var and func, and certainly every exported name in a program 
should have a comment. This comment (called a doc comment) appears on the preceding line, and 
for a function Abcd should start with: “Abcd …”. 
56The Way to Go 
57 
Example: 
// enterOrbit causes Superman to fly into low Earth orbit, a position 
// that presents several possibilities for planet salvation. 
func enterOrbit() error { 
... 
} 
The godoc-tool (see §3.6) collects these comments to produce a technical documentation. 
4.2.4 Types 
Variables (like constants) contain data, and data can be of different data types, or types for short. A 
declaration of a variable with var automatically initializes it to the zero-value defined for its type.A 
type defines the set of values and the set of operations that can take place on those values. 
Types can be elementary (or primitive), like int, float, bool, string, 
or structured (or composite), like struct, array, slice, map, channel, 
and interfaces, which only describe the behavior of a type. 
A structured type which has no real value (yet) has the value nil, which is also the default value for 
these types (in Objective-C this is also called nil, in Java it is null, in C anc C++ it is NULL or 0). 
There is no type-hierarchy. 
Functions can also be of a certain type, this is the type of the variable which is returned by the 
function. This type is written after the function name and its optional parameter-list, like: 
func FunctionName (a typea, b typeb) typeFunc 
The returned variable var of typeFunc appears somewhere in the function in the statement: 
return var 
A function can return more than one variable, then the return-types are indicated separated by 
comma’s and surrounded by ( ), like: func FunctionName (a typea, b typeb) (t1 type1, t2 
type2) 
Example: the function Atoi (see § 4.7): func Atoi(s string) (i int, err error) 
Then return takes the form: 
return var1, var2Ivo Balbaert 
This is often used when the success (true/false) of the execution of a function or the error-message 
is returned together with the return value (see multiple assignments below). 
Use the keyword type for defining your own type. Then you probably want to define a struct-type 
(see Chapter 10), but it is also possible to define an alias for an existing type, like in: 
type IZ int 
and then we can declare variables like: var a IZ = 5 
We say that a has int as underlying type, this makes conversion possible (see § 4.2.6). 
If you have more than one type to define, you can use the factored keyword form, as in: 
type ( 
IZ int 
FZ float 
STR string 
) 
Every value must have a type after compilation (the compiler must be able to infer the types of all 
values): 
Go is a statically typed language. 
4.2.5 General structure of a Go-program 
The following program compiles but does nothing useful, but is shows the preferred structure for a 
Go-program. This structure is not necessary, the compiler does not mind if main() or the variable 
declarations come last, but a uniform structure makes Go code better readable from top to bottom. 
All structures will be further explained in this and the coming chapters, but the general ideas are: 
• After import: declare constants, variables and the types 
• Then comes the init() function if there is any: this is a special function that every package 
can contain and that is executed first. 
• Then comes the main() function (only in the package main) 
• Then come the rest of the functions, the methods on the types first; or the functions in 
order as they are called from main() onwards; or the methods and functions alphabetically 
if the number of functions is high. 
58The Way to Go 
59 
Listing 4.4—gotemplate.go: 

package main 
import ( 
“fmt” 
) 
const c = “C” 
var v int = 5 
type T struct{} 
func init() { // initialization of package 
} 
func main() { 
var a int 
Func1() 
// ... 
fmt.Println(a) 
} 
func (t T) Method1() { 
//... 
} 
func Func1() { // exported function Func1 
//... 
} 
The order of execution (program startup ) of a Go application is as follows: 
(1) all packages in package main are imported in the order as indicated, 
in every package: 
(2) if it imports packages, (1) is called for this package (recursively) 
but a certain package is imported only once 
(3) then for every package (in reverse order) all constants and variables are evaluated, and the 
init() if it contains this function. 
(4) at last in package main the same happens, and then main() starts executing.60 
Ivo Balbaert 
4.2.6 Conversions 
If necessary and possible a value can be converted (cast, coerced) into a value of another type. Go 
never does implicit (automatic) conversion, it must be done explicit like so, with the syntax like a 
function call (a type is here used as a kind of function): 
valueOfTypeB = typeB(valueOfTypeA) 
Examples: 
a := 5.0 
b := int(a) 
But this can only succeed in certain well defined cases, for example from a narrower type to a 
broader type (for example: int16 to int32). When converting from a broader type to a narrower 
type (for example: int32 to int16, or float32 to int) loss of value (truncation) can occur. When 
the conversion is impossible and the compiler detects this, a compile-error is given, otherwise a 
runtime-error occurs. 
Variables with the same underlying type can be converted into one another: 
var a IZ = 5 
c := int(a) 
d := IZ(c) 
4.2.7 About naming things in Go 
Clean, readable code and simplicity are a major goal for Go development. gofmt imposes the 
code-style. Names of things in Go should be short, concise, evocative. Long names with mixed 
caps and underscores which are often seen e.g. in Java or Python code often hinders readability. 
Names should not contain an indication of the package: the qualification with the package name is 
sufficient. A method or function which returns an object is named as a noun, no Get… is needed. 
To change an object, use SetName. If necessary, Go uses MixedCaps or mixedCaps rather than 
underscores to write multiword names. 
4.3. Constants 
A constant const contains data which does not change. 
This data can only be of type boolean, number (integer, float or complex) or string. 
It is defined as follows: const identifier [type] = value, for example: const Pi = 3.14159The Way to Go 
61 
The type specifier [type] is optional, the compiler can implicitly derive the type from the value. 
Explicit typing example: const b string = “abc” 
Implicit typing example: const b = “abc” 
A value derived from an untyped constant becomes typed when it is used within a context that 
requires a typed value (otherwise formulated: an untyped constant takes the type needed by its 
context): 
var n int 
f(n + 5) // untyped numeric constant “5” becomes typed as int 

Constants must be evaluated at compile time; a const can be defined as a calculation, but all the 
values necessary for the calculation must be available at compile time. 
So this is ok: const c1 = 2/3 
this is NOT: 
const c2 = getNumber()// gives the build error: getNumber() used as value 
Numeric constants have no size or sign, can be of arbitrary high precision and do no overflow: 
const Ln2= 0.693147180559945309417232121458\ 
176568075500134360255254120680009 
const Log2E= 1/Ln2 
// this is a precise reciprocal 
const Billion = 1e9 
// float constant 
const hardEight = (1 << 100) >> 97 
As demonstrated \ can be used as a continuation character in a constant. 
In contrast to numeric variables of different types, with constants you don’t have to worry about 
conversions: they are like ideal numbers. 
Constants can overflow only when they are assigned to a numeric variable with too little precision 
to represent the value, this results in a compile error. Multiple assignment is allowed, like in: 
const beef, two, c = “meat”, 2, “veg” 
const Monday, Tuesday, Wednesday, Thursday, Friday, Saturday = 1, 2, 3, 4, 5, 6 
const ( 
Monday, Tuesday, Wednesday = 1, 2, 3 
Thursday, Friday, Saturday = 4, 5, 6 
)Ivo Balbaert 
Constants can be used for enumerations: 
const ( 
Unknown = 0 
Female = 1 
Male = 2 
) 
Unknown, Female, Male are now aliases for 0, 1 and 2. They can in effect be used to test for these 
values, like in a switch / case construct (§ 5.3). 
In such cases, the value iota can be used to enumerate the values: 
const ( 
a = iota 
b = iota 
c = iota 
) 
The first use of iota gives 0, whenever iota is used again on a new line, its value is incremented by 
1; so a=0, b=1, c=2. This can be shortened to: 
const ( 
a = iota 
b 
c 
) 
iota can also be used in an expression, like iota + 50. A new const block or declaration initializes 
iota back to 0. 
Of course, the value of a constant cannot change during the execution of the program; doing so is 
prevented by a compiler error: cannot assign to value, where value is the value of the constant. 
An example from the time package: the names for the days of the week: 
const ( 
Sunday = iota 
Monday 
Tuesday 
62The Way to Go 
63 
Wednesday 
Thursday 
Friday 
Saturday 
) 
You can give the enumeration a type name like in this example: 
type Color int 
const ( 
RED Color = iota // 0 
ORANGE 
// 1 
YELLOW 
// 2 
GREEN 
// .. 
BLUE 
INDIGO 
VIOLET 
// 6 
) 

Remark: There is a convention to name constant identifiers with all uppercase letters, like: const 
INCHTOwCM = 2.54; this improves readability and can be used as long as it is not in conflict 
with the Visibility Rule of §4.2 
4.4. Variables 
4.4.1 Introduction 
The general form for declaring a variable uses the keyword var: var identifier type 
Important to note is that the type is written after the identifier of the variable, contrary to almost 
any other programming language. Why did the Go designers chose for this convention? 
First it removes some ambiguity which can exist in C declarations, e.g. in writing int* a, b; 
Only a is a pointer and b is not. In order to declare them both pointers, the asterisk must be repeated. 
(for a longer discussion on this topic, see: http://blog.golang.org/2010/07/gos-declaration-syntax. 
html) 
However in Go, they can both be declared pointers as follows: var a, b *int64 
Ivo Balbaert 
Secondly it reads well from left to right and so is easier to understand. 
Some examples: 
var a int 
var b bool 
var str string 
which also can be written as: 
var ( 
a int 
b bool 
str string 
) 
This form is mainly used to declare variables globally. 
When a variable is declared it contains automatically the default zero or null value for its type: 0 
for int, 0.0 for float, false for bool, empty string (“”) for string, nil for pointer, zero-ed struct, etc.: 
all memory in Go is initialized. 
The naming of identifiers for variables follows the camelCasing rules (start with a small letter, every 
new part of the word starts with a capital letter), like: numShips, startDate 
But if the variable has to be exported, it must start with a capital letter (visibility rule §4.2). 
A variable (constant, type, function) is only known in a certain range of the program, called the 
scope. Variables etc. declared outside of any function (in other words at the top level) have global (or 
package) scope: they are visible and available in all source files of the package. 
Variables declared in a function have local scope: they are only known in that function, the same 
goes for parameters and return-variables. In chapter 5 we will encounter control constructs like if 
and for; a variable defined inside such a construct is only known within that construct (construct 
scope). Mostly you can think of a scope as the codeblock ( surrounded by { } ) in which the variable 
is declared. 
Although identifiers have to be unique, an identifier declared in a block may be redeclared in an 
inner block: in this block (but only there) the redeclared variable takes priority and shadows the 
outer variable with the same name; if used care must be taken to avoid subtle errors (see § 16.1).The Way to Go 
65 
Variables can get their value (which is called assigning and uses the assignment-operator =) at 
compile time, but of course a value can also be computed or changed during runtime. 
Examples: 
a = 15 
b = false 
In general a variable b can only be assigned to a variable a as in a = b, when a and b are of the same 
type. 
Declaration and assignment(initialization) can of course be combined, in the general format: 
var identifier [type] = value 
Examples: 
var a int = 15 
var i = 5 
var b bool = false 
var str string = “Go says hello to the world!” 
But the Go-compiler is intelligent enough to derive the type of a variable from its value (dynamically, 
also called automatic type inference, somewhat like in the scripting languages Python and Ruby, but 
there it happens in run time), so the following forms (omitting the type) are also correct: 
var a = 15 
var b = false 
var str = “Go says hello to the world!” 
or: 
var ( 
a = 15 
b = false 
str = “Go says hello to the world!” 

numShips = 50 
city string 
) 
It can still be useful to include the type information in the case where you want the variable to be 
typed something different than what would be inferred, such as in: var n int64 = 2 
However an expression like var a is not correct, because the compiler has no clue about the type 
of a. Variables could also be expressions computed at runtime, like: 
var ( 
HOME = os.Getenv(“HOME”)Ivo Balbaert 
USER = os.Getenv(“USER”) 
GOROOT = os.Getenv(“GOROOT”) 
) 
The var syntax is mainly used at a global, package level, in functions it is replaced by the short 
declaration syntax := (see § 4.4). 
Here is an example of a program which shows the operating system on which it runs. It has 
a local string variable getting its value by calling the Getenv function (which is used to obtain 
environment-variables) from the os-package. 
Listing 4.5—goos.go: 
package main 
import ( 
“fmt” 
“os” 
) 
func main() { 
var goos string = os.Getenv(“GOOS”) 
fmt.Printf(“The operating system is: %s\n”, goos) 
path := os.Getenv(“PATH”) 
fmt.Printf(“Path is %s\n”, path) 
} 
The output can for example be: The operating system is: windows, or The operating system is: 
linux, followed by the contents of the path variable. 
Here Printf is used to format the ouput (see § 4.4.3). 
4.4.2 Value types and reference types 
Memory in a computer is used in programs as a enormous number of boxes (that’s how we will 
draw them), called words. All words have the same length of 32 bits (4 bytes) or 64 bits (8 bytes), 
according to the processor and the operating system; all words are identified by their memory 
address (represented as a hexadecimal number). 
All variables of elementary (primitive) types like int, float, bool, string, … are value types, they 
point directly to their value contained in memory: 
66The Way to Go 
67 
7 
(int) i 
32 bit word 
Fig 4.1: Value type 
Also composite types like arrays (see chapter 7) and structs (see Chapter 10) are value types. 
When assigning with = the value of a value type to another variable: j = i, a copy of the original 
value i is made in memory. 
7 
(int) i 
7 
(int) j 
Fig 4.2: Assignment of value types 
The memory address of the word where variable i is stored is given by &i (see § 4.9), e.g. this could 
be 0xf840000040. Variables of value type are cointained in stack memory. 
The actual value of the address will differ from machine to machine and even on different executions 
of the same program as each machine could have a different memory layout and and also the 
location where it is allocated could be different. 
More complex data which usually needs several words are treated as reference types. 
A reference type variable r1 contains the address (a number) of the memory location where the value 
of r1 is stored (or at least the 1st word of it): 
address1 
value of r1 
address1 
(ref) r1 
(ref) r2 
Fig 4.3: Reference types and assignmentIvo Balbaert 
This address which is called a pointer (as is clear from the drawing, see § 4.9 for more details) is 
also contained in a word. 

_

_

). 

The different words a reference type points to could be sequential memory addresses (the memory 
layout is said to be contiguously) which is the most efficient storage for computation; or the words 
could be spread around, each pointing to the next. 
When assigning r2 = r1, only the reference (the address) is copied. 
If the value of r1 is modified, all references of that value (like r1 and r2) then point to the modified 
content. 
In Go pointers (see § 4.9) are reference types, as well as slices (ch 7), maps (ch 8) and channels (ch 
13). The variables that are referenced are stored in the heap, which is garbage collected and which 
is a much larger memory space than the stack. 
4.4.3 Printing 
The function Printf is visible outside the fmt-package because it starts with a P, and is used to 
print output to the console. It generally uses a format-string as its first argument: 
func Printf(format string, list of variables to be printed) 
In Listing 4.5 the format string was: “The operating system is: %s\n” 
This format-string can contain one or more format-specifiers %.., where .. denotes the type of the 
value to be inserted, e.g. %s stands for a string-value. %v is the general default format specifier. 
The value(s) come in the same order from the variables summed up after the comma, and they are 
separated by comma’s if there is more than 1. These % placeholders provide for very fine control 
over the formatting. 
The function fmt.Sprintf behaves in exactly the same way as Printf, but simply returns the 
formatted string: so this is the way to make strings containing variable values in your programs (for 
an example, see Listing 15.4—simple tcp server.go
The functions fmt.Print and fmt.Println perform fully automatic formatting of their arguments 
using the format-specifier %v, adding spaces between arguments and the latter a newline at the 
end. So fmt.Print(“Hello:”, 23) produces as output: Hello: 23 
68The Way to Go 
69 
4.4.4 Short form with the := assignment operator 
With the type omitted, the keyword var in the last statements of § 4.4.1 is pretty superfluous, so 
we may write in Go: 
a := 50 
or 
b := false 
Again the types of a and b (int and bool) are inferred by the compiler. 
This is the preferred form, but it can only be used inside functions, not in package scope. The := 
operator effectively makes a new variable; it is also called an initializing declaration. 
Remark: If after the lines above in the same codeblock we declare a:= 20, this is not allowed : the 
compiler gives the error “no new variables on left side of :=” ; however a = 20 is ok because 
then the same variable only gets a new value. 
A variable a which is used, but not declared, gives a compiler error: 
undefined: a 
Declaring a local variable, but not using it, is a compiler error; like variable a in the following 
main() function: 
func main() { 
var a string = “abc” 
fmt.Println(“hello, world”) 
} 
which gives the error: a declared and not used 
Also setting the value of a is not enough, the value must be read in order to count as a use, so fmt. 
Println(“hello, world”, a) removes the error. 
However for global variables this is allowed. 
Other convenient shortening forms are: 
Multiple declarations of variables of the same type on a single line, like: var a, b, c int 
( this is an important reason why the type is written after the identifier(s) ) 
Multiple assignments of variables on a single line, like: a, b, c = 5, 7, “abc” 
This assumes that variables a, b and c where already declared, if not: a, b, c := 5, 7, “abc”70 
Ivo Balbaert 
The values from the right-hand side are assigned to the variables on the left-hand side in the same 
order, so a has the value 5, b has the value 7, c has the value “abc”. 
This is called parallel or simultaneous assignment. 
With two variables it can be used to perform a swap of the values: 
a, b = b, a 
(This removes the need for making a swap function in Go) 
The blank identifier   can also be used to throw away values, like the value 5 in: 
 is in effect a write-only variable, you cannot ask for its value. It exists because a declared variable 
_
in Go must also be used, and sometimes you don’t need to use all return values from a function. 

, b = 5, 7 
_

_

 imports the package trans (which is in the same directory) 

The multiple assignment is also used when a function returns more than 1 value, like here where 
val and an error err are returned from Func1: val, err = Func1(var1) 
4.4.5 Init-functions 
Apart from global declaration with initialization, variables can also be initialized in an init()-function. 
This is a special function with the name init() which cannot be called, but is executed automatically 
before the main() function in package main or at the start of the import of the package that 
contains it. 
Every source file can contain only 1 init()-function. Initialization is always single-threaded and 
package dependency guarantees correct execution order. 
A possible use is to verify or repair correctness of the program state before real execution begins. 
Example: Listing 4.6—init.go: 
package trans 
import “math” 
var Pi float64 
func init() { 
Pi = 4 * math.Atan(1) // init() function computes Pi 
}The Way to Go 
71 
In its init() the variable Pi is initialized by calculation. 
The program in Listing 4.7 use init.go
_
and uses Pi: 
package main 
import ( 
“fmt” 
“./trans” 
) 
var twoPi = 2 * trans.Pi 
func main() { 
fmt.Printf(“2*Pi = %g\n”, twoPi) // 2*Pi = 6.283185307179586 
} 
An init() function is also frequently used when (for example for a server application) a backend() 
goroutine is required from the start of the application, like in: 
func init() { 
// setup preparations 
go backend() 
} 
EXERCISES: Deduce the output of the following programs and explain your answer, then compile 
and execute them. 
Exercise 4.1: local scope.go: 
_
package main 
var a = “G” 
func main() { 
n() 
m() 
n() 
} 
72 
Ivo Balbaert 
func n() { print(a) } 
func m() { 
a := “O” 
print(a) 
} 
Exercise 4.2: global scope.go: 
package main 
var a = “G” 
func main() { 
n() 
m() 
n() 
} 
func n() { 
print(a) 
} 
func m() { 
a = “O” 
print(a) 
} 
Exercise 4.3: function calls function.go 
package main 
var a string 
func main() { 
a = “G” 
print(a) 
f1() 

_

_

_

}The Way to Go 
73 
func f1() { 
a := “O” 
print(a) 
f2() 
} 
func f2() { 
print(a) 
} 
4.5. Elementary types and operators 
In this paragraph, we discuss the boolean, numerical and character data types. 
Values are combined together with operators into expressions, which are also values of a certain type. 
Every type has its own defined set of operators, which can work with values of that type. If an 
operator is used for a type for which it is not defined, a compiler error results. 
A unary operator works on one value (postfix), a binary operator works on two values or operands 
(infix). 
The two values for a binary operator must be of the same type. Go does not implicitly convert the 
type of a value, if necessary this must be done by an explicit conversion (see § 4.2): Go is strongly 
typed.There is no operator overloading as in C and Java. An expression is by default evaluated from 
left to right. 
There is a built-in precedence amongst the operators (see § 4.5.3) telling us which operator in an 
expression has the highest priority, and so gets executed first. But the use of parentheses ( ) around 
expression(s) can alter this order: an expression within ( ) is always executed first. 
4.5.1. Boolean type bool 
An example: var b bool = true 
The possible values of this type are the predefined constants true and false. 
Two values of a certain type can be compared with each other with the relational operators == and 
!= producing a boolean value: 
Equality operator: 
==74 
Ivo Balbaert 
This gives true if the values on both sides are the same (values), false otherwise. This supposes that 
they are of the same type. 
Example: 
var aVar = 10 
aVar == 5 
false 
aVar == 10 
true 
Not-equal operator: 
!= 
This gives true if the values on both sides are different (values), false otherwise. 
Example: 
var aVar = 10 
aVar != 5 
true 
aVar != 10 
false 
Go is very strict about the values that can be compared: they have to be of the same type, or if they 
are interfaces (see Chapter 11) they must implement the same interface type. If one of them is a 
constant, it must be of a type compatible with the other. If these conditions are not satisfied, one 
of the values has first to be converted to the other’s type. 
Boolean constants and variables can also be combined with logical operators ( not, and, or) to 
produce a boolean value. Such a logical statement is not a complete Go-statement on itself. 
The resultant boolean value can then be tested against in conditional structures (see chapter 5). 
And, or and equals are binary operators; not is a unary operator. We will use T representing a true 
statement, and F for a false statement. 
The following are the logical operators: 
NOT operator: 
! 
!T
false 
!F
true 
It turns the boolean value into its opposite. 
AND operator: 
&& 

T && T
trueThe Way to Go 
75 
T && F
false 
F && T
false 
F && F
false 
It only gives true if both operands are true. 
OR operator: 
|| 
T || T true 
T || F
true 
F || T
true 
F || F
false 
It is true if any one of the operands is true, it only gives false if both operands are false. 
The && and || operators behave in a shortcut way: when the value of the left side is known and it 
is sufficient to deduce the value of the whole expression (false with && and true with ||), then the 
right side is not computed anymore. For that reason: if one of the expressions involves a longlasting 
calculation, put this expression at the right side. 
Like in all expressions, ( ) can be used to combine values and influence the result. 
In format-strings %t is used as a format specifier for booleans. 
Boolean values are most often used (as values or combined with their operators) for testing the 
conditions of if-, for- and switch-statements (see chapter 5). 
A useful naming convention for important boolean values and functions is to let the name begin 
with is or Is, like isSorted, isFound, isFinished, isVisible, so code in if-statements reads as a normal 
sentence, e.g.: unicode.IsDigit(ch) (see § 4.5.5). 
4.5.2. Numerical types 
4.5.2.1 ints and floats 
There are types for integers, floating point numbers and there is also native support for complex 
numbers. The bit representation is two’s complement (for more info see http://en.wikipedia.org/ 
wiki/Two’s complement).
_
Ivo Balbaert 
Go has architecture dependent types such as int, uint, uintptr. 
They have the appropriate length for the machine on which the program runs: 
an int is the default signed type: it takes 32 bit (4 bytes) on a 32 bit machine and 64 bit(8 
bytes) on a 64 bit machine; the same goes for the unsigned uint. 
uintptr is an unsigned integer large enough to store a pointer value. 
A float type does not exist. 
The architecture independent types have a fixed size (in bits) indicated by their names: 
For integers: 
int8 (-128 -> 127) 
int16 (-32768 -> 32767) 
int32 (− 2,147,483,648 -> 2,147,483,647) 
int64 (− 9,223,372,036,854,775,808 -> 9,223,372,036,854,775,807) 
For unsigned integers: 
uint8 (with alias byte, 0 -> 255) 
uint16 (0 -> 65,535) 
uint32 (0 -> 4,294,967,295) 
uint64 (0 -> 18,446,744,073,709,551,615) 
For floats: 
float32 (+- 1O-45 -> +- 3.4 * 1038 ) 
(IEEE-754) 
float64 (+- 5 * 10-324 -> 1.7 * 10308 ) 
int is the integer type which offers the fastest processing speeds. 
The initial (default) value for integers is 0, and for floats this is 0.0 
A float32 is reliably accurate to about 7 decimal places, a float64 to about 15 decimal places. Due 
to the fact that perfect accuracy is not possible for floats comparing them with == or != must be 
done very carefully; if needed a test on the difference being smaller than a very small number (the 
accuracy limit) must be made. 
Use float64 whenever possible, because all the functions of the math package expect that type. 
Numbers may be denoted in octal notation with a prefix of 0 (like 077), hexadecimal with a prefix 

76 

_

of 0x (like 0xFF) or scientific notation with e, which represents the power of 10 (e.g.: 1e3 = 1000 
or 6.022e23 = 6.022 x 1023).The Way to Go 
77 
Note that you can make a number like this: a := uint64(0) which is in fact a conversion to type 
uint64. 
Because Go is strongly typed, mixing of types is not allowed, as in the following program. But 
constants are considered typeless in this respect, so with constants mixing is allowed. 
Listing 4.8—type mixing.go (does not compile!): 
package main 
func main() { 
var a int 
var b int32 
a = 15 
b = a + a // compiler error 
b = b + 5 // ok: 5 is a constant 
} 
The compiler error is: cannot use a + a (type int) as type int32 in assignment 
Likewise an int16 cannot be assigned to an int32, there is no implicit coercion. 
In the following program casting.go, an explicit conversion is done to avoid this (see §4.2) 
Listing 4.9—casting.go: 
package main 
import “fmt” 
func main() { 
var n int16 = 34 
var m int32 
// compiler error: cannot use n (type int16) as type int32 in assignment 
//m = n 
m = int32(n) 
fmt.Printf(“32 bit int is: %d\n”, m) 
fmt.Printf(“16 bit int is: %d\n”, n) 
} 
// the output is: 
32 bit int is: 34 
16 bit int is: 3478 
Ivo Balbaert 
Format specifiers: 
In format-strings %d is used as a format specifier for integers (%x or %X can be used for a 
hexadecimal representation), %g is used for float types (%f gives a floating point, %e gives a 
scientific notation), %0nd shows an integer with n digits, and leading 0 is necessary. 
%n.mg represents the number with m digits after the decimal sign, and n before it, instead of g also 
e and f can be used, for example: the %5.2e formatting of the value 3.4 gives 3.40e+00 
Conversions of numerical values: 
In a conversion like a32bitInt = int32(a32Float) truncation of the decimal part occurs. In general 
information is lost when converting to a smaller type, therefore in order to avoid loss of accuracy 
always convert to the bigger numerical type. Or you could write suitable functions to perform safe 
downsizing conversions, like the following for converting an int to a uint8: 
func Uint8FromInt(n int) (uint8, error) { 
if 0 <= n && n <= math.MaxUint8 { // conversion is safe 
return uint8(n), nil 
} 
return 0, fmt.Errorf(“%d is out of the uint8 range”, n) 
} 
Or for safe converting of a float64 to an int: 
func IntFromFloat64(x float64) int { 
if math.MinInt32 <= x && x <= math.MaxInt32 { // x lies in the integer range 
whole, fraction := math.Modf(x) 
if fraction >= 0.5 { 
whole++ 
} 
return int(whole) 
} 
panic(fmt.Sprintf(“%g is out of the int32 range”, x)) 
} 
In the case that x does not sit in the integer range, the program stops with a panic message (see § 
13.2). 
Question 4.1: Are int and int64 the same type ?The Way to Go 
79 
4.5.2.2 Complex numbers 
For these data we have the following types: 
complex64 (with a 32 bit real and imaginary part) 
complex128 (with a 64 bit real and imaginary part) 
A complex number is written in the form: re + imi, where re is the real part, and im is the imaginary 
part, and i is the √ -1 . 

Example: 
var c1 complex64 = 5 + 10i 
fmt.Printf(“The value is: %v”, c1) 
// this will print: 5 + 10i 
If re and im are of type float32, a variable c of type complex64 can be made with the function 
complex: 
c = complex(re, im) 
The functions real(c) and imag(c) give the real and imaginary part respectively. 
In format-strings %v the default format specifier can be used for complex numbers; otherwise use 
%f for both constituent parts. 
Complex numbers support all the normal arithmetic operations as other numbers. You can only 
compare them with == and !=, but again be aware of precision. The package cmath contains 
common functions for operating on complex numbers. When memory constraints are not too 
tight, use type complex128 because all cmath functions use it. 
4.5.2.3 Bit operators 
They work only on integer variables having bit-patterns of equal length: 
%b is the format-string for bit-representations. 
Binary: Bitwise and: 
& 
bits in the same position are and-ed together, see AND-operator in §4.5.1, 
replacing T (true) by 1 and F (false) by 0: 
1 & 1 1 
1 & 0 0 
0 & 1 0 
0 & 0 080 
Ivo Balbaert 
Bitwise or: 
| 
bits in the same position are or-ed together, see OR-operator in §4.5.1, replacing 
T (true) by 1 and F (false) by 0 
1 | 1
1 
1 | 0
1 
0 | 1
1 
0 | 0
0 
Bitwise xor: 
^ 
bits in the same position are taken together according to the rule: 
1 ^ 1 0 
1 ^ 0 1 
0 ^ 1 1 
0 ^ 0 0 
Bit clear: 
&^ 
forces a specified bit to 0. 
(equivalent to and not) 
Unary: Bitwise complement: 
^ 
is defined with the xor operator: it is m ^ x with m = “all bits set to 1” for unsigned 
x and m = -1 for signed x 
e.g.: ^2 = ^10 = -01 ^ 10 = -11 
BitShift 
Left Shift: 
<< 
, for example: bitP << n 
the bits of bitP shift n positions to the left, the empty positions on the right are filled 
with 0’s; if n is 2, the number is multiplied by 2, left shift by n effects to a multiplication 
by 2n 
So 1 << 10 // equals 1 KB (kilobyte) 
1 << 20 // equals 1 MB (megabyte) 
1 << 30 // equals 1 GB (gigabyte) 
Right Shift: >> 

, for example: bitP >> n 
the bits of bitP shift n positions to the right, the empty positions on the left are filled with 
0’s; if n is 2, the number is divided by 2, right shift by n effects to a division by 2n The Way to Go 
81 
When the result is assigned to the first operand, they can also be abbreviated like a <<= 2 or b ^= 
a & 0xffffffff 
Commonly used constants in memory resource usage: 
Applying the << operator and the use of iota in constants, the following type definition neatly 
defines memory constants: 
type ByteSize float64 
const ( 
 = iota // ignore first value by assigning to blank identifier 
_
KB ByteSize = 1<<(10*iota) 
MB 
GB 
TB 
PB 
EB 
ZB 
YB 
) 
A type BitFlag for working with bits in communication: 
type BitFlag int 
const ( 
Active BitFlag = 1 << iota // 1 << 0 == 1 
Send 
// 1 << 1 == 2 
Receive 
// 1 << 2 == 4 
) 
flag := Active | Send 
// == 3 
4.5.2.4 Logical operators 
Here we have the usual ==, != (see § 4.5.1) and <, <=, > and >= 
They are called logical because the result value is of type bool: b3:= 10 > 5 // b3 is true82 
Ivo Balbaert 
4.5.2.5 Arithmetic operators 
The common binary operators +, -, * and / exist for both integers and floats. 
(In contrast to the general rule, this could be called a form of operator overloading; moreover the + 
operator also exists for strings; but outside this Go does not allow operator overloading.) 
/ for integers is integer division, for example: 9 / 4 -> 2. 
The modulus operator % is only defined for integers: 9 % 4 -> 1 
Integer division by 0 causes the program to crash, a run-time panic occurs (if it is obvious then the 
compiler can detect it); see Chapter 13 for how to test for this properly. 
Division by 0.0 with floating point numbers gives an infinite result: +Inf 
Exercise 4.4: Try this out: divby0.go 
There are shortcuts for these operations: b = b + a can be shortened to b += a, and the same goes 
for -=, *=, /= and %=. 
As unary operators for integers and floats we have ++ (increment) and -- (decrement), but only 
after the number (postfix): 
i++ is short for i += 1 is short for i = i + 1 
i-- is short for i -= 1 is short for i = i – 1 
Moreover ++ and - - may only be used as statements, not expressions; so n = i++ is invalid, and 
subtler expressions like f(i++) or a[i]=b[i++], which are accepted in C, C++ and Java, cannot be 
used in Go. 
No error is generated when an overflow occurs during an operation: high bits are simply discarded. 
Constants can be of help here, and if you need integers or rational numbers of unbounded size 
(that is only limited by the available memory) you can use the big package from the standard 
library, which provides the types big.Int and big.Rat (see § 9.4). 
4.5.2.6 Random numbers 
Some programs like games or statistical applications need random numbers. The package rand 
implements pseudo-random number generators. The Way to Go 
83 
For a simple example see Listing 4.10—random.go, which prints 10 random non-negative 
integers. 
package main 
import ( 
“fmt” 
“rand” 
“time” 

) 
func main() { 
for i := 0; i < 10; i++ { 
a := rand.Int() 
fmt.Printf(“%d / “, a) 
} 
for i := 0; i < 5; i++ { 
r := rand.Intn(8) 
fmt.Printf(“%d / “, r) 
} 
fmt.Println() 
timens := int64(time.Now().Nanosecond()) 
rand.Seed(timens) 
for i := 0; i < 10; i++ { 
fmt.Printf(“%2.2f / “, 100*rand.Float32()) 
} 
} 
Output, for example: 816681689 / 1325201247 / 623951027 / 478285186 / 1654146165 / 
1951252986 / 2029250107 / 762911244 / 1372544545 / 591415086 / / 3 / 0 / 6 / 4 / 2 /22.10 
/ 65.77 / 65.89 / 16.85 / 75.56 / 46.90 / 55.24 / 55.95 / 25.58 / 70.61 / 
The functions rand.Float32 and rand.Float64 return a pseudo-random number of that type in 
[0.0, 1.0), ) here means the upper bound not included. The function rand.Intn takes an int n and 
returns a non-negative pseudo-random number in [0,n). 
You can use the Seed(value)-function to provide a starting value for the pseudo-random generation. 
Often the current offset time in nanoseconds is used for that purpose (see § 4.8).84 
Ivo Balbaert 
4.5.3. Operators and precedence 
Some operators have higher priority (precedence) than others; binary operators of the same 
precedence associate from left to right. The following table lists all operators and their precedence, 
top to bottom (7 -> 1) is highest to lowest: 
Precedence 
Operator(s) 
7 
^ ! 
6 
* / % << >> & &^ 
5 
+ - | ^ 
4 
== != < <= >= > 
3 
<- 
2 
&& 
1 
|| 
It is of course allowed to clarify expressions by using ( ) to indicate priority in operations: 
expressions contained in ( ) are always computed first. 
4.5.4. Aliasing types 
When working with types, a type can also be given another name, so that this new name can be 
used in the code (for shortening names, or avoiding a name-clash). 
In 
type TZ int TZ is declared as a new name for the int type (perhaps it represents time zones 
in a program), and can then be used to declare int-variables, like in the following program: 
Listing 4.11—type.go : 
package main 
import “fmt” 
type TZ int 
func main() { 
var a, b TZ = 3, 4 
c := a + b 
fmt.Printf(“c has the value: %d”, c) // prints: c has the value: 7 
} 
In fact this alias is a brand new type, which can have methods that the original type does not have 
(see Chapter 10); TZ can have a method to output the time zone-info in a clear or pretty way.The Way to Go 
85 
Exercise 4.5: Define an alias type Rope for string and declare a variable with it. 
4.5.5. Character type 
Strictly speaking this is not a type in Go: characters are a special case of integers. The byte type is 
an alias for uint8, and this is ok for the traditional ASCII-encoding for characters (1 byte): var ch 
byte = ‘A’ ; a character is surrounded by single quotes ‘ ’. 
In the ASCII-table the decimal value for A is 65, and the hexadecimal value is 41, so the following 
are also declarations for the character A: 
var ch byte = 65 or var ch byte = ‘\x41’ 

(\x is always followed by exactly 2 hexadecimal digits). 
Another possible notation is a \ followed by exactly 3 octal digits, e.g. ‘\377’. 
But there is also support for Unicode (UTF-8): characters are also called Unicode code points or 
runes, and a Unicode character is represented by an int in memory. In documentation they are 
commonly represented as U+hhhh, where h us a hexadecimal digit. In fact the type rune exists in 
Go and is an alias for type int32. 
To write a Unicode-character in code preface the hexadecimal value with \u or \U. 
Because they need at least 2 bytes we have to use the int16 or int type. If 4 bytes are needed for the 
character \U is used; \u is always followed by exactly 4 hexadecimal digits and \U by 8 . 
The following code (see Listing 4.12 char.go) 
var ch int = ‘\u0041’ 
var ch2 int = ‘\u03B2’ 
var ch3 int = ‘\U00101234’ 
fmt.Printf(“%d - %d - %d\n”, ch, ch2, ch3) 
// integer 
fmt.Printf(“%c - %c - %c\n”, ch, ch2, ch3) 
// character 
fmt.Printf(“%X - %X - %X\n”, ch, ch2, ch3) 
// UTF-8 bytes 
fmt.Printf(“%U - %U - %U”, ch, ch2, ch3) 
// UTF-8 code point 
prints out: 
65 - 946 - 1053236 
A - - 􁈴 
41 - 3B2 - 101234 
U+0041 - U+03B2 - U+101234 86 
Ivo Balbaert 
In format-strings %c is used as a format specifier for characters: the character is shown, 
format-specifiers %v or %d show the integer representing the character; %U outputs the U+hhhh 
notation (for another example: see § 5.4.4). 
The package unicode has some useful functions for testing characters, like (ch is a character): 
testing for a letter: 
unicode.IsLetter(ch) 
testing for a digit: 
unicode.IsDigit(ch) 
testing for a whitespace character: 
unicode.IsSpace(ch) 
They return a bool value. The utf8 package further contains functions to work with runes. 
4.6. Strings 
Strings are a sequence of UTF-8 characters (the 1 byte ASCII-code is used when possible, a 2-4 byte 
UTF-8 code when necessary). UTF-8 is the most widely used encoding, the standard encoding 
for text files, XML files and JSON strings. While able to represent characters that need 4 bytes, 
ASCII-characters are still stored using only 1 byte. A Go string is thus a sequence of variable-width 
characters (each 1 to 4 bytes, see Ex. 4.6), contrary to strings in other languages as C++, Java or 
Python that are fixed-width (Java uses always 2 bytes). The advantages are that Go strings and text 
files occupy less memory/disk space, and since UTF-8 is the standard, Go doesn’t need to encode 
and decode strings as other languages have to do. 
Strings are value types and immutable: once created you cannot modify the contents of the string; 
formulated in another way: strings are immutable arrays of bytes. 
2 kinds of string literals exist: 
Interpreted strings: 
surrounded by ““(double quotes), 
escape sequences are interpreted: 
for example: \n represents a newline 
\r represents a carriage return 
\t represents a tab 
\u or \U Unicode characters 
the escape character \ can also be used to remove the special meaning of the 
following character, so \” simply prints a “, and \’ is ‘, \\ prints a \ 
Raw strings: 
surrounded by ` ` (back quotes: AltGr + £), they are not interpreted; they 
can span multiple lines. 
in `This is a raw string \n` \n is not interpreted but taken literally.The Way to Go 
87 
Strings are length-delimited and do not terminate by a special character as in C/C++ 
The initial (default) value of a string is the empty string “” . 
The usual comparison operators (== != < <= >= >) work on strings by comparing byte by byte 

in memory. The length of a string str (the number of bytes) is given by the len() function: 
len(str) 
The contents of a string (the ‘raw’ bytes) is accessible via standard indexing methods, the index 
between [ ], with the index starting from 0: 
the first byte of a string str is given by: 
str[0] 
the i-th byte by: 
str[i] 
the last byte by: 
str[len(str)-1] 
However these translate only to real characters if only ASCII characters are used! 
Note: Taking the address of a character in a string, like &str[i], is illegal. 
Adding (concatenating) strings: + 
Two strings s1 and s2 can be made into one string s with: s := s1 + s2 
s2 is appended to s1 to form a new string s. 
Multi-line strings can be constructed as follows: 
str := “Beginning of the string “+ 
“second part of the string” 
The + has to be on the first line, due to the insertion of ; by the compiler. 
The append shorthand += can also be used for strings: 
s := “hel” + “lo,” 
s += “world!” 
fmt.Println(s) // prints out “hello, world!” 
Concatenating strings in a loop using + is not the most efficient way, a better approach is to use 
strings.Join() (see § 4.7.10), even better is to use writing in a byte-buffer (§ 7.2.6).88 
Ivo Balbaert 
In chapter 7 we will see that strings can be considered as slices of bytes (or ints), and that the 
slice-indexing operations thus also apply for strings. The for-loop from § 5.4.1 loops over the index 
and so only returns the raw bytes, to loop over the Unicode characters in the string we must use 
the for-range loop from § 5.4.4 (see also the example in § 7.6.1). In the next § we learn a number 
of useful methods for working with strings. And then there is also the function fmt.Sprint(x) from 
the fmt package, to produce a string out of data in the format you want (see § 4.4.3). 
Exercise 4.6: count characters.go 
Create a program that counts the number of bytes and characters (runes) for this string: 
“asSASA ddd dsjkdsjs dk” 
Then do the same for this string: “asSASA ddd dsjkdsjs こん dk” 
Explain the difference. (hint: use the unicode/utf8 package.) 
4.7. The strings and strconv package 
Strings are a basic data structure, and every language has a number of predefined functions for 
manipulating strings. In Go these are gathered in the package strings. 
Some very useful functions are: 
4.7.1—Prefixes and suffixes: 
HasPrefix tests whether the string s begins with prefix: 
strings.HasPrefix(s, prefix string) bool 
HasSuffix tests whether the string s end with suffix: 
strings.HasSuffix(s, suffix string) bool 
Listing 4.13—presuffix.go: 
package main 
import ( 
“fmt” 
“strings” 
) 
func main() { 
var str string = “This is an example of a string” 
fmt.Printf(“T/F? Does the string \”%s\” have prefix %s? “, str, “Th”) 
fmt.Printf(“%t\n”, strings.HasPrefix(str, “Th”)) 
}The Way to Go 
89 
Output: T/F? Does the string “This is an example of a string” have prefix Th? True 
This illustrates also the use of the escape character \ to output a literal “with \”, and the use of 2 
substitutions in a format-string. 
4.7.2—Testing whether a string contains a substring: 
Contains returns true if substr is within s: 
strings.Contains(s, substr string) bool 
4.7.3—Indicating at which position (index) a substring or character occurs in a string: 
Index returns the index of the first instance of str in s, or -1 if str is not present in s: 
strings.Index(s, str string) int 
LastIndex returns the index of the last instance of str in s, or -1 if str is not present in s: 

_

_

_ _

strings.LastIndex(s, str string) int 
If ch is a non-ASCII character use strings.IndexRune(s string, ch int) int. 
An example: Listing 4.14—index in string.go: 
package main 
import ( 
“fmt” 
“strings” 
) 
func main() { 
var str string = “Hi, I’m Marc, Hi.” 
fmt.Printf(“The position of \“Marc\” is: “) 
fmt.Printf(“%d\n”, strings.Index(str, “Marc”)) 
fmt.Printf(“The position of the first instance of \“Hi\” is: “) 
fmt.Printf(“%d\n”, strings.Index(str, “Hi”)) 
fmt.Printf(“The position of the last instance of \“Hi\” is: “) 
fmt.Printf(“%d\n”, strings.LastIndex(str, “Hi”)) 
fmt.Printf(“The position of \“Burger\” is: “) 
fmt.Printf(“%d\n”, strings.Index(str, “Burger”)) 
} 
Output: 
The position of “Marc” is: 8 
The position of the first instance of “Hi” is: 0 
The position of the last instance of “Hi” is: 14 
The position of “Burger” is: -190 
Ivo Balbaert 
4.7.4—Replacing a substring: 
With strings.Replace(str, old, new, n) you can replace the first n occurrences of old in str by 
new. A copy of str is returned, and if n = -1 all occurrences are replaced. 
4.7.5—Counting occurrences of a substring: 
Count the number of non-overlapping instances of substring str in s with: strings.Count(s, str 
string) int 
An example: Listing 4.15—count substring.go: 
package main 
import ( 
“fmt” 
“strings” 
) 
func main() { 
var str string = “Hello, how is it going, Hugo?” 
var manyG = “gggggggggg” 
fmt.Printf(“Number of H’s in %s is: “, str) 
fmt.Printf(“%d\n”, strings.Count(str, “H”)) 
fmt.Printf(“Number of double g’s in %s is: “, manyG) 
fmt.Printf(“%d\n”, strings.Count(manyG, “gg”)) 
} 
Output: 
Number of H’s in Hello, how is it going, Hugo? is: 2 
Number of double g’s in gggggggggg is: 5 
4.7.6—Repeating a string: 
Repeat returns a new string consisting of count copies of the string s: strings.Repeat(s, count 
int) string 
An example: Listing 4.16—repeat string.go : 
package main 
import ( 
“fmt”The Way to Go 
91 
“strings” 
) 
func main() { 
var origS string = “Hi there!” 
var newS string 
newS = strings.Repeat(origS, 3) 
fmt.Printf(“The new repeated string is: %s\n”, newS) 
} 
Output: 
The new repeated string is: Hi there! Hi there! Hi there! 
4.7.7—Changing the case of a string: 
ToLower returns a copy of the string s with all Unicode letters mapped to their lower case: 
strings.ToLower(s) string 
All uppercase is obtained with: strings.ToUpper(s) string 
An example: Listing 4.17—toupper lower.go: 
package main 

_

_

import ( 
“fmt” 
“strings” 
) 
func main() { 
var orig string = “Hey, how are you George?” 
var lower string 
var upper string 
fmt.Printf(“The original string is: %s\n”, orig) 
lower = strings.ToLower(orig) 
fmt.Printf(“The lowercase string is: %s\n”, lower) 
upper = strings.ToUpper(orig) 
fmt.Printf(“The uppercase string is: %s\n”, upper) 
} 
Output: 
The original string is: Hey, how are you George? 
The lowercase string is: hey, how are you george? 
The uppercase string is: HEY, HOW ARE YOU GEORGE?Ivo Balbaert 
4.7.8—Trimming a string: 
Here you can use strings.TrimSpace(s) to remove all leading and trailing whitespace; if you want 
to specify in a string cut which characters to remove, use strings.Trim(s, “cut”). 
Example: strings.Trim(s, “\r\n”) removes all leading and trailing \r and \n from the string s. The 
2nd string-parameter can contain any characters, which are all removed from the left and right-side 
of s. If you want to remove only leading or only trailing characters or strings, use TrimLeft or 
TrimRight. 
4.7.9—Splitting a string: 
On whitespace: strings.Fields(s) splits the string s around each instance of one or more 
consecutive white space characters, returning a slice of substrings []string of s or an empty list if s 
contains only white space. 
On a separator sep: strings.Split(s, sep) : works the same as Fields, but splits around a separator 
character or string sep (e.g.: ; or, or -). 
Because both return a []string, they are often used within a for-range loop (see § 7.3) 
4.7.10—Joining over a slice: 
This results in a string with all the elements of the slice, separated by sep: 
Strings.Join(sl []string, sep string) 
These simple operations are illustred in Listing 4.18—strings splitjoin.go: 
package main 
import ( 
“fmt” 
“strings” 
) 
func main() { 
str := “The quick brown fox jumps over the lazy dog” 
sl := strings.Fields(str) 
fmt.Printf(“Splitted in slice: %v\n”, sl) 
for  , val := range sl { 
fmt.Printf(“%s - “, val) 
} 
fmt.Println() 
92The Way to Go 
str2 := “GO1|The ABC of Go|25” 
sl2 := strings.Split(str2, “|”) 
fmt.Printf(“Splitted in slice: %v\n”, sl2) 
for  , val := range sl2 { 
fmt.Printf(“%s - “, val) 
} 
fmt.Println() 
str3 := strings.Join(sl2,”;”) 
fmt.Printf(“sl2 joined by ;: %s\n”, str3) 
} 
/* Output: 
Splitted in slice: [The quick brown fox jumps over the lazy dog] 
The - quick - brown - fox - jumps - over - the - lazy - dog - 
Splitted in slice: [GO1 The ABC of Go 25] 
GO1 - The ABC of Go - 25 - 
sl2 joined by ;: GO1;The ABC of Go;25 
*/ 
Documentation for other functions in this package can be found at: http://golang.org/pkg/ 
strings/ 
4.7.11—Reading from a string: 
The package also has a strings.NewReader(str) function. This procuces a pointer to a Reader value, 
that provides amongst others the following functions to operate on str: 
• Read() to read a []byte 

_

_

_

_

_

_

• ReadByte() and ReadRune() : to read the next byte or rune from the string. 
4.7.12—Conversion to and from a string: 
This functionality is offered by the package strconv. 
It contains a few variables to calculate the size in bits of an int of the platform on which the 
program runs: strconv.IntSize 
To convert a variable of a certain type T to a string will always succeed. 
For converting from numbers we have the following functions: 
9394 
Ivo Balbaert 
strconv.Itoa(i int) string : returns the decimal string representation of i 
strconv.FormatFloat(f float64, fmt byte, prec int, bitSize int) string: 
converts the 64-bit floating-point number f to a string, according to the format 
fmt (can be ‘b’, ‘e’, ‘f’ or ‘g’), precision prec and bitSize is 32 for float32 or 
64 for float64. 
Converting a string to another type tp will not always be possible, in that case a runtime error is 
thrown: parsing “…”: invalid argument 
For converting to numbers we have the following functions: 
strconv.Atoi(s string) (i int, err error) 
: convert to an int 
strconv.ParseFloat(s string, bitSize int) (f float64, err error) : convert to a 
64bit floating-point number 
As can be seen from the return-type these functions will return 2 values: the converted value (if 
possible) and the possible error. So when calling such a function the multiple assignment form will 
be used: 
val, err = strconv.Atoi(s) 
For an example of use, see program: string conversion.go. 
In this program we disregard the possible conversion-error with the blank identifier  : _
anInt,   = strconv.Atoi(origStr) 
Listing 4.19—string conversion.go: 
Package main 
import ( 
“fmt” 
“strconv” 
) 
func main() { 
var orig string = “666” 
var an int 
var newS string 
fmt.Printf(“The size of ints is: %d\n”, strconv.IntSize) 
an,   = strconv.
Atoi(orig) 
fmt.Printf(“The integer is: %d\n”, an) 
an = an + 5 
newS = strconv.Itoa(an) 
fmt.Printf(“The new string is: %s\n”, newS) 
}The Way to Go 
95 
/* Output: 
The size of ints is: 32 
The integer is: 666 
The new string is: 671 */ 
In § 5.1 discussing the if-statement we will see a way to test a possible error on return. 
For more information see: 
http://golang.org/pkg/strconv/ 
4.8. Times and dates 
The package time gives us a datatype time.Time (to be used as a value) and functionality for 
displaying and measuring time and dates. 
The current time is given by time.Now(), and the parts of a time can then be obtained as t.Day(), 
t.Minute(), etc. ; you can make your own time-formats as in: fmt.Printf(“%02d.%02d.%4d\n”, 
t.Day(), t.Month(), t.Year()) // e.g.: 21.07.2011 
The type Duration represents the elapsed time between two instants as an int64 nanosecond count. 
The type Location maps time instants to the zone in use at that time, UTC represents Universal 
Coordinated Time. 
There is a predefined function func (t Time) Format(layout string) string, which formats a 
time t into a string according to a layout string, with some predefined formats like time.ANSIC 
or time.RFC822 
The general layout defines the format by showing the representation of a standard time, which is 
then used to describe the time to be formatted; this seems strange, but an example makes this clear: 
fmt.Println(t.Format(“02 Jan 2006 15:04”)) // outputs now: 21 Jul 2011 10:31 
(see program time.go, more info at: http://golang.org/pkg/time/) 

_

_

_

_

Listing 4.20—time.go : 
package main 
import ( 
“fmt” 
“time” 
)96 
Ivo Balbaert 
var week time.Duration 
func main() { 
t := time.Now() 
fmt.Println(t) // e.g. Wed Dec 21 09:52:14 +0100 RST 2011 
fmt.Printf(“%02d.%02d.%4d\n”, t.Day(), t.Month(), t.Year()) 
// 21.12.2011 
t = time.Now().UTC() 
fmt.Println(t) // Wed Dec 21 08:52:14 +0000 UTC 2011 
fmt.Println(time.Now()) // Wed Dec 21 09:52:14 +0100 RST 2011 
// calculating times: 
week = 60 * 60 * 24 * 7 * 1e9 // must be in nanosec 
week from now := t.
Add(week) 
_
fmt.Println(week from now) // Wed Dec 28 08:52:14 +0000 UTC 2011 
// formatting times: 
fmt.Println(t.Format(time.RFC822)) // 21 Dec 11 0852 UTC 
fmt.Println(t.Format(time.ANSIC)) // Wed Dec 21 08:56:34 2011 
fmt.Println(t.Format(“02 Jan 2006 15:04”)) // 21 Dec 2011 08:52 
s := t.Format(“20060102”) 
fmt.Println(t, “=>”, s) 
// Wed Dec 21 08:52:14 +0000 UTC 2011 => 20111221 
} 
The output is shown after the // in each line. 
If you need to let something happen in an application after a certain amount of time or periodically 
(a special case of event-handling) time.After and time.Ticker are what you need: §14.5 discusses 
their interesting possibilities. There is also a function time.Sleep(Duration d), which pauses the 
current process (goroutine in fact, see § 14.1) for a Duration d. 
4.9. Pointers 
Unlike Java and .NET, Go gives the programmer control over which data structure is a pointer 
and which is not; however you cannot calculate with pointer values in programs. By giving the 
programmer control over basic memory layout, Go provides you the ability to control the total 
size of a given collection of data structures, the number of allocations, and the memory access 
patterns, all of which are important for building systems that perform well: pointers are important 
for performance and indispensable if you want to do systems programming, close to the operating 
system and network.The Way to Go 
97 
Because pointers are somewhat unknown to contemporary OO-programmers, we will explain 
them here and in the coming chapters in depth. 
Programs store values in memory, and each memory block (or word) has an address, which is 
usually represented as a hexadecimal number, like 0x6b0820 or 0xf84001d7f0 
Go has the address-of operator &, which when placed before a variable gives us the memory address 
of that variable. 
The following code-snippet (see Listing 4.9 pointer.go) outputs for example: “An integer: 5, its 
location in memory: 0x6b0820” (this value will be different every time you run the program!) 
var i1 = 5 
fmt.Printf(“An integer: %d, it’s location in memory: %p\n”, i1, &i1) 
This address can be stored in a special data type called a pointer, in this case it is a pointer to an int, 
here i1: this is denoted by *int. If we call that pointer intP, we can declare it as 
var intP *int 
Then the following is true: 
intP = &i1, intP points to i1. 
( because of its name a pointer is represented by %p in a format-string ) 
intP stores the memory address of i1; it points to the location of i1, it references the variable i1. 
A pointer variable contains the memory address of another value: it points to that value in memory 
and it takes 4 bytes on 32 bit machines, and 8 bytes on 64 bit machines, regardless of the size of 
the value they point to. Of course pointers can be declared to a value of any type, be it primitive 
or structured; the * is placed before the type of the value (prefixing), so the * is here a type modifier. 
Using a pointer to refer to a value is called indirection. 
A newly declared pointer which has not been assigned to a variable has the nil value. 
A pointer variable is often abbreviated as ptr. 
!! In an expression like var p *type always leave a space between the name of the pointer and the 
* - var p*type is syntactically correct, but in more complex expressions it can easily be mistaken 
for a multiplication !!98 
Ivo Balbaert 

_

The same symbol * can be placed before a pointer like *intP, and then it gives the value which the 
pointer is pointing to; it is called the dereference (or contents or indirection) operator; another way to 
say it is that the pointer is flattened. 
So for any variable var the following is true: 
var == *(&var) 
Now we can understand the complete program pointer.go and its output: 
Listing 4.21—pointer.go: 
package main 
import “fmt” 
func main() { 
var i1 = 5 
fmt.Printf(“An integer: %d, its location in memory: %p\n”, i1, &i1) 
var intP *int 
intP = &i1 
fmt.Printf(“The value at memory location %p is %d\n”, intP, *intP) 
} 
Output: 
An integer: 5, its location in memory: 0x24f0820 
The value at memory location 0x24f0820 is 5 
We could represent the memory usage as: 
0x24f0820 
5 
intP 
i1 
Fig 4.4: Pointers and memory usage 
Program string pointer.go gives us an example with strings. 
_
It shows that assigning a new value to *p changes the value of the variable itself (here a string).The Way to Go 
99 
Listing 4.22—string pointer.go: 
package main 
import “fmt” 
func main() { 
s := “good bye” 
var p *string = &s 
*p = “ciao” 
fmt.Printf(“Here is the pointer p: %p\n”, p) // prints address 
fmt.Printf(“Here is the string *p: %s\n”, *p) // prints string 
fmt.Printf(“Here is the string s: %s\n”, s) // prints same string 
} 
Output: 
Here is the pointer p: 0x2540820 
Here is the string *p: ciao 
Here is the string s: ciao 
By changing the ‘object’ through giving *p another value, s is also changed. 
Schematically in memory: 
ciao 
s 
0x2540820 
p 
Fig 4.5: Pointers and memory usage, 2 
Remark:
you cannot take the address of a literal or a constant, as the following code snippet 
shows: 
const i = 5 
ptr := &i //error: cannot take the address of i 
ptr2 := &10 //error: cannot take the address of 10 
So Go, like most other low level (system) languages as C, C++ and D, has the concept of pointers. 
But calculations with pointers (so called pointer arithmetic, e.g. pointer + 2, to go through the bytes 
of a string or the positions in an array), which often lead to erroneous memory access in C and thus 
fatal crashes of programs, are not allowed in Go, making the language memory-safe. Go pointers 
resemble more the references from languages like Java, C# and VB.NET .100 
Ivo Balbaert 
So: 
c = *p++ is invalid Go code!! 
One advantage of pointers is that you can pass a reference to a variable (for example as a parameter 
to a function), instead of passing a copy of the variable. Pointers are cheap to pass, only 4 or 8 
bytes. When the program has to work with variables which occupy a lot of memory, or many 
variables, or both, working with pointers can reduce memory usage and increase efficiency. Pointed 
variables also persist in memory, for as long as there is at least 1 pointer pointing to them, so their 
lifetime is independent of the scope in which they were created. 
On the other hand (but much less likely), because a pointer causes what is called an indirection 
(a shift in the processing to another address), prohibitive use of them could cause performance 

decrease. 
Pointers can also point to other pointers, and this nesting can go arbitrarily deep, so you can 
have multiple levels of indirection, but in most cases this will not contribute to the clarity of your 
code. 
As we will see, in many cases Go makes it easier for the programmer and will hide indirection like 
for example performing an automatic dereference. 
A nil pointer dereference, like in the following 2 lines (see program testcrash.go), is illegal and 
makes a program crash: 
Listing 4.23 testcrash.go: 
package main 
func main() { 
var p *int = nil 
*p = 0 
} 
// in Windows: stops only with: <exit code=”-1073741819” msg=“process crashed”/> 
// runtime error: invalid memory address or nil pointer dereference 
Question 4.2: Give all uses of the symbol * in GoChapter 5—Control structures 
Until now we have seen that a Go program starts executing in main() and sequentially executes the 
statements in that function. But often we want to execute certain statements only if a condition 
is met: we want to make decisions in our code. For this Go provides the following conditional or 
branching structures: 
if else construct 
switch case construct 
select construct, for the switching between channels (see § 14.4 ) 
Repeating one or more statements (a task) can be done with the iterative or looping structure: 
for (range) construct 
Some other keywords like break and continue can alter the behavior of the loop. 
There is also a return keyword to leave a body of statements and a goto keyword to jump the 
execution to a label in the code. 
Go entirely omits the parentheses ( and ) around conditions in if, switch and for-loops, creating 
less visual clutter than in Java, C++ or C# 
5.1—The if else construct 
The if test a conditional (a boolean or logical) statement: if this evaluates to true the body of 
statements between { } after the if is executed, if it is false these statements are ignored and the 
statement following the if is executed. 
if condition { 
// do something 
} 
101102 
Ivo Balbaert 
In a 2nd variant an else,with a body of statements surrounded by { }, is appended, which is executed 
when the condition is false; we have then 2 exclusive branches (only one of them is executed): 
if condition { 
// do something 
} else { 
// do something else 
} 
In a 3rd variant another if condition can be placed after the else, so we have 3 exclusive branches: 
if condition1 { 
// do something 
} else if condition2 { 
// do something else 
} else { 
// catch-all or default 
} 
The number of else if—branches is in principal not limited, but for readability reasons this should 
not be exaggerated. When using this form, place the condition which is most likely true first. 
The { } are mandatory, also when there is only one statement in the body (some people do not 
like this, but on the other hand it is consistent and according to mainstream software engineering 
principles). 
The { after the if and else must be on the same line. The else if and else keywords must be on the 
same line as the closing } of the previous part of the structure. Both of these rules are mandatory 
for the compiler. 
This is invalid Go-code:if x { 
} 
else { 
// INVALID 
} 
Note that every branch is indented with 4 (or 8) spaces or 1 tab, and that the closing } are vertically 
aligned with the if; this is enforced by applying gofmt.The Way to Go 

103 
While ( ) around the conditions are not needed, for complex conditions they may be used to make 
the code clearer. The condition can also be composite, using the logical operators &&, || and !, 
with the use of ( ) to enforce precedence or improve readability. 
A possible application is the testing of different values of a variable and executing different statements 
in each case, but most often the switch statement from § 5.3 is better suited for this. 
Listing 5.1—booleans.go: 
package main 
import “fmt” 
func main() { 
bool1 := true 
if bool1 { 
fmt.Printf(“The value is true\n”) 
} else { 
fmt.Printf(“The value is false\n”) 
} 
} 
// Output: The value is true 
Note that it is not necessary to test: if bool1 == true, because bool1 is already a boolean value. 
It is almost always better to test for true or positive conditions, but it is possible to test for the 
reverse with ! (not): 
if !bool1 
or 
if !(condition). In the last case the ( ) around 
the condition are often necessary, for example: if !(var1 == var2). 
The idiom in Go-code is to omit the else-clause when the if ends in a break, continue, goto or 
return statement. (see also § 5.2). When returning different values x and y whether or not a 
condition is true use the following : 
IDIOM 
if condition { 
return x 
} 
return y 
Remark: 
Don’t use if / else with a return in both branches, this won’t compile: “function 
ends without a return statement” (it’s a compiler bug or feature, but it strengthens the idiom 
above).Ivo Balbaert 
Some useful examples: 
(1) Checking if a string str is empty: 
if str == “” { … } 
or: if len(str) == 0 { … } 
(2) Checking on what operating system the Go-program runs: 
This can be done by testing the constant runtime.GOOS (see §2.2) 
if runtime.GOOS == “windows” { 
… 
} else { // Unix-like 
… 
} 
A good place to do this is in the init()-function. Here is a code-snippet which changes 
a prompt to contain the correct ‘end of input’: 
var prompt = “Enter a digit, e.g. 3 “+ “or %s to quit.” 
func init() { 
if runtime.GOOS == “windows” { 
prompt = fmt.Sprintf(prompt, “Ctrl+Z, Enter”) 
} else { // Unix-like 
prompt = fmt.Sprintf(prompt, “Ctrl+D”) 
} 
} 
(3) A function Abs to give the absolute value of an integer: 
func Abs(x int) int { 
if x < 0 { 
return -x 
} 
return x 
} 
(4) A function isGreater to compare two integers: 
func isGreater(x, y int) bool { 
if x > y { 
return true 
} 
104The Way to Go 
105 
return false 

} 
In a 4th variant the if can start with an initialization statement (in which a value is given to a 
variable). This takes the form (the ; after the initialization is mandatory): 
if initialization; condition { 
// do something 
} 
For example instead of: 
val := 10 
if val > max { 
// do something 
} 
you can write: 
if val := 10; val > max { 
// do something 
} 
But pay attention that in the more concise form, the variable val initialized with := is only known 
within the if-statement (the scope is limited to the statements in { }, but if there is an else clause 
val is also known there): if a variable val existed in the code before the if, its value is hidden during 
the if-block. A simple solution to this is to not use := in the if initialization (see also example 3 in 
§5.2 for how this can be useful). 
Listing 5.2—ifelse.go: 
package main 
import “fmt” 
func main() { 
var first int = 10 
var cond int 
if first <= 0 { 
fmt.Printf(“first is less than or equal to 0\n”) 
} else if first > 0 && first < 5 { 
fmt.Printf(“first is between 0 and 5\n”) 
} else { 
fmt.Printf(“first is 5 or greater\n”) 
} 
if cond = 5; cond > 10 { 
fmt.Printf(“cond is greater than 10\n”)106 
Ivo Balbaert 
} else { 
fmt.Printf(“cond is not greater than 10\n”) 
} 
} 
Output: first is 5 or greater 
cond is not greater than 10 
The following code-snippet shows how the result of a function process( ) can be retrieved in the if, 
and action taken according to the value: 
IDIOM if value := process(data); value > max { 
… 
if value := process(data); value > max { 
…
} 
5.2—Testing for errors on functions with multiple return values 
Often functions in Go are defined so that they return 2 values with successful execution: the value 
and true, and with unsuccessful execution: a 0 (or nil value) and false (see § 4.4). Instead of true 
and false, an error-variable can be returned: in the case of successful execution, the error is nil, 
otherwise it contains the error-information ( an error in Go is a variable of type error: var err 
error, more on this in chapter 13 ). It is then obvious to test the execution with an if-statement; 
because of its notation this is often called the comma, ok pattern. 
In the program string conversion.go
integer. There we disregarded a possible error-condition with: 
anInt,   = strconv.Atoi(origStr) 
If origStr cannot be converted to an integer, the function returns 0 for anInt, and the   absorbs 
the error; the program continues to run. 
This is not good: a program should test for every occurring error and behave accordingly, at least 
informing the user (world) of the error-condition and returning from possibly the function or even 
halting the program. 
This is done in the second version of the code: The Way to Go 
Example 1: 
Listing 5.3—string conversion2.go: 
_
package main 
import ( 
“fmt” 
“strconv” 
) 

 in § 4.7 the function strconv.Atoi converts a string to an 

_

_

_

func main() { 
var orig string = “ABC” 
var an int 
var err error 
an, err = strconv.Atoi(orig) 
if err != nil { 
fmt.Printf(“orig %s is not an integer - exiting with error\n”, orig) 
return 
} 
fmt.Printf(“The integer is %d\n”, an) 
// rest of the code 
} 
The idiom is to test if the error-variable err contains a real error (if err != nil), in that case 
an appropriate message is printed and the program execution leaves the executing function with 
return. We could also have used the form of return which returns a variable, like return err, so 
the calling function can in this case examine the error err. 
IDIOM 
value, err := pack1.Function1(param1) 
if err != nil { 
fmt.Printf(“An error occurred in pack1.Function1 with parameter %v”, 
param1) 
return err 
} 
// normal case, continue execution: 
In this case it was main() executing, so the program stops. 
If we do want the program to stop in case of an error, we can use the function Exit from package 
os instead of return: 
107Ivo Balbaert 
IDIOM 
if err != nil { 
fmt.Printf(“Program stopping with error %v”, err) 
os.Exit(1) 
} 
(The integer which is given to Exit, here 1, can be tested upon in the script outside the program) 
Sometimes this idiom is repeated a number of times in succession. 
No else branch is written: if there is no error-condition, the code simply continues execution after 
the if { }. 
Example 2: we try to open a file name for read-only with os.Open: 
f, err := os.Open(name) 
if err !=nil { 
return err 
} 
doSomething(f) // In case of no error, the file f is passed to a function 
doSomething 
Exercise 5.1: Rewrite string conversion2.go by using also := for the err variable, what can be 
changed? 
Example 3: the possible production of an error can occur in the initialization of an if: 
IDIOM 
if err := file.Chmod(0664); err !=nil { 
fmt.Println(err) 
return err 
} 
(this is a Unix-only example, Chmod from package os attempts to change the mode of a file) 
Example 4: the initialization can also contain a multiple assignment where ok is a bool return 
value, which is tested, like in this form: 
108The Way to Go 
109 
IDIOM 
if value, ok := readData(); ok { 
…
} 
Remark: If you accidentally forget a parameter left of the = sign of a multi-return function call, as 
in the following snippet: 
func mySqrt(f float64) (v float64, ok bool) { 
if f < 0 { return } // error case 
return math.Sqrt(f),true 
} 
func main() { 
t := mySqrt(25.0) 
fmt.Println(t) 
} 
then you get the following compiler error: 
multiple-value mySqrt() in single-value 
context 
It must be: 

_

t, ok := mySqrt(25.0) 
if ok { fmt.Println(t) } 
Remark 2: 
When you are really sure that the things you are dealing with are integers and you 
don’t want to test the return value at every conversion, you can wrap Atoi in a function with only 
returns the integer, like: 
func atoi (s string) (n int) { 
n,   = strconv.Atoi(s) 
_
return 
} 
In fact even the simple Print-functions of fmt (see § 4.4.3) also return 2 values: 
count, err := fmt.Println(x) // number of bytes printed, nil or 0, error 
When printing to the console these are not checked, but when printing to files, network connections, 
etc. the error value should always be checked. (see also Exercise 6.1b)110 
Ivo Balbaert 
5.3—The switch keyword 
Compared to the C, Java—languages, switch in Go is considerably more flexible. It takes the 
general form: switch var1 { 
case val1: 
… 
case val2: 
… 
default: 
… 
} 
where var1 is a variable which can be of any type, and val1, val2, … are possible values of var1; they 
don’t need to be constants or integers, but they must be of the same type, or expressions evaluating 
to that type. The opening { has to be on the same line as the switch. 
More than one value can be tested in a case, the values are presented in a comma separated list 
like: 
case val1, val2, val3: 
Each case-branch is exclusive; they are tried first to last; place the most probable values first. 
The first branch that is correct is executed and then the switch-statement is complete: the break 
from C++, Java and C# happens but is implicit, certainly a big improvement! 
So automatic fall-through is not the default behavior; if you want this, use the keyword fallthrough 
at the end of the branch. 
So 
switch i { 
case 0: //empty case body, nothing is executed when i==0 
case 1: 
f() // f is not called when i==0! 
} 
And: switch i { 
case 0: fallthrough 
case 1: 
f() // f is called when i==0! 
}The Way to Go 
Fallthrough can also be used in a hierarchy of cases where at each level something has to be done 
in addition to the code already executed in the higher cases, and when also a default action has to 
be executed. 
After the case … : multiple statements can follow without them being surrounded by { }, but 
braces are allowed. When there is only 1 statement: it can be placed on the same line as case. 
The last statement of such a body can also be a return with or without an expression. 
When the case-statements ends with a return statement, there also has to be a return statement 
after the } of the switch (see exercise 1). 
The (optional) default branch is executed when no value is found to match var1 with, it resembles 
the else clause in if-else statements. It can appear anywhere in the switch (even as first branch), but 
it is best written as the last branch. 
Listing 5.4—switch1.go: 
package main 
import “fmt” 
func main() { 
var num1 int = 100 
switch num1 { 
case 98, 99: 
fmt.Println(“It’s equal to 98”) 
case 100: 
fmt.Println(“It’s equal to 100”) 
default: 
fmt.Println(“It’s not equal to 98 or 100”) 
} 

} 
// Output: “It’s equal to 100” 
In § 12.1 we will use a switch-statement to read input from the keyboard (see Listing 12.2 switch. 
go). In a 2nd form of the switch-statement no variable is required (this is in fact a switch true) and 
the cases can test different conditions. The first condition that is true is executed. This looks very 
much like if-else chaining, and offers a more readable syntax if there are many branches. 
111112 
Ivo Balbaert 
switch { 
case condition1: 
… 
case condition2: 
… 
default: 
… 
} 
For example: switch { 
case i < 0: 
f1() 
case i == 0: 
f2() 
case i > 0: 
f3() 
} 
Any type that supports the equality comparison operator, such as ints, strings or pointers, can be 
used in these conditions. 
Listing 5.5—switch2.go: 
package main 
import “fmt” 
func main() { 
var num1 int = 7 
switch { 
case num1 < 0: 
fmt.Println(“Number is negative”) 
case num1 > 0 && num1 < 10: 
fmt.Println(“Number is between 0 and 10”) 
default: 
fmt.Println(“Number is 10 or greater”) 
} 
} 
// Output: Number is between 0 and 10The Way to Go 
113 
As a 3rd form and like the if, a switch can also contain an initialization statement: 
switch initialization { 
case val1: 
… 
case val2: 
… 
default: 
… 
} 
This can blend nicely with case testing of conditions, like in: 
switch result := calculate(); { 
case result < 0: 
// … 
case result > 0: 
// … 
default: 
// 0 
} 
Or this snippet, where a and b are retrieved in the parallel initialization, and the cases are 
conditions: 
switch a, b := x[i], y[j]; { 
case a < b: t = -1 
case a == b: t = 0 
case a > b: t = 1 
} 
There is also a type-switch (see § 11.4) which tests the type of an interface variable. 
Question 5.1: Give the output of the following code snippet: 
k := 6 
switch k { 
case 4: fmt.Println(“was <= 4”); fallthrough; 
case 5: fmt.Println(“was <= 5”); fallthrough; 
case 6: fmt.Println(“was <= 6”); fallthrough; 

case 7: fmt.Println(“was <= 7”); fallthrough; 
case 8: fmt.Println(“was <= 8”); fallthrough; 
default: fmt.Println(“default case”) 
}114 
Ivo Balbaert 
Exercise 5.2—season.go: Write a function Season which has as input-parameter a month-number and 
which returns the name of the season to which this month belongs (disregard the day in the month). 
5.4—The for construct 
Only the for statement exists for repeating a set of statements a number of times; this is possible 
because it is more flexible than in other languages. One pass through the set is called an iteration. 
Remark: There is no for-match for the do while-statement found in most other languages, probably 
because the use case for it was not that important. 
5.4.1 Counter-controlled iteration 
The simplest form is counter-controlled iteration, like in for1.go: 
The general format is: for init; condition; modif { } 
Listing 5.6—for1.go: 
package main 
import “fmt” 
func main() { 
for i := 0; i < 5; i++ { 
fmt.Printf(“This is the %d iteration\n”, i) 
} 
} 
Output: This is the 0 iteration 
This is the 1 iteration 
This is the 2 iteration 
This is the 3 iteration 
This is the 4 iteration 
The body { } of the for-loop is repeated a known number of times, this is counted by a variable 
(here i). The loop starts (so this is performed only once) with an initialization for i (i := 0); this is 
shorter than a declaration beforehand. This is followed by a conditional check on i (i < 10), which 
is performed before every iteration: when it is true, the iteration is done, the for-loop stops when 
the condition becomes false. Then comes a modification of i (i++), which is performed after every 
iteration, at which point the condition is checked again to see if the loop can continue. This 
modification could for example also be a decrement, or + or—using a step.The Way to Go 
115 
These are 3 separate statements which form the header of the loop, so they are separated by ; but 
there are no ( ) surrounding the header: for (i = 0; i < 10; i++) { } is invalid code! 
Again the opening { has to be on the same line as the for. The counter-variable ceases to exist after 
the } of the for; always use short names for it like i, j, z or ix. 
!! Never change the counter-variable in the for-loop itself, this is bad practice in all languages !! 
Exercise 5.3: i undefined.go:
package main 
import “fmt” 
func main() { 
for i:=0; i<10; i++ { 
fmt.Printf(“%v\n”, i) 
} 
fmt.Printf(“%v\n”, i) //<-- compile error: undefined i 
} 
How could you make it work ? 
More than 1 counter can also be used, as in: for i, j := 0, N; i < j; i, j = i+1, j-1 {} 
which is often the preferred way in Go as we can use parallel assignment. 
(see the example of reversing an array and exercise string reverse.go in Chapter 7) 
For-loops can be nested, like: for i:=0; i<5; ji++ { 
for j:=0; j<10; j++ { 
println(j) 
} 
} 
What happens if we use this kind of for-loop for a general Unicode-string ? 
Listing 5.7—for string.go: 
package main 
import “fmt” 
func main() { 
str := “Go is a beautiful language!” 
fmt.Printf(“The length of str is: %d\n”, len(str))116 
Ivo Balbaert 
for ix :=0; ix < len(str); ix++ { 
fmt.Printf(“Character on position %d is: %c \n”, ix, str[ix]) 
} 
str2 := “日本語” 
fmt.Printf(“The length of str2 is: %d\n”, len(str2)) 
for ix :=0; ix < len(str2); ix++ { 

 this program does not compile, why not ? 

_

_

_

_

_

fmt.Printf(“Character on position %d is: %c \n”, ix, str2[ix]) 
} 
} 
/* Output: 
The length of str is: 27 
Character on position 0 is: G 
Character on position 1 is: o 
Character on position 2 is: 
Character on position 3 is: i 
… 
Character on position 25 is: e 
Character on position 26 is: ! 
The length of str2 is: 9 
Character on position 0 is: æ 
Character on position 1 is: — 
Character on position 2 is: 
Character on position 3 is: æ 
Character on position 4 is: 
 œ
Character on position 5 is: ¬ 
Character on position 6 is: è 
Character on position 7 is: ª 
Character on position 8 is:   
*/ 
If we print out the length len of strings str and str2, we get respectively 27 and 9. 
We see that for normal ASCII-characters using 1 byte, an indexed character is the full character, 
whereas for non-ASCII characters (who need 2 to 4 bytes) the indexed character is no longer 
correct! The for-range from § 5.4.4 will solve this problem.The Way to Go 
117 
EXERCISES: 
Exercise 5.4: for loop.go 
1. Create a simple loop with the for construct. Make it loop 15 times and print out the loop 
counter with the fmt package. 
2. Rewrite this loop using goto. The keyword for may not be used now. 
Exercise 5.5: for character.go 
Create a program that prints the following (up to 25 characters): 
G 
GG 
GGG 
GGGG 
GGGGG 
GGGGGG 
GGGGGGG 
... 
1. - use 2 nested for loops 
2. - use only one for loop and string concatenation 
Exercise 5.6: 
bitwise complement.go
_
use the bit-respresentation %b 
Exercise 5.7: TheFizz-Buzz problem: fizzbuzz.go 
Write a program that prints the numbers from 1 to 100, but for multiples of three 
print “Fizz” instead of the number and for the multiples of five print “Buzz”. For 
numbers which are multiples of both three and five print “FizzBuzz”. (hint: use a 
switch with conditions) 
Exercise 5.8: 
rectangle stars.go
_
character: 
5.4.2 Condition-controlled iteration 
The 2nd form contains no header and is used for condition-controlled iteration ( the while-loop in 
other languages ) with the general format: 
for condition { }118 
Ivo Balbaert 
You could also argue that it is a for without init and modif section, so that the ; ; are superfluous. 
Example: Listing 5.8—for2.go: 
package main 
import “fmt” 
func main() { 
var i int = 5 
for i >= 0 { 
i = i - 1 
fmt.Printf(“The variable i is now: %d\n”, i) 
} 

: Print out a rectangle of width=20 and height=10 with the * 

 : Show the bitwise complement of the integers 0 till 10, 

} 
Output: 
The variable i is now: 4 
The variable i is now: 3 
The variable i is now: 2 
The variable i is now: 1 
The variable i is now: 0 
The variable i is now: -1 
5.4.3 Infinite loops 
The condition can be absent: like in for i:=0; ; i++ or for { } (or for ;; { } but the ; ; is 
removed by gofmt): these are in fact infinite loops. The latter could also be written as: for true { }, 
but the normal format is: for { } 
If a condition check is missing in a for-header, the condition for looping is and remains always 
true, so in the loop-body something has to happen in order for the loop to be exited after a number 
of iterations. 
Always take care that the exit-condition will evaluate to true at a certain moment, in order to avoid 
an endless loop! This kind of loop is exited via a break statement (see § 5.5) or a return statement 
(see § 6.1). 
But there is a difference: break only exits from the loop, while return exits from the function in 
which the loop is coded! 
A typical use for an infinite loop is a server-function which is waiting for incoming requests.The Way to Go 
119 
For an example in which this all comes together, see the for loop in listing 12.17 (xml.go): 
for t, err = p.Token(); err == nil; t, err = p.Token() { 
… 
} 
5.4.4 The for range construct 
This is the iterator construct in Go and you will find it useful in a lot of contexts. It is a very useful 
and elegant variation, used to make a loop over every item in a collection (like arrays and maps, see 
chapters 7 and 8). It is similar to a foreach in other languages, but we still have the index at each 
iteration in the loop. The general format is: for ix, val := range coll { } 
Be careful: val is here a copy of the value at that index in the collection, so it can be used only for 
read-purposes, the real value in the collection cannot be modified through val (try this out!). A 
string is a collection of Unicode-characters (or runes), so it can be applied for strings too. If str is a 
string, you can loop over it with: 
for pos, char := range str { 
…
} 
Each rune char and its index pos are available for processing inside the loop. It breaks out individual 
Unicode characters by parsing the UTF-8 (erroneous encodings consume one byte and produce 
the replacement rune U+FFFD). 
See it in action in Listing 5.9—range string.go
package main 
import “fmt” 
func main() { 
str := “Go is a beautiful language!” 
for pos, char := range str { 
fmt.Printf(“Character on position %d is: %c \n”, pos, char) 
} 
fmt.Println() 
str2 := “Chinese: 日本語” 
for pos, char := range str2 { 
fmt.Printf(“character %c starts at byte position %d\n”, char, 
pos)120 
Ivo Balbaert 
} 
fmt.Println() 
fmt.Println(“index int(rune) rune char bytes”) 
for index, rune := range str2 { 
fmt.Printf(“%-2d %d %U ‘%c’ % X\n”, index, rune, rune, 
rune, []byte(string(rune))) 
} 
} 
Output: 
Character on position 0 is: G 
Character on position 1 is: o 
Character on position 2 is: 
Character on position 3 is: i 
… 
The length of str2 is: 18 
character C starts at byte position 0 
character h starts at byte position 1 

: 

_

_

character i starts at byte position 2 
character n starts at byte position 3 
character e starts at byte position 4 
character s starts at byte position 5 
character e starts at byte position 6 
character : starts at byte position 7 
character starts at byte position 8 
character 日 starts at byte position 9 
character 本 starts at byte position 12 
character 語 starts at byte position 15 
index int(rune) rune char bytes 
0 67 U+0043 ‘C’ 43 
1 104 U+0068 ‘h’ 68 
2 105 U+0069 ‘i’ 69 
3 110 U+006E ‘n’ 6E 
4 101 U+0065 ‘e’ 65 
5 115 U+0073 ‘s’ 73 
6 101 U+0065 ‘e’ 65 
7 58 U+003A ‘:’ 3A 
8 32 U+0020 ‘ ’ 20 
9 26085 U+65E5 ‘日’ E6 97 A5 
12 26412 U+672C ‘本’ E6 9C AC 
15 35486 U+8A9E ‘語’ E8 AA 9EThe Way to Go 
121 
Compare this with the output of Listing 5.7 (for string.go). 
We see that the normal English characters are represented by 1 byte, and these Chinese characters 
by 3 bytes. 
Exercise 5.9: What will this loop print out ? 
for i := 0; i < 5; i++ { 
var v int 
fmt.Printf(“%d “, v) 
v = 5 
} 
Question 5.2: Describe the output of the following valid for-loops: 
1) 
for i := 0; ; i++ { 
fmt.Println(“Value of i is now:”, i) 
} 
2) 
for i := 0; i < 3; { 
fmt.Println(“Value of i:”, i) 
} 
3) 
s := “” 
for ; s != “aaaaa”; { 
fmt.Println(“Value of s:”, s) 
s = s + “a” 
} 
4) 
for i, j, s := 0, 5, “a”; i < 3 && j < 100 && s != “aaaaa”; i, j, 
s = i+1, j+1, s + “a” { 
fmt.Println(“Value of i, j, s:”, i, j, s) 
} 
5.5—Break / continue 
Using break, the code of the for-loop in for2.go could then be rewritten (clearly less elegant) as: 
Listing 5.10—for3.go: 
for { 
i = i - 1 
fmt.Printf(“The variable i is now: %d\n”, i)122 
Ivo Balbaert 
if i < 0 { 
break 
} 
} 
So in every iteration a condition (here i < 0) has to be checked to see whether the loop should stop. 
If the exit-condition becomes true, the loop is left through the break statement. 
A break statement always breaks out of the innermost structure in which it occurs; it can be used 
in any kind of for-loop (counter, condition,etc.), but also in a switch, or a select-statement (see ch 
13). Execution is continued after the ending } of that structure. 
In the following example with a nested loop (for4.go) break exits the innermost loop: 
Listing 5.11—for4.go: 
package main 
func main() { 
for i:=0; i<3; i++ { 
for j:=0; j<10; j++ { 
if j>5 { 
break 

} 
print(j) 
} 
print(“ ”) 
} 
} 
// Output: 
012345 012345 012345 
The keyword continue skips the remaining part of the loop, but then continues with the next 
iteration of the loop after checking the condition, see for example Listing 5.12—for5.go: 
package main 
func main() { 
for i := 0; i < 10; i++ { 
if i == 5 { 
continue 
} 
print(i) 
print(“ ”)The Way to Go 
123 
} 
} 
Output: 0 1 2 3 4 6 7 8 9 
5 is skipped 
The keyword continue can only be used within a for-loop. 
5.6—Use of labels with break and continue—goto 
A code line which starts a for, switch, or select statement can be decorated with a label of the form 
identifier: 
The first word ending with a colon : and preceding the code (gofmt puts it on the preceding line) 
is a label, like LABEL1: in Listing 5.13—for6.go: 
( The name of a label is case-sensitive, it is put in uppercase by convention to increase readability. ) 
package main 
import “fmt” 
func main() { 
LABEL1: 
for i := 0; i <= 5; i++ { 
for j := 0; j <= 5; j++ { 
if j == 4 { 
continue LABEL1 
} 
fmt.Printf(“i is: %d, and j is: %d\n”, i, j) 
} 
} 
} 
Here continue points to LABEL1, the execution jumps to the label. 
You see that cases j == 4 and j == 5 do not appear in the output: the label precedes the outer loop, 
which starts i at its next value, causing the j in the inner for loop to reset to 0 at its initialization. 
In the same way break LABEL can be used, not only from a for-loop, but also to break out of a 
switch. There is even a goto keyword, which has to be followed by a label name; for example it can 
be used to simulate a loop as in Listing 5.14—goto.go:Ivo Balbaert 
package main 
func main() { 
i:=0 
HERE: 
print(i) 
i++ 
if i==5 { 
return 
} 
goto HERE 
} 
which prints 01234. 
But a backward goto quicky leads to unreadable ‘spaghetti’-code and should not be used, there is 
always a better alternative. 
!! The use of labels and certainly goto is discouraged: it can quickly lead to bad program design, the code 
can almost always be written more readable without using them. !! 
An example where the use of goto is acceptable is in program simple tcp server.go
_
:there goto is used to jump out of an infinite read-loop and close the connection with a client when 
a read-error occurs on that connection. 
Declaring a label and not using it is a compiler error (label … defined and not used) 
If you really have to use goto, use it only with forward labels (a label appearing in the code a 
number of lines after the goto), and do not declare any new variables between the goto and the 
label, because this can lead to errors and unexpected results, like in Listing 5.15—goto2.go (does 
not compile!) 

 from § 15.1 

_

func main() { 
a := 1 
goto TARGET // compile error: 
// goto TARGET jumps over declaration of b at goto2.go:8 
b := 9 
TARGET: 
b += a 
fmt.Printf(“a is %v *** b is %v”, a, b) 
} 
124The Way to Go 
125 
Output: 
a is 1 *** b is 4241844 
Question 5.3: Describe the output of the following valid for-loops: 
1)
i := 0 
for { //since there are no checks, this is an infinite loop 
if i >= 3 { break } 
//break out of this for loop when this condition is met 
fmt.Println(“Value of i is:”, i) 
i++; 
} 
fmt.Println(“A statement just after for loop.”) 
2)
for i := 0; i<7 ; i++ { 
if i%2 == 0 { continue } 
fmt.Println(“Odd:”, i) 
}Chapter 6—Functions 
Functions are the basic building blocks in Go code: they are very versatile so that even can be said 
that Go has a lot of characteristics of a functional language. In this chapter we elaborate on the 
elementary function-description in § 4.2.2 
6.1 Introduction 
Every program consist of a number of functions: it is the basic code block. 
Because Go code is compiled the order in which the functions are written in the program does not 
matter; however for readability it is better to start with main() and write the functions in a logical 
order (for example the calling order). 
Their main purpose is to break a large problem which requires many code lines into a number of 
smaller tasks (functions). Also the same task can be invoked several times, so a function promotes 
code reuse. 
( In fact a good program honors the DRY-principle, Don’t Repeat Yourself, meaning that the code 
which performs a certain task may only appear once in the program. ) 
In § 4.2 the main characteristics of functions were described, but now we have more material to 
build concrete and useful examples. 
A function ends when it has executed its last statement (before } ), or when it executes a return 
statement, which can be with or without argument(s); these arguments are the values that the 
functions returns from its computation (see § 6.2). A simple return can thus also be used to end an 
infinite for-loop, or to stop a goroutine. 
There are 3 types of functions in Go: 
• Normal functions with an identifier 
• Anonymous or lambda functions (see § 6.8) 
• Methods (see § 10.6) 
126The Way to Go 
127 
Any of these can have parameters and return values. The definition of all the function parameters 
and return values, together with their types, is called the function signature. 
And as a reminder, a syntax prerequisite: 
This is invalid Go-code: 
func g() 
{ 
// INVALID 
} 
It must be: 
func g() {
// VALID 
} 
A function is called or invoked in code, in a general format like: 
pack1.Function(arg1,arg2, . . . ,argn) 
where Function is a function in package pack1, and arg1, etc. are the arguments: the values which 
are passed into the parameters of the function (see § 6.2). When a function is invoked copies of the 

arguments are made and these are then passed to the called function. The invocation happens in 
the code of another function: the calling function. A function can call other functions as much as 
needed, and these in turn call other functions, and this can go on with theoretically no limit (or 
the stack upon which these function calls are placed is exhausted). 
Here is the simplest example of a function calling another function: 
Listing 6.1—greeting.go: 
package main 
func main() { 
println(“In main before calling greeting”) 
greeting() 
println(“In main after calling greeting”) 
} 
func greeting() { 
println(“In greeting: Hi!!!!!”) 
} 
Output: 
In main before calling greeting 
In greeting: Hi!!!!! 
In main after calling greeting128 
Ivo Balbaert 
A function call can have another function call as its argument, provided that this function has the 
same number and types of arguments in the correct order that the first function needs, e.g.: 
Suppose f1 needs 3 arguments f1(a, b, c int), and f2 returns 3 arguments: 
f2(a, b int) (int, int, int), then this can be a call to f1: f1(f2(a, b)) 
Function overloading, that is coding two or more functions in a program with the same function 
name but a different parameter list and/or a different return-type(s), is not allowed in Go. It gives 
the compiler error: 
funcName redeclared in this block, previous declaration at lineno 
The main reason is that overloading functions forces the runtime to do additional type matching 
which reduces performance; no overloading means only a simple function dispatch is needed. So 
you need to give your functions appropriate unique names, probably named according to their 
signature (but see also §11.12.5). 
To declarer a function implemented outside Go, such as an assembly routine, you simply give the 
name and signature, and no body: 
func flushICache(begin, end uintptr) // implemented externally 
Functions can also be used in the form of a declaration, as a function type, like in: 
type binOp func(int, int) int 
In that case also the body { } is omitted. 
Funtions are first-class values: they can be assigned to a variable, like in: 
add := binOp 
The variable add gets a reference (points) to the function and it knows the signature of the function 
it refers to, so it is not possible to assign to it a function with a different signature. 
Function values can be compared: they are equal if they refer to the same function or if both are 
nil. A function cannot be declared inside another function (no nesting), but this can be mimicked 
by using anonymous functions (see § 6.8). 
Go has until now no concept of generics, which means for example defining 1 function which 
can be applied to a number of variable types. However most cases can be solved simply by using The Way to Go 
interfaces, especially the empty interface and a type switch (see § 11.12 and for examples ex. 
11.10-11.12) and/or by using reflection (see § 11.10). Code complexity is increased using these 
techniques and performance lowered, so when performance is very important it is better and will 
produce more readable code to create the function explicitly for every type used. 
6.2 Parameters and return values 
A function can take parameters to use in its code, and it can return zero or more values (when 
more values are returned one often speaks of a tuple of values). This is also a great improvement 
compared to C, C++, Java and C#, and it is particularly handy when testing whether or not a 
function execution has resulted in an error (see § 5.2) 
Returning (a) value(s) is done with the keyword return . In fact every function that returns at least 
1 value must end with return or panic (see chapter 13). 
Code after return in the same block is not executed anymore. If return is used, then every code-path 
in the function must end with a return statement. 
Question 6.1: The following function does not compile, why not? Correct it. 
func (st *Stack) Pop() int { 
v := 0 
for ix:= len(st)-1; ix>=0; ix-- { 
if v=st[ix]; v!=0 { 
st[ix] = 0 
return v 
} 
} 

_

_

} 
Parameters normally have names, but a function can be defined in which no parameter has a name, 
only a type, like: func f(int, int, float64) 
A function with no parameters is called a niladic function, like main.main(). 
6.2.1 Call by value / Call by reference 
The default way in Go is to pass a variable as an argument to a function by value: a copy is made 
of that variable (and the data in it). The function works with and possibly changes the copy, the 
original value is not changed: Function(arg1). 
129130 
Ivo Balbaert 
If you want Function to be able to change the value of arg1 itself (‘in place’), you have to pass the 
memory address of that variable with &, this is call (pass) by reference: Function(&arg1); effectively 
a pointer is then passed to the function. If the variable that is passed is a pointer, then the pointer 
is copied, not the data that it points to; but through the pointer the function changes the original 
value. 
Passing a pointer (a 32bit or 64bit value) is in almost all cases cheaper than making a copy of the 
object. 
Reference types like slices (ch 7), maps (ch 8), interfaces (ch 10) and channels (ch 13) are pass by 
reference by default (even though the pointer is not directly visible in the code). 
Some functions just perform a task, and do not return values: they perform what is called a 
side-effect, like printing to the console, sending a mail, logging an error, etc. 
But most functions return values, which can be named or unnamed. 
In the program simple function.go the function takes 3 int parameters a,b and c and returns an int 
(the commented lines show more verbose alternative code, where a local variable is used): 
Listing 6.2—simple function.go: 
package main 
import “fmt” 
func main() { 
fmt.Printf(“Multiply 2 * 5 * 6 = %d\n”, MultiPly3Nums(2, 5, 6)) 
// var i1 int = MultiPly3Nums(2, 5, 6) 
// fmt.Printf(“Multiply 2 * 5 * 6 = %d\n”, i1) 
} 
func MultiPly3Nums(a int, b int, c int) int { 
// var product int = a * b * c 
// return product 
return a * b * c 
} 
Output: 
Multiply 2 * 5 * 6 = 60 
When it becomes necessary to return more than 4 or 5 values from a function, it is best to pass a 
slice (see chapter 7) is the values are of the same type (homogeneous), or to use a pointer to a struct The Way to Go 
131 
(see chapter 10) if they are of different type (heterogeneous). Passing a pointer like that is cheap 
and allows to modify the data in place. 
Question 6.2: 
What difference if any is there between the following function calls: 
(A) func DoSomething(a *A) { 
b = a 
} 
and: 
(B) func DoSomething(a A) { 
b = &a 
} 
6.2.2 Named return variables 
In the following program multiple return.go the function takes one int parameter and returns 2 
ints; the return values are filled in at the calling function in a parallel assignment. 
The two functions getX2AndX3 and getX2AndX3 2_  show how unnamed—or named return variables 
are used. When there is more than 1 unnamed return variable, they must be enclosed within (), 
like (int, int) 
Named variables used as result parameters are automatically initialized to their zero-value, and once 
they receive their value, a simple (empty) return statement is sufficient; furthermore even when 
there is only 1 named return variable, it has to be put inside ( ) (see § 6.6 fibonacci.go ). 
Listing 6.3—multiple return.go: 
package main 
import “fmt” 
var num int = 10 
var numx2, numx3 int 
func main() { 
numx2, numx3 = getX2AndX3(num) 
PrintValues() 
numx2, numx3 = getX2AndX3 2(num) 

_

_

_

_

_

_

PrintValues()132 
Ivo Balbaert 
} 
func PrintValues() { 
fmt.Printf(“num = %d, 2x num = %d, 3x num = %d\n”, num, numx2, numx3) 
} 
func getX2AndX3(input int) (int, int) { 
return 2 * input, 3 * input 
} 
func getX2AndX3 2(input int) (x2 int, x3 int) { 
x2 = 2 * input 
x3 = 3 * input 
// return x2, x3 
return 
} 
Output: 
num = 10, 2x num = 20, 3x num = 30 
num = 10, 2x num = 20, 3x num = 30 
Caution: 
return or return var is ok, 
but 
return var = expression 
gives a compiler error: 
syntax error: unexpected =, expecting semicolon or newline or } 
Even with named return variables you can still ignore the names and return explicit values. 
When any of the result variables has been shadowed (not a good practice!) the return-statement 
must contain the result variable names. 
!! Use named return variables: they make the code clearer, shorter and self-documenting !! 
Exercise 6.1: mult returnval.go 
Write a function which accepts 2 integers and returns their sum, product and difference. Make a 
version with unnamed return variables, and a 2nd version with named return variables. 
Exercise 6.2: error returnval.go 
Write a function MySqrt which calculates the square root of a float64, but returns an error if this 
number is negative; make a version with unnamed and a second one with named return variables.The Way to Go 
133 
6.2.3 Blank identifier 
The blank identifier   can be used to discard values, effectively assigning the right-hand-side value 
_
to nothing, as in blank identifier.go. 
_
The function ThreeValues has no parameters and 3 return-values, where only the first and the third 
return value are captured in i1 and f1. 
Listing 6.4—blank identifier.go: 
_
package main 
import “fmt” 
func main() { 
var i1 int 
var f1 float32 
i1,  , f1 = ThreeValues() 
fmt.Printf(“The int: %d, the float; %f\n”, i1, f1) 
} 
func ThreeValues() (int, int, float32) { 
return 5, 6, 7.5 
} 
Output: The int: 5, the float; 7.500000 
Another illustration of a function with 2 parameters and 2 return-values which calculates the 
minimum and maximum value of the 2 parameters is presented in minmax.go. 
Listing 6.5—minmax.go: 
package main 
import “fmt” 
func main() { 
var min, max int 
min, max = MinMax(78, 65) 
fmt.Printf(“Minimum is: %d, Maximum is: %d\n”, min, max) 
} 
func MinMax(a int, b int) (min int, max int) { 
if a < b {134 
Ivo Balbaert 
min = a 
max = b 
} else { // a = b or a < b 
min = b 
max = a 
} 
return 
} 
// Output: 
Minimum is: 65, Maximum is: 78 

_

_

 construct of § 5.4.4. 

6.2.4 Changing an outside variable 
Passing a pointer to a function not only conserves memory because no copy of the value is made. 
It has also as side-effect that the variable or object can be changed inside the function, so that the 
changed object doesn’t have to be returned back from the function. See this in the following little 
program, where reply, a pointer to an integer, is being changed in the function itself. 
Listing 6.6—side effect.go: 
package main 
import ( 
“fmt” 
) 
// this function changes reply: 
func Multiply(a, b int, reply *int) { 
*reply = a * b 
} 
func main() { 
n := 0 
reply := &n 
Multiply(10, 5, reply) 
fmt.Println(“Multiply:”, *reply) // Multiply: 50 
} 
This is only a didactic example, but it is much more useful to change a large object inside a 
function. However this technique obscures a bit what is going on, the programmer should be very 
much aware of this side-effect, and if necessary make it clear to users of the function through a 
comment.The Way to Go 
135 
6.3 Passing a variable number of parameters 
If the last parameter of a function is followed by …type, this indicates that the function can deal 
with a variable number of parameters of that type, possibly also 0: a so called variadic function: 
func myFunc(a, b, arg ...int) {} 
The function receives in effect a slice of the type (see chapter 7), which can be looped through with 
the for  , v := range
_
Given the function and call: 
func Greeting(prefix string, who ...string) 
Greeting(“hello:”, “Joe”, “Anna”, “Eileen”) 
within Greeting, who will have the value []string{“Joe”, “Anna”, “Eileen”} 
If the parameters are stored in an array arr, the function can be called with the parameter arr… 
This is demonstrated in Listing 6.7—varnumpar.go: 
package main 
import “fmt” 
func main() { 
x := Min(1, 3, 2, 0) 
fmt.Printf(“The minimum is: %d\n”, x) 
arr := []int{7,9,3,5,1} 
x = Min(arr...) 
fmt.Printf(“The minimum in the array arr is: %d”, x) 
} 
func Min(a ...int) int { 
if len(a)==0 { 
return 0 
} 
min := a[0] 
for  , v := range a { 
_
if v < min { 
min = v 
} 
} 
return min 
}136 
Ivo Balbaert 
Output: 
The minimum is: 0 
The minimum in the array arr is: 1 
Exercise 6.3: varargs.go 
Make a function that has as arguments a variable number of ints and which prints 
each integer on a separate line. 
A function with a variadic parameter can give this parameter to other functions, like in the following 
code snippet: 
function F1(s … string) { 
F2(s …) 
F3(s) 
} 
func F2(s … string) { } 
func F3(s []string) { } 
The variable number parameter can be passed as such or as a slice of its type. 

_

But what if the variable parameters are not of the same type? To have to write say 5 parameters of 
different type is not elegant. There are 2 possible solutions: 
Use a struct: 
(see chapter 10) 
Define a struct type, say Options, which gathers all possible parameters: 
type Options struct { 
par1 type1, 
par2 type2, 
... 
} 
A function F1 can then be called with its normal parameters a and b and with no optional parameters 
as: 
F1(a, b, Options {}) 
If one or more of the optional parameters have values, call F1 as: 
F1(a, b, Options {par1:val1, par2:val2})The Way to Go 
137 
Use of the empty interface: 
If in a variadic parameter the type is not specified, it defaults to the empty interface { } 
which can stand for any other type (see § 11.9). This could also be used if not only the number 
of parameters is unknown, but also their type is not specified (perhaps they are each of a different 
type. The function which receives this parameter can then do a for-range loop over the values, and 
process them in a type-switch like so: 
func typecheck(..,..,values … interface{}) { 
for  , value := range values { 
switch v := value.(type) { 
case int: … 
case float: … 
case string: … 
case bool: … 
default: … 
} 
} 
} 
6.4 Defer and tracing 
The defer keyword allows us to postpone the execution of a statement or a function until the end 
of the enclosing (calling) function: it executes something (a function or an expression) when the 
enclosing function returns (after every return and even when an error occurred in the midst of 
executing the function, not only a return at the end of the function), but before the } (Why after? 
Because the return statement itself can be an expression which does something instead of only 
giving back 1 or more variables). 
defer resembles the finally-block in OO-languages as Java and C#; in most cases it also serves to 
free up allocated resources. 
This is illustrated in Listing 6.8—defer.go : 
package main 
import “fmt” 
func main() { 
Function1() 
}138 
Ivo Balbaert 
func Function1() { 
fmt.Printf(“In Function1 at the top\n”) 
defer Function2() 
fmt.Printf(“In Function1 at the bottom!\n”) 
} 
func Function2() { 
fmt.Printf(“Function2: Deferred until the end of the calling function!”) 
} 
Output: 
In Function1 at the top 
In Function1 at the bottom! 
Function2: Deferred until the end of the calling function! 
(compare the output when defer is removed) 
If the defer has arguments they are evaluated at the line of the defer-statement; this is illustrated in 
the following snippet, where the defer will print 0: 
func a() { 
i := 0 
defer fmt.Println(i) 
i++ 
return 
} 
When many defer’s are issued in the code, they are executed at the end of the function in the 
inverse order (like a stack or LIFO): the last defer is first executed, and so on. 

_

This is illustrated in the following contrived snippet: 
func f() { 
for i := 0; i < 5; i++ { 
defer fmt.Printf(“%d “, i) 
} 
} 
Which prints out: 4 3 2 1 0 
defer allows us to guarantee that certain clean-up tasks are performed before we return from a 
function, for example:The Way to Go 
139 
1) closing a file stream: 
// open a file 
defer file.Close() (see § 12.2) 
2) unlocking a locked resource (a mutex): 
mu.Lock() 
defer mu.Unlock() (see § 9.3) 
3) printing a footer in a report: 
printHeader() 
defer printFooter() 
4) closing a database connection: 
// open a database connection 
defer disconnectFromDB() 
It can be helpful to keep the code cleaner and so often shorter. 
The following listing simulates case 4): 
Listing 6.9—defer dbconn.go : 
package main 
import “fmt” 
func main() { 
doDBOperations() 
} 
func connectToDB () { 
fmt.Println( “ok, connected to db” ) 
} 
func disconnectFromDB () { 
fmt.Println( “ok, disconnected from db” ) 
} 
func doDBOperations() { 
connectToDB() 
fmt.Println(“Defering the database disconnect.”) 
defer disconnectFromDB() //function called here with defer140 
Ivo Balbaert 
fmt.Println(“Doing some DB operations ...”) 
fmt.Println(“Oops! some crash or network error ...”) 
fmt.Println(“Returning from function here!”) 
return //terminate the program 
// deferred function executed here just before actually returning, even if 
there is a return or abnormal termination before 
} 
/* Output: 
ok, connected to db 
Defering the database disconnect. 
Doing some DB operations ... 
Oops! some crash or network error ... 
Returning from function here! 
ok, disconnected from db 
*/ 
Tracing with defer: 
A primitive but sometimes effective way of tracing the execution of a program is printing a message 
when entering and leaving certain functions. This can be done with the following 2 functions: 
func trace(s string) { fmt.Println(“entering:”, s) } 
func untrace(s string) { fmt.Println(“leaving:”, s) } 
where we will call untraced with the defer keyword, as in the following program 
Listing 6.10— defer tracing.go: 
_
package main 
import “fmt” 
func trace(s string) { fmt.Println(“entering:”, s) } 
func untrace(s string) { fmt.Println(“leaving:”, s) } 
func a() { 
trace(“a”) 
defer untrace(“a”) 
fmt.Println(“in a”) 
}The Way to Go 
141 
func b() { 
trace(“b”) 
defer untrace(“b”) 
fmt.Println(“in b”) 
a() 

_

_

} 
func main() { 
b() 
} 
which outputs: 
entering: b 
in b 
entering: a 
win a 
leaving: a 
leaving: b 
This can be done more succinctly: 
as in Listing 6.11— defer tracing2.go: 
_
package main 
import “fmt” 
func trace(s string) string { 
fmt.Println(“entering:”, s) 
return s 
} 
func un(s string) { 
fmt.Println(“leaving:”, s) 
} 
func a() { 
defer un(trace(“a”)) 
fmt.Println(“in a”) 
} 
func b() { 
defer un(trace(“b”)) 
fmt.Println(“in b”) 
a() 
} 
func main() { 
b() 
}142 
Ivo Balbaert 
Using defer to log parameter- and return values from within the function: 
This is another possible use of defer which might come in handy while debugging: 
Listing 6.12— defer logvalues.go: 
_
package main 
import ( 
“log” 
“io” 
) 
func func1(s string) (n int, err error) { 
defer func() { 
log.Printf(“func1(%q) = %d, %v”, s, n, err) 
}() 
return 7, io.EOF 
} 
func main() { 
func1(“Go”) 
} 
// Output: 2011/10/04 10:46:11 func1(“Go”) = 7, EOF 
6.5 Built-in functions 
These are predefined functions which can be used as such, without having to import a package to 
get access to them. They sometimes apply to different types, e.g. len, cap and append, or they have 
to operate near system level like panic. That’s why they need support from the compiler. 
Here is a list, they will be further discussed in the following chapters. 
close 
Used in channel communication 
len 
cap 
len gives the length of a number of types (strings, arrays, slices, maps, 
channels); cap is the capacity, the maximum storage (only applicable to 
slices and maps) 
new 
make 
Both new and make are used for allocating memory: 
new for value types and user-defined types like structs, 
make for built-in reference types (slices, maps, channels)The Way to Go 
143 
They are used like functions with the type as its argument: new(type), 
make(type) 

_

new(T) allocates zeroed storage for a new item of type T and returns 
its address, so it returns a pointer to the type T (see also § 10.1: Using 
new) 
It can be used with primitive types as well: 
v := new(int) // v has type *int 
make(T) returns an initialized variable of type T, so it does more work 
than new (see also §7.2.3/4, §8.1.1. and § 14.2.1) 
!! new( ) is a function, don’t forget its parentheses !! 
copy 
append 
used resp. for copying and concatenating slices (see § 7.5.5) 
panic 
recover 
both are used in a mechanism for handling errors (see § 13.2) 
print 
println 
low level printing functions (see § 4.2), use the fmt package in production 
programs 
complex 
real imag used for making and manipulating complex numbers (see § 4.5.2.2) 
6.6 Recursive functions 
A function that call itself in its body is called recursive. The proverbial example is the calculation 
of the numbers of the Fibonacci sequence, in which each number is the sum of its two preceding 
numbers. 
The sequence starts with: 
1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 
10946, … 
This is done in the following program: 
Listing 6.13—  fibonacci.go: 
_
package main 
import “fmt” 
func main() { 
result := 0144 
Ivo Balbaert 
for i:=0; i <= 10; i++ { 
result = fibonacci(i) 
fmt.Printf(“fibonacci(%d) is: %d\n”, i, result) 
} 
} 
func fibonacci(n int) (res int) { 
if n <= 1 { 
res = 1 
} else { 
res = fibonacci(n-1) + fibonacci(n-2) 
} 
return 
} 
Output: fibonacci(0) is: 1 
fibonacci(1) is: 1 
fibonacci(2) is: 2 
fibonacci(3) is: 3 
fibonacci(4) is: 5 
fibonacci(5) is: 8 
fibonacci(6) is: 13 
fibonacci(7) is: 21 
fibonacci(8) is: 34 
fibonacci(9) is: 55 
fibonacci(10) is: 89 
Many problems have an elegant recursive solution, like the famous Quicksort algorithm. 
An important problem when using recursive functions is stack overflow: this can occur when a large 
number of recursive calls are needed and the programs runs out of allocated stack memory. This 
can be solved by using a technique called lazy evaluation, implemented in Go with a channel and 
a goroutine (see § 14.8). Exercise 14.12 solves the Fibonacci problem in this way. 
Mutually recursive functions can also be used in Go: these are functions that call one another. 
Because of the Go compilation process, these functions may be declared in any order. Here is a 
simple example: even calls odd, and odd calls even. 
Listing 6.14—  mut recurs.go: 
package mainThe Way to Go 
145 
import ( 
“fmt” 
) 

_

_

_

func main() { 
fmt.Printf(“%d is even: is %t\n”, 16, even(16)) // 16 is even: is true 
fmt.Printf(“%d is odd: is %t\n”, 17, odd(17)) 
// 17 is odd: is true 
fmt.Printf(“%d is odd: is %t\n”, 18, odd(18)) 
// 18 is odd: is false 
} 
func even(nr int) bool { 
if nr == 0 {return true} 
return odd(RevSign(nr)-1) 
} 
func odd(nr int) bool { 
if nr == 0 {return false} 
return even(RevSign(nr)-1) 
} 
func RevSign(nr int) int { 
if nr < 0 {return -nr} 
return nr 
} 
EXERCISES: 
Exercise 6.4: fibonacci2.go 
Rewrite the Fibonacci program above to return 2 named variables (see § 6.2), 
namely the value and the position of the Fibonacci-number, like 5 and 4 or 89 
and 10. 
Exercise 6.5: 10to1 recursive.go 
Print the numbers from 10 to 1 in that order using a recursive function printrec(i 
int) 
Exercise 6.6: factorial.go 
Write a program which prints the factorial (!) of the first 30 integers146 
Ivo Balbaert 
The factorial n! of a number n is defined as:
n! = n * (n-1)!, 0!=1 
So this clearly a good candidate for a recursive function Factorial. 
Make a 2nd version of Factorial with a named return variable. 
Remark that when using type int the calculation is only correct up until 12!, this 
is of course because an int can only contain integers which fit in 32 bit. Go doesn’t 
warn against this overflow-error! How can you gset more correct results ? 
The best solution is to use the big package (see § 9.4). 
6.7 Functions as parameters 
Functions can be used as parameters in another function, the passed function can then be called 
within the body of that function, that is why it is commonly called a callback. To illustrate here is 
a simple example: 
Listing 6.15—  function parameter.go: 
_
_
package main 
import ( 
“fmt” 
) 
func main() { 
callback(1, Add) 
} 
func Add(a,b int) { 
fmt.Printf(“The sum of %d and %d is: %d\n”, a, b, a + b) 
} 
func callback(y int, f func(int, int)) { 
f(y, 2) // this becomes Add(1, 2) 
} 
// Output: The sum of 1 and 2 is: 3 
A good example of the use of a function as a parameter is the strings.IndexFunc() function:The Way to Go 
147 
It has the signature func IndexFunc(s string, f func(c int) bool) int and returns the index 
into s of the first Unicode character for which f(c) is true, or -1 if none do. 
For example strings.IndexFunc(line, unicode.IsSpace) will return the index of the 1st whitespace 
character in line. Of course you can make your own function f, e.g.: 
func IsAscii(c int) bool { 
if c > 255 { 
return false 
} 
return true 
} 
In § 14.10.1 we will also discuss an example of a function which has another function as a parameter, 
in the context of writing a client-server program: 
type binOp func(a, b int) int 
func run(op binOp, req *Request) { … } 

_

_

_

) 

Exercise 6.7: strings map.go 
The Map function in the package strings is also a good example of the use of higher order functions, 
like strings.IndexFunc(). Look up its definition in the package documentation and make a little 
test program with a map function that replaces all non-ASCII characters from a string with a ? or 
a space. What do you have to do to delete these characters? 
6.8 Closures (function literals) 
Sometimes we do not want to give a function a name, then we make an anonymous function (also 
known under the names of a lambda function, a function literal, or a closure), for example: func(x, 
y int) int { return x + y } 
Such a function cannot stand on its own (the compiler gives the error: non-declaration statement 
outside function body) but it can be assigned to a variable which is a reference to that function: 
fplus := func(x, y int) int { return x + y } 
and then invoked as if fplus was the name of the function: 
fplus(3,4) 
or it can be invoked directly: func(x, y int) int { return x + y } (3, 4)148 
Ivo Balbaert 
Here is a call to a lambda function which calculates the sum of integer floats till 1 million, gofmt 
reformats a lambda function in this way: 
func() { 
sum = 0.0 
for i := 1; i<= 1e6; i++ { 
sum += i 
} 
}() 
The first ( ) is the parameter-list and follows immediately after the keyword func because there is 
no function-name. The { } comprise the function body, and the last pair of ( ) represent the call of 
the function. 
Here is an example of assigning it to a variable, g in the following snippet (function literal.go
which is then of type function: 
Listing 6.16—  function literal.go: 
_
package main 
import “fmt” 
func main() { 
f() 
} 
func f() { 
for i := 0; i < 4; i++ { 
g := func(i int) { fmt.Printf(“%d “, i) } 
g(i) 
fmt.Printf(“ - g is of type %T and has value %v\n”, g, g) 
} 
} 
Output: 0 - g is of type func(int) and has value 0x681a80 
1 - g is of type func(int) and has value 0x681b00 
2 - g is of type func(int) and has value 0x681ac0 
3 - g is of type func(int) and has value 0x681400 
We see that the type of g is func(int), its value is a memory address. 
So in this assignment we have in fact a variable with a function value: lambda functions can be 
assigned to variables and treated as values.The Way to Go 
Exercise 6.8: Write a program which in main() defines a lambda function which prints “Hello 
World”. Assign it to a variable fv, call the function with as that value, and check 
the type of fv (lambda value.go
Anonymous functions like all functions can be with- or without parameters; in the following 
example there is a value v passed in the parameter u: 
func (u string) { 
fmt.Println(u) 
… 
}(v) 
Consider this contrived example: what is the value of ret after return from f ? 
Listing 6.17—  return defer.go: 
_
package main 
import “fmt” 
func f() (ret int) { 
defer func() { 
ret++ 
}() 
return 1 
} 
func main() { 
fmt.Println(f()) 
} 
The value is 2, because of the ret++, which is executed after return 1. 

) 

_

_

_

_

 we see functions Add2 and Adder which return another lambda 

This can be convenient for modifying the error return value of a function. 
defer and lambda functions: 
The defer keyword (§ 6.4) is often used with a lambda function. It can then also change return 
values, provided that you are using named result parameters. 
Lambda functions can also be launched as a goroutine with go (see chapter 14 and § 16.9). 
149150 
Ivo Balbaert 
Lambda functions are also called closures (a term from the theory of functional languages): they 
may refer to variables defined in a surrounding function. A closure is a function that captures 
some external state—for example, the state of the function in which it is created. Another way 
to formulate this is: a closure inherits the scope of the function in which it is declared. That state 
(those variables) is then shared between the surrounding function and the closure, and the variables 
survive as long as they are accessible; see the following examples in §6.9. Closures are often used 
as wrapper functions: they predefine 1 or more of the arguments for the wrapped function; this is 
also illustrated in the following § and in many examples to come.Another good application is using 
closures in performing clean error-checking (see § 16.10.2) 
6.9 Applying closures: a function returning another function 
In program function return.go
function func(b int) int: 
func Add2() (func(b int) int) 
func Adder(a int) (func(b int) int) 
Add2 takes no parameters, but Adder takes an int as parameter. 
We can make special cases of Adder and give them a name, like TwoAdder in listing 6.13. 
Listing 6.18—  function return.go: 
_
package main 
import “fmt” 
func main() { 
// make an Add2 function, give it a name p2, and call it: 
p2 := Add2() 
fmt.Printf(“Call Add2 for 3 gives: %v\n”, p2(3)) 
// make a special Adder function, a gets value 3: 
TwoAdder := Adder(2) 
fmt.Printf(“The result is: %v\n”, TwoAdder(3)) 
} 
func Add32() (func(b int) int) { 
return func(b int) int { 
return b + 2 
} 
}The Way to Go 
151 
func Adder(a int) (func(b int) int) { 
return func(b int) int { 
return a + b 
} 
} 
/* Output: 
Call Add2 for 3 gives: 5 
The result is: 5 
*/ 
Here is (nearly) the same function used in a slightly different way: 
Listing 6.19—  function closure.go: 
_
package main 
import “fmt” 
func main() { 
var f = Adder() 
fmt.Print(f(1),” - “) 
fmt.Print(f(20),” - “) 
fmt.Print(f(300)) 
} 
func Adder() func(int) int { 
var x int 
return func(delta int) int { 
x += delta 
return x 
} 
} 
Adder() is now assigned to the variable f (which is then of type func(int) int) 
The output is: 1 - 21 - 321 
In the calls to f, delta in Adder() gets respectively the values 1, 20 and 300.152 
Ivo Balbaert 
We see that between calls of f the value of x is retained, first it is 0 + 1 = 1, then it becomes 1 + 20 
= 21, then 21 is added to 300 to give the result 321: the lambda function stores and accumulates 
the values of its variables: it still has access to the (local) variables defined in the current function. 
These local variables can also be parameters, like Adder(a int) in listing 6.13. 

_

_

) 

This demonstrates clearly that Go literal functions are closures. 
The variables that the lambda function uses or updates can also be declared outside of the lambda, 
like in this snippet: 
var g int 
go func(i int) { 
s := 0 
for j := 0; j < i; j++ { s += j } 
g = s 
}(1000) // Passes argument 1000 to the function literal. 
The lambda function can be applied to all elements of a collection, updating these variables. 
Afterwards these variables can be used to represent or calculate global values or averages. 
Exercise 6.9: Write a non-recursive version of the Fibonacci program from § 6.6 using a function 
as a closure: (fibonacci closure.go
Exercise 6.10: Study and comprehend the working of the following program: (compose.go) 
A function returning another function can be used as a factory function. This can be useful when 
you have to create a number of similar functions: write 1 factory function instead of writing them 
all individually. The following function illustrates this: it returns functions that add a suffix to a 
filename when this is not yet present: 
func MakeAddSuffix(suffix string) func(string) string { 
return func(name string) string { 
if !strings.HasSuffix(name, suffix) { 
return name + suffix 
} 
return name 
} 
} 
Now we can make functions like: 
addBmp := MakeAddSuffix(“.bmp”) 
addJpeg := MakeAddSuffix(“.jpeg”) 
and call them as: 
addBmp(“file”) 
// returns: file.bmp 
addJpeg(“file”) // returns: file.jpegThe Way to Go 
A function which can return another function and a function which has another function as a 
parameter are called higher order functions, which is a hallmark of the category of languages called 
functional languages. We have seen in §6.7 that functions are also values, so it is clear that Go possesses 
some of the major characteristics of a functional language. Closures are used frequently in Go, often 
in combination with goroutines and channels (see chapter 14 §14.8-9). In §11.14 program cars.go 
we see the power of functions in Go in action in an example with concrete objects. 
6.10 Debugging with closures 
When analyzing and debugging complex programs with myriads of functions in different code-files 
calling one another, it can often be useful to know at certain points in the program the file which is 
executing and the line number in it. This can be done by using special functions from the packages 
runtime or log. In package runtime the function Caller() provides this information, so a closure 
where() could be defined which calls this, and then be invoked wherever it is needed: 
where := func() { 
, file, line,   := runtime.Caller(1) 
_
log.Printf(“%s:%d”, file, line) 
} 
where() 
// some code 
where() 
// some more code 
where() 
The same can be achieved by setting a flag in the log package: 
log.SetFlags(log.Llongfile) 
log.Print(“”) 
or if you like the brevity of “where”: 
var where = log.Print 
func func1() { 
where() 
... some code 
where() 
... some code 
where() 
} 
153Ivo Balbaert 
6.11 Timing a function 
Sometimes it is interesting to know how long a certain computation took, e.g. for comparing and 
benchmarking calculations. A simple way is to record the start-time before the calculation, and 
the end-time after the calculation by using the function Now() from the time package; and the 
difference between them can then be calculated with Sub(). In code, this goes like: 

_

_

_

start := time.Now() 
longCalculation() 
end := time.Now() 
delta := end.Sub(start) 
fmt.Printf(“longCalculation took this amount of time: %s\n”, delta) 
See it in action in the program Listing 6.20—fibonacci.go. 
If you have optimized a piece of code always time the former version and the optimized version to 
see that there is a significant (enough) advantage; in the following § we see an optimization applied 
which is certainly worthwhile. 
6.12 Using memoization for performance 
When doing heavy computations one thing that can be done for increasing performance is not 
to repeat any calculation that has already been done and that must be reused. Instead cache the 
calculated value in memory, which is called memoization. A great example of this is the Fibonacci 
program (see § 6.6 and 6.11): 
to calculate the n-th Fibonacci number, you need the 2 preceding ones, which normally have 
already been calculated. If you do not stock the preceding results, every higher Fibonacci number 
results in an ever greater avalanche of recalculations, which is precisely what the version from 
listing 6.11 (fibonnaci.go) does. 
Simple stock the n-th Fibonacci number in an array at index n (see chapter 7), and before calculating 
a fibonnaci-number, first look in the array if it has not yet been calculated. 
This principle is applied in Listing 6.17 (fibonacci memoization.go). The performance gain is 
astounding, time both programs for the calculation up to the 40th Fibonnaci number: 
normal (fibonacci.go): the calculation took this amount of time: 4.730270 s 
with memoization: the calculation took this amount of time: 0.001000 s 
154The Way to Go 
155 
In this algorithm memoization is obvious, but it can often be applied in other computations as 
well, perhaps using maps (see chapter 7) instead of arrays or slices. 
Listing 6.21—  fibonacci memoization.go: 
_
package main 
import ( 
“fmt” 
“time” 
) 
const LIM = 41 
var fibs [LIM]uint64 
func main() { 
var result uint64 = 0 
start := time.Now() 
for i:=0; i < LIM; i++ { 
result = fibonacci(i) 
fmt.Printf(“fibonacci(%d) is: %d\n”, i, result) 
} 
end := time.Now() 
delta := end.Sub(start) 
fmt.Printf(“longCalculation took this amount of time: %s\n”, delta) 
} 
func fibonacci(n int) (res uint64) { 
// memoization: check if fibonacci(n) is already known in array: 
if fibs[n] != 0 { 
res = fibs[n] 
return 
} 
if n <= 1 { 
res = 1 
} else { 
res = fibonacci(n-1) + fibonacci(n-2) 
} 
fibs[n] = res 
return 
}Ivo Balbaert 
Memoization is useful for relatively expensive functions (not necessarily recursive as in the example) 
that are called lots of times with the same arguments. It can also only be applied to pure functions, 
these are functions that always produce the same result with the same arguments, and have no 
side-effects. 
156157 
Chapter 7—Arrays and Slices 
In this chapter we start with examining data-structures that contain a number of items, so called 
collections, such as arrays (slices) and maps. Here the Python influence is obvious. 
The array-type, indicated by the [ ], notation is well-known in almost every programming 
language as the basic workhorse in applications. The Go array is very much the same, but has a few 

peculiarities. It is not as dynamic as in C, but for that Go has the slice type. This is an abstraction 
built on top of Go’s array type, and so to understand slices we must first understand arrays. Arrays 
have their place, but they are a bit inflexible, so you don’t see them too often in Go code. Slices, 
though, are everywhere. They build on arrays to provide great power and convenience. 
7.1 Declaration and initialization 
7.1.1 Concept 
An array is a numbered and fixed-length sequence of data items (elements) of the same single type 
(it is a homogeneous data structure); this type can be anything from primitive types like integers, 
strings to self-defined types. The length must be a constant expression, that must evaluate to a 
non-negative integer value. It is part of the type of the array, so arrays declared as [5]int and [10] 
int differ in type. Initialization of an array with values known at compile time is done with array 
literals (see below). 
Remark:
If we would like the item type can be any type by using the empty interface as type 
(see § 11.9). When using the values we would first have to do a type assertion (see § 11.3). 
The items can be accessed (and changed) through their index (the position), the index starts from 
0, so the 1st element has index 0, the 2nd index 1, etc. (arrays are zero-based as usual in the C-family 
of languages). The number of items, also called the length len or size of the array, is fixed and must 
be given when declaring the array (len has to be determined at compile time in order to allocate 
the memory); the maximum array length is 2 Gb. 
The format of the declaration is: 
var identifier [len]type158 
Ivo Balbaert 
For example: var arr1 [5]int 
which can be visualized in memory as: 
arr1 
index 0 1 2 3 4 
Fig 7.1: Array in memory 
Each compartment contains an integer; when declaring an array, each item in it is automatically 
initialized with the default zero-value of the type, here all items default to 0. 
The length of arr1 len(arr1) is 5, and the index ranges from 0 to len(arr1)-1. 
The first element is given by arr1[0], the 3rd element is given by arr1[2] ; in general the element 
at index i is given by arr1[i]. The last element is given by:
arr1[len(arr1)-1] 
Assigning a value to an array-item at index i is done by: arr[i] = value, so arrays are mutable. 
Only valid indexes can be be used. When using an index equal to or greater than len(arr1): if the 
compiler can detect this, the message index out of bounds is given; but otherwise the code compiles 
just fine and executing the program will give the panic (see chapter 13): 
runtime error: index out of range. 
Because of the index, a natural way to loop over an array is to use the for-construct: 
• for initializing the items of the array 
• for printing the values, or in general: 
• for procession each item in succession. 
A basic example is given in Listing 7.1—for arrays.go: 
package main 
import “fmt” 
func main() { 
var arr1 [5]int 
for i:=0; i < len(arr1); i++ {The Way to Go 
159 
arr1[i] = i * 2 
} 
for i:=0; i < len(arr1); i++ { 
fmt.Printf(“Array at index %d is %d\n”, i, arr1[i]) 
} 
} 
Output: Array at index 0 is 0 
Array at index 1 is 2 
Array at index 2 is 4 
Array at index 3 is 6 
Array at index 4 is 8 
Very important here is the condition in the for-loop: i < len(arr1) 
i <= len(arr1) would give an index out of range-error. 
IDIOM: 
for i:=0; i < len(arr1); i++ { 
arr1[i]= … 
} 
The for-range construct is also useful: 

_

_

IDIOM: 
for i:= range arr1 { 
… 
} 
Here i is also the index in the array. Both for-constructs also work for slices (§ 7.2) of course. 
Question 7.1: What is the output of the following code snippet? 
a := [...]string{“a”, “b”, “c”, “d”} 
for i := range a { 
fmt.Println(“Array item”, i, “is”, a[i]) 
} 
An array in Go is a value type (not a pointer to the first element like in C/C++), so it can be created 
with new():160 
Ivo Balbaert 
var arr1 = new([5]int) 
What is the difference with: var arr2 [5]int ? arr1 is of type *[5]int, arr2 is of type [5]int . 
The consequence is that when assigning an array to another, a distinct copy in memory of the array 
is made. For example when: 
arr2 := arr1 
arr2[2] = 100 
then the arrays have different values; changing arr2 after the assignment does not change arr1. 
So when an array is passed as an argument to a function like in func1(arr1), a copy of the array is 
made, and func1 cannot change the original array arr1. 
If you want this to be possible or you want a more efficient solution, then arr1 must be passed by 
reference with the &-operator, as in func1(&arr1), like in the following example 
Listing 7.2—pointer array.go: 
package main 
import “fmt” 
func f(a [3]int) { fmt.Println(a) } 
func fp(a *[3]int) { fmt.Println(a) } 
func main() { 
var ar [3]int 
f(ar) // passes a copy of ar 
fp(&ar) // passes a pointer to ar 
} 
Output: 
[0 0 0] 
&[0 0 0] 
Another equivalent way is to make a slice of the array and pass that to the function (see Passing an 
array to a function in § 7.1.4) 
EXERCISES: 
Exercise 7.1: array value.go
memory of the array is made. The Way to Go 
161 
Exercise 7.2: for array.go
15) and then prints that array to the screen. 
Exercise 7.3: fibonacci array.go
numbers. But they can also be calculated in an imperative way, using a simple 
array. Do this for the first 50 Fibonacci numbers. 
7.1.2 Array literals 
When the values (or some of them) of the items are known beforehand, a simpler initialization 
exists using the { , , } notation called array literals (or constructors), instead of initializing every item 
in the [ ]= way. (All composite types have a similar syntax for creating literal values). 
This is illustrated in the following code Listing 7.3—array literals.go: 
package main 
import “fmt” 
func main() { 
var arrAge = [5]int{18, 20, 15, 22, 16} 
var arrLazy = [...]int{5, 6, 7, 8, 22} 
// var arrLazy = []int{5, 6, 7, 8, 22} 
var arrKeyValue = [5]string{3: “Chris”, 4: “Ron”} 
//var arrKeyValue = []string{3: “Chris”, 4: “Ron”} 
for i := 0; i < len(arrKeyValue); i++ { 
fmt.Printf(“Person at %d is %s\n”, i, arrKeyValue[i]) 
} 
}
1st variant: 
var arrAge = [5]int{18, 20, 15, 22, 16} 
Note that the [5]int can be omitted from the left-hand side 
[10]int { 1, 2, 3 } : this is an array of 10 elements with the 1st 
three different from 0. 
2nd variant: 

: Write the loop that fills an array with the loop-counter (from 0 to 

: Prove that when assigning an array to another, a distinct copy in 

: In § 6.6 we saw a recursive solution for calculating Fibonacci 

_

_

_

_

var arrLazy = [...]int{5, 6, 7, 8, 22} 
... indicates the compiler has to count the number of items to obtain the length of the 
array. 
But [...]int is not a type, so this is illegal: 
var arrLazy [...]int = [...]int{5, 6, 7, 8, 22} 
The ... can also be omitted (technically speaking it then becomes a slice).162 
Ivo Balbaert 
3rd variant: 
key: value syntax 
var arrKeyValue = [5]string{3: “Chris”, 4: “Ron”} 
Only the items with indexes (keys) 3 and 4 get a real value, the others are set to empty 
strings, as is shown in the output: 
Person at 0 is 
Person at 1 is 
Person at 2 is 
Person at 3 is Chris 
Person at 4 is Ron 
Here also the length can be written as ... or even be omitted. 
You can take the address of an array literal to get a pointer to a newly created instance, see Listing 
7.4—pointer array2.go: 
_
package main 
import “fmt” 
func fp(a *[3]int) { fmt.Println(a) } 
func main() { 
for i := 0; i < 3; i++ { 
fp(&[3]int{i, i * i, i * i * i}) 
} 
} 
Output: &[0 0 0] 
&[1 1 1] 
&[2 4 8] 
Geometrical points (or mathematical vectors) are a classic example of the use of arrays. To clarify 
the code often an alias is used: type Vector3D [3]float32 
var vec Vector3D 
7.1.3 Multidimensional arrays 
Arrays are always 1-dimensional, but they may be composed to form multidimensional arrays, 
like: 
[3][5]int 
[2][2][2]float64 
The inner arrays have always the same length. Go’s multidimensional arrays are rectangular (the 
only exceptions can be arrays of slices, see § 7.2.5).The Way to Go 
163 
Here is a code snippet which uses such an array: 
Listing 7.5—multidim array.go: 
package main 
const ( 
WIDTH =1920 
HEIGHT = 1080 
) 
type pixel int 
var screen [WIDTH][HEIGHT]pixel 
func main() { 
for y := 0; y < HEIGHT; y++ { 
for x := 0; x < WIDTH; x++ { 
screen[x][y] = 0 
} 
} 
} 
7.1.4 Passing an array to a function 
Passing big arrays to a function quickly uses up much memory. 
There are 2 solutions to prevent this: 
1- Pass a pointer to the array 
2- Use a slice of the array 
The following example Listing 7.6—array sum.go
package main 
import “fmt” 
func main() { 
array := [3]float64{7.0, 8.5, 9.1} 
x := Sum(&array) // Note the explicit address-of operator 
// to pass a pointer to the array 
fmt.Printf(“The sum of the array is: %f”, x) 
}164 
Ivo Balbaert 

 illustrates the first solution: 

_

_

_

func Sum(a *[3]float64) (sum float64) { 
for  , v := range a { // dereferencing *a to get back to the array is 
not necessary! 
sum += v 
} 
return 
} 
// Output: The sum of the array is: 24.600000 
But this is not idiomatic Go, solution 2 using slices is: see § 7.2.2 
7.2 Slices 
7.2.1 Concept 
A slice is a reference to a contiguous segment(section) of an array (which we will call the underlying 
array, and which is usually anonymous), so a slice is a reference type (thus more akin to the array 
type in C/C++, or the list type in Python). This section can be the entire array, or a subset of the 
items indicated by a start- and an end index (the item at the end-index is not included in the slice). 
Slices provide a dynamic window onto the underlying array. 
Slices are indexable and have a length given by the len()-function. 
The slice-index of a given item can be less than the index of the same element in the underlying 
array. Unlike an array, the length of a slice can change during execution of the code, minimally 0 
and maximally the length of the underlying array: a slice is variable-length array. 
The built-in capacity function cap() of a slice is a measure of how long a slice can become: it is the 
length of the slice + the length of the array beyond the slice. If s is a slice cap is the size of the array 
from s[0] to the end of the array. A slice’s length can never exceed its capacity, so the following 
statement is always true for a slice s: 
0 <= len(s) <= cap(s) 
Multiple slices can share data if they represent pieces of the same array; multiple arrays can never 
share data. A slice therefore shares storage with its underlying array and with other slices of the 
same array, by contrast distinct arrays always represent distinct storage. Arrays are in fact building 
blocks for slices.The Way to Go 
165 
Advantage: 
Because slices are references, they don’t use up additional memory and so are more 
efficient to use than arrays, so they are used much more than arrays in Go-code. 
The format of the declaration is: 
var identifier []type no length is needed. 
A slice that has not yet been initialized is set to nil by default, and has length 0. 
Format of initialization of a slice: 
var slice1 []type = arr1[start:end] 
This represents the subarray of arr1 (slicing the array, start:end is called a slice-expression) composed 
of the items from index start to index end-1.So slice1[0] == arr1[start] is a true statement. 
This can be defined even before the array arr1 is populated. 
If one writes: var slice1 []type = arr1[:] then slice1 is equal to the complete array arr1 (so it is 
a shortcut for arr1[0:len(arr1)]). Another way to write this is: slice1 = &arr1. 
arr1[2:] is the same as arr1[2:len(arr1)] so contains all the items of the array from the 2nd till 
the last. 
arr1[:3] is the same as arr1[0:3], containing the array-items from the 1st till (not including) the 
3rd . 
If you need to cut the last element from slice1, use: 
slice1 = slice1[:len(slice1)-1] 
A slice of the array with elements 1,2 and 3 can be made as follows: s := [3]int{1,2,3}[: or s 
:= […]int{1,2,3}[:] or even shorter s := []int{1,2,3} 
s2 := s[:] is a slice made out of a slice, having identical elements, but still refers to the same 
underlying array. 
A slice s can be expanded to its maximum size with: s = s[:cap(s)], any larger gives a run time 
error (see listing 7.7). 
For every slice (also for strings) the following is always true: 
s == s[:i] + s[i:] // i is an int: 0 <= i <= len(s) 
len(s) <= cap(s) 
Slices can also be initialized like arrays: var x = []int{2, 3, 5, 7, 11}166 
Ivo Balbaert 
What this does is create an array of length 5 and then create a slice to refer to it. 
A slice in memory is in fact a structure with 3 fields: a pointer to the underlying array, the length of 
the slice, and the capacity of the slice. This is illustrated in the following figure, where the slice y 
is of length 2 and capacity 4. 
y[0] = 3 and y[1] = 5. The slice y[0:4] contains the elements 3, 5, 7 and 11. 
Fig 7.2: Slice in memory 
Listing 7.7—array slices.go shows us the basic usage: 

_

package main 
import “fmt” 
func main() { 
var arr1 [6]int 
var slice1 []int = arr1[2:5] // item at index 5 not included! 
// load the array with integers: 0,1,2,3,4,5 
for i := 0; i < len(arr1); i++ { 
arr1[i] = i 
} 
// print the slice: 
for i := 0; i < len(slice1); i++ { 
fmt.Printf(“Slice at %d is %d\n”, i, slice1[i]) 
} 
fmt.Printf(“The length of arr1 is %d\n”, len(arr1)) 
fmt.Printf(“The length of slice1 is %d\n”, len(slice1))The Way to Go 
167 
fmt.Printf(“The capacity of slice1 is %d\n”, cap(slice1)) 
// grow the slice: 
slice1 = slice1[0:4] 
for i := 0; i < len(slice1); i++ { 
fmt.Printf(“Slice at %d is %d\n”, i, slice1[i]) 
} 
fmt.Printf(“The length of slice1 is %d\n”, len(slice1)) 
fmt.Printf(“The capacity of slice1 is %d\n”, cap(slice1)) 
// grow the slice beyond capacity: 
// slice1 = slice1[0:7 ] // panic: runtime error: slice bounds out of range 
} 
Output: 
Slice at 0 is 2 
Slice at 1 is 3 
Slice at 2 is 4 
The length of arr1 is 6 
The length of slice1 is 3 
The capacity of slice1 is 4 
Slice at 0 is 2 
Slice at 1 is 3 
Slice at 2 is 4 
Slice at 3 is 5 
The length of slice1 is 4 
The capacity of slice1 is 4 
If s2 is a slice, then you can move the slice forward by one with s2 = s2[1:], but the end is not 
moved. Slices can only move forward: s2 = s2[-1:] results in a compile error. 
Slices cannot be re-sliced below zero to access earlier elements in the array. 
!! Never use a pointer to a slice. A slice is already a reference type, so it is a pointer !! 
Question 7.2: Given the slice of bytes b := []byte{‘g’, ‘o’, ‘l’, ‘a’, ‘n’, ‘g’} 
What are: b[1:4], b[:2], b[2:] and b[:] ?168 
Ivo Balbaert 
7.2.2 Passing a slice to a function 
If you have a function which must operate on an array, you probably always want to declare the 
formal parameter to be a slice. When you call the function, slice the array to create (efficiently) a 
slice reference and pass that. For example, here is a function that sums all elements in an array: 
func sum(a []int) int { 
s := 0 
for i := 0; i < len(a); i++ { 
s += a[i] 
} 
return s 
} 
func main { 
var arr = [5]int{0,1,2,3,4} 
sum(arr[:]) 
} 
7.2.3 Creating a slice with make() 
Often the underlying array is not yet defined, we can then make the slice together with the array 
using the make( ) function: 
var slice1 []type = make([]type, len) 
which can be shortened to: 
slice1 := make([]type, len) 
where len is the length of the array and also the initial length of the slice. 
So for the slice s2 made with: s2 := make([]int, 10) 
the following is true: cap(s2) == len(s2) == 10 
make takes 2 parameters: the type to be created, and the number of items in the slice. 

_

If you want slice1 not to occupy the whole array (with length cap) from the start, but only a 
number len of items, use the form: 
slice1 := make([]type, len, cap) 
make has the signature: func make([]T, len, cap) []T with optional parameter cap. 
So the following statements result in the same slice: 
make([]int, 50, 100) 
new([100]int)[0:50] 
The following figure depicts the making of a slice in memory:The Way to Go 
169 
Fig 7.2: Slice in memory 
Example: 
Listing 7.8—make slice.go: 
package main 
import “fmt” 
func main() { 
var slice1 []int = make([]int, 10) 
// load the array/slice: 
for i := 0; i < len(slice1); i++ { 
slice1[i] = 5 * i 
} 
// print the slice: 
for i := 0; i < len(slice1); i++ { 
fmt.Printf(“Slice at %d is %d\n”, i, slice1[i]) 
} 
fmt.Printf(“\nThe length of slice1 is %d\n”, len(slice1)) 
fmt.Printf(“The capacity of slice1 is %d\n”, cap(slice1)) 
} 
Output: 
Slice at 0 is 0 
Slice at 1 is 5 
Slice at 2 is 10 
Slice at 3 is 15 
Slice at 4 is 20 
Slice at 5 is 25 
Slice at 6 is 30 
Slice at 7 is 35 
Slice at 8 is 40 
Slice at 9 is 45 
The length of slice1 is 10170 
Ivo Balbaert 
The capacity of slice1 is 10 
Because strings are in essence immutable arrays of bytes, they can be sliced too. 
Exercise 7.4: fibonacci funcarray.go
main calls a function with parameter the number of terms in the series. The 
function returns a slice with the Fibonacci numbers up to that number. 
7.2.4 Difference between new() and make() 
This is often confusing at first sight: both allocate memory on the heap, but they do different 
things and apply to different types. 
new(T) allocates zeroed storage for a new item of type T and returns its address, 
a value of type *T: it returns a pointer to a newly allocated zero value of type T, 
ready for use; it applies to value types like arrays and structs (see Chapter 10); it is 
equivalent to &T{ } 
make(T) returns an initialized value of type T; it applies only to the 3 built-in 
reference types: slices, maps and channels (see chapters 8 and 13). 
In other words, new allocates; make initializes; the following figure illustrates this difference: 
Fig 7.3: Difference between new() and make() 
In the first drawing in fig 7.3: 
var p *[]int = new([]int) 
// *p == nil; with len and cap 0 
or 
p := new([]int)The Way to Go 
171 
which is only rarely useful. 
In the lower figure: 
p := make([]int, 0) 
our slice is initialized, but here points to an empty array. 
Both these statements aren’t very useful, the following is: 
var v []int = make([]int, 10, 50) 
or 
v := make([]int, 10, 50) 

: Starting from solution Ex 7.3, make a version in which 

_

This allocates an array of 50 ints and then creates a slice v with length 10 and capacity 50 pointing 
to the first 10 elements of the array. 
Question 7.3: Given s := make([]byte, 5), what is len(s) and cap(s) ? 
s = s[2:4], what is now len(s) and cap(s) ? 
Question 7.4: Suppose s1 := []byte{‘p’, ‘o’, ‘e’, ‘m’} and s2 := d[2:] 
What is the value of s2 ? 
We do: s2[1] == ‘t’, what is now the value of s1 and s2 ? 
7.2.5 Multidimensional slices 
Like arrays, slices are always 1-dimensional but may be composed to construct higher-dimensional 
objects. With slices of slices (or arrays of slices), the lengths may vary dynamically, so Go’s 
multidimensional slices can be jagged. Moreover, the inner slices must be allocated individually 
(with make). 
7.2.6 The bytes package 
Slices of bytes are so common that Go has a package bytes with manipulation functions for that 
kind of type. 
It is very analogous to the strings package (see. § 4.7). Moreover it contains a very handy type 
Buffer: 
import “bytes” 
type Buffer struct { 
... 
} 
which is a variable-sized buffer of bytes with Read and Write methods, because reading and writing 
an unknown number of bytes is best done buffered.Ivo Balbaert 
A Buffer can be created as a value as in: var buffer bytes.Buffer 
or as a pointer with new as in: var r *bytes.Buffer = new(bytes.Buffer) 
or created with the function: func NewBuffer(buf []byte) *Buffer 
that creates and initializes a new Buffer using buf as its initial contents; it is best to use NewBuffer 
only to read from buf. 
Concatenating strings by using a buffer: 
This works analogous to Java’s StringBuilder class. 
Make a buffer, append each string s in it with the buffer.WriteString(s) method, and convert at 
the end back to a string with buffer.String(), as in the following code snippet: 
var buffer bytes.Buffer 
for { 
if s, ok := getNextString(); ok { //method getNextString() not shown here 
buffer.WriteString(s) 
} else { 
break 
} 
} 
fmt.Print(buffer.String(), “\n”) 
This method is much more memory and CPU-efficient than +=, especially if the number of strings 
to concatenate is large. 
EXERCISES: 
Exercise 7.5: Given a slice sl we want to append a []byte data. 
Write a function Append(slice, data[]byte) []byte which lets sl grow if it is not 
big enough to accommodate data. 
Exercise 7.6: Split a buffer buf into 2 slices: the header is the first n bytes, the tail is the rest; use 
1 line of code. 
7.3 For range construct 
This construct can be applied to arrays and slices: 
for ix, value := range slice1 { 
… 
} 
172The Way to Go 
The first return value ix is the index in the array or slice, the second is the value at that index; they 
are local variables only known in the body of the for-statement, so value is a copy of the slice item 
at that index and cannot be used to modify it! 
Listing 7.9—slices forrange.go: 
package main 
import “fmt” 
func main() { 
slice1 := make([]int, 4) 
slice1[0] = 1 
slice1[1] = 2 
slice1[2] = 3 
slice1[3] = 4 
for ix, value := range slice1 { 
fmt.Printf(“Slice at %d is: %d\n”, ix, value) 

_

_

_

_

 presents an example with strings, only the important code is 

} 
} 
Listing 7.10—slices forrange2.go
shown here: 
seasons := []string{“Spring”,“Summer”,“Autumn”,“Winter”} 
for ix, season := range seasons { 
fmt.Printf(“Season %d is: %s\n”, ix, season) 
} 
var season string 
for  , season = range seasons { 
fmt.Printf(“%s\n”, season) 
} 
 can be used to discard the index. 
_
If you only need the index, you can omit the 2nd variable, like in: 
for ix := range seasons { 
fmt.Printf(“%d “, ix) 
173174 
Ivo Balbaert 
} 
// Output: 0 1 2 3 
Use this version if you want to modify seasons[ix] 
for range with multidimensional slices: 
It can be convenient to write the nested for-loops of §7.1.3 as simply counting the rows and 
numbers of a matrix value, like in (taking the example of Listing 7.5—multidim array.go): 
for row := range screen { 
for column := range screen[0] { 
screen[row][column] = 1 
} 
} 
Question 7.5: Suppose we have the following slice: 
items := […]int{10, 20, 30, 40, 50} 
a) If we code the following for-loop, what will be the value of items after the loop ? 
for  , item := range items { 
_
item *= 2 
} 
Try it out if you are not sure. 
b) If a) does not work, make a for-loop in which the values are doubled. 
Question 7.6: Sum up the contexts in the Go syntax where the ellipsis operator … is used. 
EXERCISES: 
Exercise 7.7: sum array.go
a) Write a function Sum which has as parameter an array arrF of 4 floating-point 
numbers, and which returns the sum of all the numbers in the array sum array.go 
How would the code have to be modified to use a slice instead of an array ? 
The slice-form of the function works for arrays of different lengths!The Way to Go 
175 
b) Write a function SumAndAverage which returns these two as unnamed variables 
of type int and float32. 
Exercise 7.8: min max.go
: 
Write a minSlice function which takes a slice of ints and returns the minimum, 
and a maxSlice function which takes a slice of ints and returns the maximum. 
7.4 Reslicing 
We saw that a slice is often made initially smaller than the underlying array, like this: 
slice1 := make([]type, start length, capacity) 
with start length
This is useful because now our slice can grow till capacity. 
Changing the length of the slice is called reslicing, it is done e.g. like: slice1 = slice1[0:end] 
where end is another end-index (length) than before. 
Resizing a slice by 1 can be done as follows: sl = sl[0:len(sl)+1] // extend length by 1 
A slice can be resized until it occupies the whole underlying array. 
This is illustrated in program Listing 7.11—reslicing.go: 
package main 
import “fmt” 
func main() { 
slice1 := make([]int, 0, 10) 
// load the slice, cap(slice1) is 10: 
for i := 0; i < cap(slice1); i++ { 
slice1 = slice1[0:i+1] // reslice 
slice1[i] = i 
fmt.Printf(“The length of slice is %d\n”, len(slice1)) 
} 
// print the slice: 
for i := 0; i < len(slice1); i++ { 

 of the slice and capacity the length of the underlying array. 

: 

_

_

_

_

_

fmt.Printf(“Slice at %d is %d\n”, i, slice1[i]) 
} 
}176 
Ivo Balbaert 
Output: 
The length of slice is 1 
The length of slice is 2 
The length of slice is 3 
The length of slice is 4 
The length of slice is 5 
The length of slice is 6 
The length of slice is 7 
The length of slice is 8 
The length of slice is 9 
The length of slice is 10 
Slice at 0 is 0 
Slice at 1 is 1 
Slice at 2 is 2 
Slice at 3 is 3 
Slice at 4 is 4 
Slice at 5 is 5 
Slice at 6 is 6 
Slice at 7 is 7 
Slice at 8 is 8 
Slice at 9 is 9 
Another example: 
var ar = [10]int{0,1,2,3,4,5,6,7,8,9} 
var a = ar[5:7] // reference to subarray {5,6} - len(a) is 2 and cap(a) is 5 
reslicing a: a = a[0:4] 
// ref of subarray {5,6,7,8} - len(a) is now 4 but cap(a) is still 5. 
Question 7.7: 1) If s is a slice, what is the length of this reslice ? 
s[n:n] 
2) And what is the length of s[n:n+1]? 
7.5 Copying and appending slices 
To increase the capacity of a slice one must create a new, larger slice and copy the contents of 
the original slice into it. The following code illustrates the functions copy for copying slices, and 
append for appending new values to a slice.The Way to Go 
177 
Listing 7.12—copy append slice.go
_
package main 
import “fmt” 
func main() { 
sl from := []int{1,2,3} 
sl to := make([]int,10) 
n := copy(sl to, sl from) 
_
fmt.Println(sl to) // output: [1 2 3 0 0 0 0 0 0 0] 
fmt.Printf(“Copied %d elements\n”, n) // n == 3 
sl3 := []int{1,2,3} 
sl3 = append(sl3, 4, 5, 6) 
fmt.Println(sl3) // output: [1 2 3 4 5 6] 
} 
func append(s[]T, x ...T) []T 
The function append appends zero or more values to a slice s and returns the resulting slice, with 
the same type as s; the values of course have to be of same type as the element-type T of s. If the 
capacity of s is not large enough to fit the additional values, append allocates a new, sufficiently 
large slice that fits both the existing slice elements and the additional values. Thus, the returned 
slice may refer to a different underlying array. The append always succeeds, unless the computer 
runs out of memory. 
If you want to append a slice y to a slice x, use the following form to expand the second argument 
to a list of arguments: x = append(x, y...) 
Remark: 
append is good for most purposes, however if you want complete control over the 
process, you could use a function AppendByte like this: 
func AppendByte(slice []byte, data ...byte) []byte { 
m := len(slice) 
n := m + len(data) 
if n > cap(slice) { // if necessary, reallocate 
// allocate double what’s needed, for future growth. 
newSlice := make([]byte, (n+1)*2) 
copy(newSlice, slice) 

: 

_
_

_

_

_

_

_

_

_

: 

: 

: 

: Given a slice s []int and a factor of type int, enlarge s so that its 

slice = newSlice178 
Ivo Balbaert 
} 
slice = slice[0:n] 
copy(slice[m:n], data) 
return slice 
} 
func copy(dst, src []T) int 
The function copy copies slice elements of type T from a source src to a destination dst, overwriting 
the corresponding elements in dst, and returns the number of elements copied. Source and 
destination may overlap. The number of arguments copied is the minimum of len(src) and len(dst). 
When src is a string the element type is byte. If you want to continue working with the variable src, 
put: src = dst after the copy. 
Exercise 7.9: magnify slice.go
new length is len(s) * factor. 
Exercise 7.10: filter slice.go
Using a higher order function for filtering a collection: 
s is a slice of the first 10 integers. Make a function Filter which accepts s as 1st 
parameter and a fn func(int) bool as 2nd parameter and returns the slice of the 
elements of s which fulfil the function fn (make it true). Test this out with fn 
testing if the integer is even. 
Exercise 7.11: insert slice.go
Make a function InsertStringSlice that inserts a slice into another slice at a certain 
index. 
Exercise 7.12: remove slice.go
Make a function RemoveStringSlice that removes items from index start to end in 
a slice. 
7.6 Applying strings, arrays and slices 
7.6.1 Making a slice of bytes from a string 
If s is a string (so in fact an array of bytes) a slice of bytes c can immediately be made with c:=[] 
byte(s). This can also be done with the copy-function: copy(dst []byte, src string)The Way to Go 
179 
For-range can also be applied, example Listing 7.13—for string.go: 
package main 
import “fmt” 
func main() { 
s := “\u00ff\u754c” 
for i, c := range s { 
fmt.Printf(“%d:%c “, i, c) 
} 
} 
Output: 0:ÿ 2:
We see that Unicode-characters take 2 bytes; some characters can even take 3 or 4 bytes. If erroneous 
UTF-8 is encountered, the character is set to U+FFFD and the index advances by one byte. In 
the same way the conversion c:=[]int(s) is allowed, then each int contains a Unicode code point: 
every character from the string corresponds to one integer; similarly the conversion to runes can 
be done with: r:=[]rune(s) 
The number of characters in a string s is given by len([]int(s)), but utf8.RuneCountInString(s) 
is faster (see Ex 4.6). 
A string may be appended to a byte slice, like this: 
var b []byte 
var s string 
b = append(b, s...) 
7.6.2 Making a substring of a string 
substr := str[start:end] takes the substring from str from the byte at index start to the byte 
at index end—1. Also str[start:] is the substring starting from index start to len(str) – 1, 
str[:end] is the substring starting from index 0 to end – 1. 
7.6.3 Memory representation of a string and a slice 
A string in memory is in fact a 2 word-structure consisting of a pointer to the string data and the 
length (see Fig 7.4); the pointer is completely invisible in Go-code; so for all practical purposes we 
can continue to see a string as a value type, namely its underlying array of characters. A substring 
(slice) t = s[2:3] of the string s = “hello” can be represented in memory as:180 
Ivo Balbaert 
Fig 7.4: String and slice in memory 
7.6.4 Changing a character in a string 
Strings are immutable. This means when str denotes a string that str[index] cannot be the left side 
of an assignment: 
str[i] = ‘D’ where i is a valid index gives the error cannot assign to 

 界

_

str[i] 
To do this you first have to convert the string to an array of bytes, then an array-item of a certain 
index can be changed, and then the array must be converted back to a new string. 
For example, change “hello” to “cello”: 
s:=“hello” 
c:=[]byte(s) 
c[0]=’c’ 
s2:= string(c) 
// s2 == “cello” 
So it is clear that string-extractions are very easy with the slice-syntax. 
7.6.5 Comparison function for byte arrays 
The following function Compare returns an integer comparing 2 byte arrays lexicographically. 
The result is : 0 if a ==b, -1 if a < b, 1 if a > b 
func Compare(a, b[]byte) int { 
for i:=0; i < len(a) && i < len(b); i++ {The Way to Go 
switch { 
case a[i] > b[i]: 
return 1 
case a[i] < b[i]: 
return -1 
} 
} 
// Strings are equal except for possible tail 
switch { 
case len(a) < len(b): 
return -1 
case len(a) > len(b): 
return 1 
} 
return 0 // Strings are equal 
} 
7.6.6 Searching and sorting slices and arrays 
Searching and sorting are very common operations and the standard library provides for these in 
the package sort. To sort a slice of ints, import the package “sort” and simply call the function func 
Ints(a []int) as in sort.Ints(arri), where arri is the array or slice to be sorted in ascending 
order. To test if an array is sorted, use func IntsAreSorted(a []int) bool, which returns true or 
false whether or not the array is sorted. 
Similarly for float64 elements, you use the function func Float64s(a []float64) and for strings 
there is the function func Strings(a []string). 
To search an item in an array or slice, the array must first be sorted (the reason is that the 
search-functions are implemented with the binary-search algorithm). Then you can use the 
function func SearchInts(a []int, n int) int, which searches for n in the slice a, and returns its 
index. And of course the equivalent functions for float64s and strings exist also: 
func SearchFloat64s(a []float64, x float64) int 
func SearchStrings(a []string, x string) int 
Further details can be found in the official information: http://golang.org/pkg/sort/ 
This is how to use the sort-package functions. In §11.6 we discover the theory behind it, and we 
implement ourselves the sort-functionality, much like in the package. 
181182 
Ivo Balbaert 
7.6.7 Simulating operations with append 
The append method from § 7.5 is very versatile and can be used for all kinds of manipulations: 
1) Append a slice b to an existing slice a: 
a = append(a, b...) 
2) Copy a slice a to a new slice b: 
b = make([]T, len(a)) 
copy(b, a) 
3) Delete item at index i: 
a = append(a[:i], a[i+1:]...) 
4) Cut from index i till j out of slice a: 
a = append(a[:i], a[j:]...) 
5) Extend slice a with a new slice of length j: 
a = append(a, make([]T, j)...) 
6) Insert item x at index i: 
a = append(a[:i], append([]T{x}, 
a[i:]...)...) 
7) Insert a new slice of length j at index i: 

_

_

a = append(a[:i], append(make([]T, 
j), a[i:]...)...) 
8) Insert an existing slice b at index i: 
a = append(a[:i], append(b, 
a[i:]...)...) 
9) Pop highest element from stack: 
x, a = a[len(a)-1], a[:len(a)-1] 
10) Push an element x on a stack: 
a = append(a, x) 
So to represent a resizable sequence of elements use a slice and the append-operation. 
A slice is often called a vector in a more mathematical context. If this makes code clearer you can 
define a vector alias for the kind of slice you need, Listing 10.11 (method2.go) shows a simple 
example. 
If you need something more elaborated go and have a look at the following packages written by 
Eleanor McHugh: http://github.com/feyeleanor/slices, http://github.com/feyeleanor/chain, and 
http://github.com/feyeleanor/lists. 
7.6.8 Slices and garbage collection 
A slice points to the underlying array; this array could potentially be very much bigger than the 
slice as in the following example. As long as the slice is referred to, the full array will be kept in 
memory until it is no longer referenced. Occasionally this can cause the program to hold all the 
data in memory when only a small piece of it is needed. 
Example: this FindDigits function loads a file into memory and searches it for the first group of 
consecutive numeric digits, returning them as a new slice.The Way to Go 
183 
var digitRegexp = regexp.MustCompile(“[0-9]+”) 
func FindDigits(filename string) []byte { 
b,   := ioutil.ReadFile(filename) 
return digitRegexp.Find(b) 
} 
This code works as described, but the returned [ ]byte points into an array containing the entire file. 
Since the slice references the original array, as long as the slice is kept around the garbage collector 
can’t release the array; the few useful bytes of the file keep the entire contents in memory. 
To fix this problem one can copy the interesting data to a new slice before returning it: 
func FindDigits(filename string) []byte { 
b,   := ioutil.ReadFile(filename) 
b = digitRegexp.Find(b) 
c := make([]byte, len(b)) 
copy(c, b) 
return c 
} 
EXERCISES: 
Exercise 7.12: string split.go: 
Write a function Split with parameters a string to split and the position to split, 
which returns the two substrings. 
Exercise 7.13: string split2.go
If str is a string, what then is str[len(str)/2:] + str[:len(str)/2]? Test it 
Exercise 7.14: string reverse.go
Write a program that reverses a string, so “Google” is printed as ” elgooG”. 
(Hint: use a slice of bytes and conversions.) 
If you coded a solution with two slices, try a variant which uses only one (Hint: 
use swapping) 
If you want to be able to reverse Unicode-strings: use [ ]int ! 
Exercise 7.15: uniq.go 
Write a program that traverses an array of characters, and copies them to another 
array only if the character is different from that which precedes it.Ivo Balbaert 
Exercise 7.16: bubblesort.go 
Sort a slice of ints through a function which implements the Bubblesort-algorithm 
(look up the definition of this algorithm at http://en.wikipedia.org/wiki/ 
Bubble sort) 
_
Exercise 7.17: map function.go 
In functional languages a map-function is a function which takes a function and a 
list as arguments, and its result is a list where the argument-function is applied to 
each element of the list, formally: 
map ( F(), (e1,e2, . . . ,en) ) = ( F(e1), F(e2), … F(en) ) 
Write such a function mapFunc which takes as arguments: 
- a (lambda) function that multiplies an int by 10 
- a list of ints 
and returns the list of all ints multiplied by 10. 

: 

: 

_

_

_

_

184185 
Chapter 8—Maps 
Maps are a special kind of data structure: an unordered collection of pairs of items, where one 
element of the pair is the key, and the other element, associated with the key, is the data or the 
value, hence they are also called associative arrays or dictionaries. They are ideal for looking up 
values fast: given the key, the corresponding value can be retrieved very quickly. 
This structure exists in many other programming languages under other names such as Dictionary 
(dict in Python), hash, HashTable, etc. 
8.1 Declaration, initialization and make 
8.1.1 Concept 
A map is a reference type and declared in general as: 
var map1 map[keytype]valuetype 
e.g.: 
var map1 map[string]int 
(A space is allowed between [keytype] valuetype, but gofmt removes this) 
The length of the map doesn’t have to be known at declaration: a map can grow dynamically. 
The value of an uninitialized map is nil. 
The key type can be any type for which the operations == and != are defined, like string, int, float. 
So arrays, slices and structs cannot be used as key type, but pointers and interface types can. One 
way to use structs as a key is to provide them with a Key() or Hash() method, so that a unique 
numeric or string key can be calculated from the struct’s fields. 
The value type can be any type; by using the empty interface as type (see § 11.9), we could store 
any value, but when using that value we would first have to do a type assertion (see § 11.3). 
Maps are cheap to pass to a function: 4 bytes on a 32 bit machine, 8 bytes on a 64 bit machine, 
no matter how much data they hold. Looking up a value in a map by key is fast, much faster 186 
Ivo Balbaert 
than a linear search, but still around 100x slower than direct indexing in an array or slice; so if 
performance is very important try to solve the problem with slices. 
A map with function values can also be used as a branching structure (see chapter 5): the keys are 
used to select the branch which is a function that is executed. 
If key1 is a key value of map map1, then map1[key1] is the value associated with key1, just like 
the array-index notation (an array could be considered as a simple form of a map, where the keys 
are integers starting from 0). 
The value associated with key1 can be set to (or if already present changed to) val1 through the 
assignment: map1[key1] = val1 
The assignment v:= map1[key1] stores in v the value corresponding to key1; if key1 is not present 
in the map, then v becomes the zero-value for the value type of map1. 
As usual len(map1) gives the number of pairs in the map, which can grow or diminish because 
map-pairs may be added or removed during runtime. 
 a number of maps are shown: 
In Listing 8.1—make maps.go
package main 
import “fmt” 
func main() { 
var mapLit map[string]int 
//var mapCreated map[string]float32 
var mapAssigned map[string]int 
mapLit = map[string]int{“one”: 1, “two”: 2} 
mapCreated := make(map[string]float32) 
mapAssigned = mapLit 
mapCreated[“key1”] = 4.5 
mapCreated[“key2”] = 3.14159 
mapAssigned[“two”] = 3 
fmt.Printf(“Map literal at \“one\” is: %d\n”, mapLit[“one”]) 
fmt.Printf(“Map created at \“key2\” is: %f\n”, mapCreated[“key2”]) 
fmt.Printf(“Map assigned at \“two\” is: %d\n”, mapLit[“two”]) 
fmt.Printf(“Map literal at \“ten\” is: %d\n”, mapLit[“ten”]) 
} 
Output: 
Map literal at “one” is: 1 
Map created at “key2” is: 3.141590The Way to Go 
187 
Map assigned at “two” is: 3 
Map literal at “ten” is: 0 
mapLit illustrates the use of map literals: a map can be initialized with the {key1: val1, key2: 
val2} notation, just like arrays and structs. 
Maps are reference types: memory is allocated with the make-function: 
Initialization of a map: 
var map1[keytype]valuetype = make(map[keytype]valuetype) 

_

_

or shorter with: 
map1 := make(map[keytype]valuetype) 
mapCreated is made in this way: mapCreated := make(map[string]float) 
which is equivalent to: 
mapCreated := map[string]float{} 
Also mapAssigned is a reference to the same value as mapLit, changing mapAssigned also changes 
mapLit as the program output shows. 
!! Don’t use new, always use make with maps !! 
Remark: If you by mistake allocate a reference object with new(), you receive a pointer to a nil 
reference, equivalent to declaring an uninitialized variable and taking its address: 
mapCreated := new(map[string]float) 
Then we get in the statement: mapCreated[“key1”] = 4.5 
the compiler error: invalid operation: mapCreated[“key1”] (index of type *map[string] 
float). 
To demonstrate that the value can be any type, here is an example of a map which has a func() int 
as its value: Listing 8.2—map func.go: 
package main 
import “fmt” 
f unc main() { 
mf := map[int]func() int{ 
1: func() int { return 10 }, 
2: func() int { return 20 }, 
5: func() int { return 50 }, 
} 
fmt.Println(mf) 
} 
The output is: map[1:0x10903be0 5:0x10903ba0 2:0x10903bc0]: the integers are mapped to 
addresses of functions.188 
Ivo Balbaert 
8.1.2 Map capacity 
Unlike arrays, maps dynamically grow to accommodate new key-values that are added, they have 
no fixed or maximum size. But you can optionally indicate an initial capacity cap for the map, as 
in 
make(map[keytype]valuetype, cap) 
e.g.: 
map2 := make(map[string]float, 100) 
When the map has grown to its capacity, and a new key-value is added, then the size of the map will 
automatically increase by 1. So for large maps or maps that grow a lot, it is better for performance 
to specify an initial capacity, even if this is only known approximately. 
Here is a more concrete example of a map: map the name of a musical note to its frequency in Hz 
( measuring frequencies in Hz for equal-tempered scale (A4 = 440Hz)): 
noteFrequency := map[string]float32{ 
“C0”: 16.35, “D0”: 18.35, “E0”: 20.60, “F0”: 21.83, 
“G0”: 24.50, “A0”: 27.50, “B0”: 30.87, “A4”: 440} 
8.1.3 Slices as map values 
When one key has only one associated value, the value can be a primitive type. What if a key 
corresponds to many values ? For example, when we have to work with all the processes on a 
Unix-machine, where a parent process as key (process-id pid is an int value) can have many child 
processes (represented as a slice of ints with their pid’s as items). This can be elegantly solved by 
defining the value type as a [ ]int or a slice of another type. 
Here are some examples defining such maps: 
mp1 := make(map[int][]int) 
mp2 := make(map[int]*[]int) 
8.2 Testing if a key-value item exists in a map—Deleting an element 
Testing the existence of key1 in map1: 
We saw in § 8.1 that val1 = map1[key1] returns us the value val1 associated with key1. If key1 does 
not exist in the map, val1 becomes the zero-value for the value’s type. 
But this is ambiguous: now we can’t distinguish between this case, or the case where key1 does exist 
and its value is the zero-value!The Way to Go 
189 
In order to test this, we can use the following comma ok form: val1, isPresent = map1[key1] 
isPresent returns a Boolean value: if key1 exists in map1, val1 will contain the value for key1, and 
isPresent will be true; if key1 does not exist in map1, val1 will contain the zero-value for its type, 
and isPresent will be false. 
If you just want to check for the presence of a key and don’t care about its value, you could write: 
, ok := map1[key1] // ok == true if key1 is present, false otherwise 
_
Or combined with an if: 
if  , ok := map1[key1]; ok { 

_

_

: 

// … 
} 
Deleting an element with key1 from map1: 
This is done with: 
delete(map1, key1) 
When key1 does not exist this statement doesn’t produce an error. 
Both techniques are illustrated in the Listing 8.4—map testelement.go
package main 
import “fmt” 
func main() { 
var value int 
var isPresent bool 
map1 := make(map[string]int) 
map1[“New Delhi”] = 55 
map1[“Bejing”] = 20 
map1[“Washington”] = 25 
value, isPresent = map1[“Bejing”] 
if isPresent { 
fmt.Printf(“The value of \“Bejing\” in map1 is: %d\n”, value) 
} else { 
fmt.Println(“map1 does not contain Bejing”) 
} 
value, isPresent = map1[“Paris”] 
fmt.Printf(“Is \“Paris\” in map1 ?: %t\n”, isPresent)190 
Ivo Balbaert 
fmt.Printf(“Value is: %d\n”, value) 
// delete an item: 
delete(map1, “Washington”) 
value, isPresent = map1[“Washington”] 
if isPresent { 
fmt.Printf(“The value of \“Washington\” in map1 is: %d\n”, value) 
} else { 
fmt.Println(“map1 does not contain Washington”) 
} 
} 
Output: 
The value of “Bejing” in map1 is: 20 
Is “Paris” in map1 ?: false 
Value is: 0 
map1 does not contain Washington 
8.3 The for range construct 
This construct can also be applied to maps: for key, value := range map1 { 
… 
} 
The first return value key is the key of the map, thwe second is the value for that key; they are 
local variables only known in the body of the for-statement. The first element in a map iteration is 
chosen at random.If you are only interested in the values, 
use the form: 
for  , value := range map1 { 
… 
} 
To get only the keys, you can use: 
for key := range map1 { 
fmt.Printf(“key is: %d\n”, key) 
} 
Example: Listing 8.5—maps forrange.go
package main 
import “fmt” 
func main() { 
map1 := make(map[int]float32) 
map1[1] = 1.0The Way to Go 
191 
map1[2] = 2.0 
map1[3] = 3.0 
map1[4] = 4.0 
for key, value := range map1 { 
fmt.Printf(“key is: %d - value is: %f\n”, key, value) 
} 
} 
Output: 
key is: 3 - value is: 3.000000 
key is: 1 - value is: 1.000000 
key is: 4 - value is: 4.000000 

: 

_

_

_

_

_

: 

key is: 2 - value is: 2.000000 
We see that a map is not key-ordered, neither is it sorted on the values. 
Question 8.1: What is the output of the following code snippet: 
capitals := map[string] string {“France”:“Paris”, “Italy”:“Rome”, 
“Japan”:“Tokyo” } 
for key := range capitals { 
fmt.Println(“Map item: Capital of”, key, “is”, capitals[key]) 
} 
Exercise 8.1: map days.go 
Make a map to hold together the number of the day in the week (1 -> 7) with its name. 
Print them out and test for the presence of tuesday and hollyday. 
8.4 A slice of maps 
Suppose we want to make a slice of maps, then we must use make() 2 times, first for the slice, then 
for each of the map-elements of the slice, like in Listing 8.3 
But take care to use the map-items in the slice by index, as in version A. The item value in version 
B is a copy of the map-value, so the real map-variables don’t get initialized. 
Listing 8.3—slice maps.go
package main 
import ( 
“fmt”192 
Ivo Balbaert 
) 
func main() { 
// Version A: 
items := make([]map[int]int, 5) 
for i := range items { 
items[i] = make(map[int]int, 1) 
items[i][1] = 2 
} 
fmt.Printf(“Version A: Value of items: %v\n”, items) 
// Version B: NOT GOOD! 
items2 := make([]map[int]int, 5) 
for  , item := range items2 { 
item = make(map[int]int, 1) 
// item is only a copy of the slice element. 
item[1] = 2 
// This ‘item’ will be lost on the next iteration. 
} 
fmt.Printf(“Version B: Value of items: %v\n”, items2) 
} 
/* Output: 
Version A: Value of items: [map[1:2] map[1:2] map[1:2] map[1:2] map[1:2]] 
Version B: Value of items: [map[] map[] map[] map[] map[]] 
*/ 
8.5 Sorting a map 
By default a map isw not sorted, not even on the value of its keys (see listing 8.5) 
If you want a sorted map, copy the keys (or values) to a slice, sort the slice (using the sort package, 
see § 7.6.6), and then print out the keys and/or values using a for-range on the slice. 
This is illustrated in the following program: 
Listing 8.6—sort map.go
// the telephone alphabet: 
package main 
import ( 
“fmt” 
“sort”The Way to Go 
193 
) 
var ( 
barVal = map[string]int{“alpha”: 34, “bravo”: 56, “charlie”: 23, 
“delta”: 87, “echo”: 56, “foxtrot”: 12, “golf”: 34, “hotel”: 16, 
“indio”: 87, “juliet”: 65, “kilo”: 43, “lima”: 98} 
) 
func main() { 
fmt.Println(“unsorted:”) 
for k, v := range barVal { 
fmt.Printf(“Key: %v, Value: %v / “, k, v) 
} 
keys := make([]string, len(barVal)) 
i := 0 
for k,   := range barVal { 
_
keys[i] = k 
i++ 
} 
sort.Strings(keys) 

: 

_

_

_

: 

fmt.Println() 
fmt.Println(“sorted:”) 
for  , k := range keys { 
fmt.Printf(“Key: %v, Value: %v / “, k, barVal[k]) 
} 
} 
/* Output: 
unsorted: 
Key: indio, Value: 87 / Key: echo, Value: 56 / Key: juliet, Value: 65 / Key: charlie, 
Value: 23 / Key: hotel, Value: 16 / Key: lima, Value: 98 / Key: bravo, Value: 56 / Key: 
alpha, Value: 34 / Key: kilo, Value: 43 / Key: delta, Value: 87 / Key: golf, Value: 34 / 
Key: foxtrot, Value: 12 / 
sorted: 
Key: alpha, Value: 34 / Key: bravo, Value: 56 / Key: charlie, Value: 23 / Key: delta, 
Value: 87 / Key: echo, Value: 56 / Key: foxtrot, Value: 12 / Key: golf, Value: 34 / Key: 194 
Ivo Balbaert 
hotel, Value: 16 / Key: indio, Value: 87 / Key: juliet, Value: 65 / Key: kilo, Value: 43 
/ Key: lima, Value: 98 / 
*/ 
But if what you want is a sorted list you better use a slice of structs, which is more efficient: 
type struct { 
key string 
value int 
} 
8.6 Inverting a map 
By this we mean switching the values and keys. If the value type of a map is acceptable as a key 
type, and the map values are unique, this can be done easily: 
Listing 8.7—invert map.go
package main 
import ( 
“fmt” 
) 
var ( 
barVal = map[string]int{“alpha”: 34, “bravo”: 56, “charlie”: 23, 
“delta”: 87, “echo”: 56, “foxtrot”: 12, “golf”: 34, “hotel”: 16, 
“indio”: 87, “juliet”: 65, “kilo”: 43, “lima”: 98} 
) 
func main() { 
invMap := make(map[int]string, len(barVal)) 
for k, v := range barVal { 
invMap[v] = k 
} 
fmt.Println(“inverted:”) 
for k, v := range invMap { 
fmt.Printf(“Key: %v, Value: %v / “, k, v) 
} 
} 
/* Output: 
inverted:The Way to Go 
Key: 12, Value: foxtrot / Key: 16, Value: hotel / Key: 87, Value: delta / Key: 23, 
Value: charlie / 
Key: 65, Value: juliet / Key: 43, Value: kilo / Key: 56, Value: bravo / Key: 98, 
Value: lima / 
Key: 34, Value: golf / 
*/ 
This goes wrong of course when the original value items are not unique; in that case no error occurs, 
but the processing of the inverted map is simply stopped when a nonunique key is encountered, 
and it will most probably not contain all pairs from the original map! A solution is to carefully test 
for the uniqueness and making use of a multi-valued map, in this case of type map[int][]string 
Exercise 8.2: map drinks.go 
Construct a collection which maps English names of drinks to the French (or your native language) 
translations; print first only the drinks available, and then print both (the name and the translation). 
Then produce the same output, but this time the English names of the drinks must be sorted. 
195196 
Chapter 9—Packages 
A The standard library 
9.1 Overview of the standard library. 
The Go-distribution contains over 150 standard built-in packages for common functionality, like 
fmt, os, . . . , as a whole designated as the standard library, for the most part (except some low level 
routines) built in Go itself. They are documented at: http://golang.org/pkg/ 
In the examples and exercises throughout the book, we use the packages of the standard library; for 
a quick index and practical examples, see: References in the text to Go—packages p. 350 . Here we 
will discuss their general purpose of a number of them grouped by function, we will not go into 

_

_

_

_
_
_

_
_
_

details about their inner structure. 
unsafe: contains commands to step out of the Go type-safety, not needed in normal programs; can 
be useful when interfacing with C/C++ 
syscall—os—os/exec: 
os: 
gives us a platform-independent interface to operating-system functionality; its 
design is Unix-like; it hides the differences between various operating systems to 
give a consistent view of files and other OS-objects. 
os/exec: 
gives you the possibility to run external OS commands and programs. 
syscall: 
is the low-level, external package, which provides a primitive interface to the 
underlying OS ‘s calls. 
As an example of its power, here is a Go-program to make a Linux-machine reboot (start with sudo 
./6.out):The Way to Go 
197 
Listing 9.1 reboot.go: 
package main 
import ( 
“syscall” 
) 
const LINUX REBOOT MAGIC1 uintptr = 0xfee1dead 
_
const LINUX REBOOT MAGIC2 uintptr = 672274793 
_
const LINUX REBOOT CMD RESTART uintptr = 0x1234567 
_
_
func main() { 
syscall.Syscall(syscall.SYS REBOOT, 
LINUX REBOOT MAGIC1, 
_
LINUX REBOOT MAGIC2, 
_
LINUX REBOOT CMD RESTART) 
_
} 
archive/tar and /zip—compress: 
functionality for (de)compressing files. 
fmt—io—bufio—path/filepath—flag: 
fmt 
contains functionality for formatted input-output. 
io: 
provides basic input-output functionality, mostly as a wrapper around os-functions. 
bufio: wraps around io to give buffered input-output functionality. 
path/filepath: routines for manipulating filename paths targeted at the OS used. 
flag: functionality to work with command-line arguments 
strings—strconv—unicode—regexp—bytes: 
strings: 
for working with strings. 
strconv: 
converting them to basic data types. 
unicode: 
special functions for Unicode characters. 
regexp: 
provides pattern-search functionality in complex strings. 
bytes: 
contains functions for the manipulation of byte slices. 
index/suffixarray: for very fast searching in strings. 
math—math/cmath—math/big—math/rand—sort: 
math: 
basic mathematical constands and functions. 
math/cmath: 
manipulations with complx numbers. 
math/rand: 
contains pseudo-random number generators. 
sort 
functionality for sorting arrays and user-defined collections. 
math/big: 
multiprecision arithmetic for working with arbitrarily large integers and rational 
numbers.198 
Ivo Balbaert 
container: /list—ring—heap: implement containers for manipulating collections: 
list: to work with doubly linked lists. 
For example, to iterate over a list(where l is a *List): 
for e := l.Front(); e != nil; e = e.Next() { 
// do something with e.Value 
} 

_

ring: to work with circular lists. 
time—log: 
time: basic functionality for working with times and dates. 
log: functionality for logging information in a running program; we’ll use it throughout 
examples in the following chapters. 
encoding/json—encoding/xml—text/template: 
encoding/json: implements the functions for reading/decoding as well as writing/encoding data 
in JSON forwmat 
encoding/xml: simple XML 1.0 parser; for examples of json and xml: see § 12.9/10 
text/template: to make data-driven templates which can generate textual output mixed with data, 
like HTML (see § 15.7) 
net—net/http—html: (see chapter 15) 
net: basic functions for working with network-data 
http: functionality for parsing HTTP requests/replies, provides an extensible HTTP server and 
a basic client. 
html: parser for HTML5. 
crypto—encoding—hash—…: a multitude of packages for en- and decrypting data. 
runtime—reflect: 
runtime: 
operations for interacting with the Go-runtime, such as the garbage collection and 
goroutines. 
reflect: 
implements runtime introspection, allowing a program to manipulate variables 
with arbitrary types. 
The package exp contains ‘experimental’ packages, that is new packages being build. When they 
have matured enough they become independent packages at the next stable release. If a previous 
version existed, then this is moved to package old, in fact a recycle bin for deprecated packages. 
However the Go 1 release does not contain the old and exp packages.The Way to Go 
199 
Exercise 9.1: dlinked list.go 
Use the package container/list to construct a double linked list, put the values 101,102,103 in it 
and make a printout of the list. 
Exercise 9.2: size int.go 
Use a function from the unsafe package to test the size of an int variable on your computer. 
9.2 The regexp package. 
For info about regular expressions and the syntax it uses, see: http://en.wikipedia.org/wiki/ 
Regular expression 
In the following program we want to search a string pattern pat in a string searchIn. 
Testing if the pattern occurs is easy, just use Match: 
ok,   := regexp.Match(pat, [] 
byte(searchIn)) 
where ok will be true or false, or use MatchString: 
ok,   := regexp.MatchString(pat, 
_
searchIn) 
For more functionality, you must first make a (pointer to a) Regexp object from the pattern; this 
is done through the Compile function. Then we have at our disposal a whole number of Match-, 
Find- and Replace-functions. 
Listing 9.2—pattern.go: 
Package main 
import ( 
“fmt” 
“regexp” 
“strconv” 
) 
func main() { 
// string to search 
searchIn := “John: 2578.34 William: 4567.23 Steve: 5632.18” 
pat := “[0-9]+.[0-9]+” // pattern to search for in searchIn 
f := func (s string) string { 
v,   := strconv.ParseFloat(s, 32)
Ivo Balbaert 
return strconv.FormatFloat(v * 2, ‘f’, 2, 32) 
} 
if ok,   := regexp.Match(pat, []byte(searchIn)); ok { 
fmt.Println(“Match found!”) 
} 
re,   := regexp.Compile(pat) 
// replace pat with “##.#” 
str := re.ReplaceAllString(searchIn, “##.#”) 
fmt.Println(str) 

200 

_

_

_

_

_

_

// using a function : 
str2 := re.ReplaceAllStringFunc(searchIn, f) 
fmt.Println(str2) 
} 
/* Output: 
Match found! 
John: ##.# William: ##.# Steve: ##.# 
John: 5156.68 William: 9134.46 Steve: 11264.36 
*/ 
The Compile function also returns an error, which we have safely ignored here because we have 
entered the pattern ourselves and know that it is a valid regular expression. Should the expression 
be entered by the user or taken from a data source, then it is necessary to check this parsing error. 
In this example we could also have used the function MustCompile which is like Compile but panics 
(stopping the program with an error message, see § 13.2) when the pattern is not a valid regular 
expression. 
9.3 Locking and the sync package. 
In more complex programs different parts of the application may execute simultaneously or 
concurrently as this is technically called, usually by executing each part of the program on a different 
thread of the operating system. When these different parts share and work with the same variables, 
most likely problems occur: the order in which these shared variables are updated cannot be 
predicted and hence also their values are unpredictable! (this is commonly called a race condition: 
the threads race for the updates of the variables). This is of course intolerable in a correct program, 
so how do we solve this issue? 
The classic approach is to let only one thread at a time change the shared variable: the code in 
which the variable is changed (called the critical section) is locked when a thread starts executing, The Way to Go 
201 
so no other thread can start with it. Only when the executing thread has finished the section an 
unlock occurs, so another thread can access it. 
In particular the map type which we have studied in this chapter does not contain any internal 
locking to achieve this effect (this is left out for performance reasons); it is said that the map type 
is not thread-safe. So when concurrent accesses happen to a shared map datastructure, corrupted, 
that means not correct, map data can result. 
In Go this kind of locking is realized with the Mutex variable of the sync package . sync comes from 
synchronized, here meaning the threads are synchronized to update the variable(s) in an orderly 
fashion. 
A sync.Mutex is a mutual exclusion lock: it serves to guard the entrance to the critical section of code 
so that only one thread can enter the critical section at one time. 
Suppose Info is a shared memory variable which must be guarded, then a typical technique is to 
include a mutex in it, like: 
import “sync” 
type Info struct { 
mu sync.Mutex 
// … other fields, e.g.: 
Str 
string 
} 
A function which has to change this variable could then be written like: 
func Update(info *Info) { 
info.mu.Lock() 
// critical section: 
info.Str = // new value 
// end critical section 
info.mu.Unlock() 
} 
An example of its usefulness is a shared buffer, which has to be locked before updating: the 
SyncedBuffer: type SyncedBuffer struct{ 
lock 
sync.Mutex 
buffer bytes.Buffer 
}Ivo Balbaert 
The sync package also has a RWMutex: a lock which allows many reader threads by using RLock(), 
but only one writer thread. If Lock() is used, the section is locked for writing as with the normal 
Mutex. It also contains a handy function once.Do(call) where once is a variabole of type Once, 
which guarantees that the function call will only be invoked 1 time, regardless of how many once. 
Do(call) ‘s there are. 
For relatively simple situations using locking through the sync package so that only one thread at 
a time can access the variable or the map will remedy this problem. If this slows done the program 
too much or causes other problems, the solution must be rethought with goroutines and channels 
in mind: this is the technology proposed by Go for writing concurrent applications. We will go 
deeply into this in chapter 14, in § 14.7 we will also compare the two approaches. 

